# 12 Сетевые уровни и протокол IP
## Введение в стек TCP/IP
### Уровни
![Стек TCP/IP](resources/tcp_ip_12_1.png)

Что представляет собой стек TCP/IP

### Application Layer (Прикладной уровень). 
Большая часть протоколов, работающих в рамках модели клиент-сервер, относится к прикладному уровню (DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS. curl supports TLS certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies (SOCKS4, SOCKS5, HTTP and HTTPS), HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate, Kerberos, Bearer tokens and AWS Sigv4), file transfer resume, proxy tunneling, HSTS, Alt-Svc, unix domain sockets, HTTP compression (gzip, brotli and zstd), etags, parallel transfers, DNS-over-HTTPS). На этом уровне задаётся вопрос “ЧТО должно быть отправлено и получено”.
### Transport Layer (Транспортный уровень). 
Самые распространённые протоколы транспортного уровня это TCP, UDP. Протоколы транспортного уровня описывают КАК ИМЕННО запросы и ответы должны отправляться и приниматься: какой порт использовать, нужно ли проверять целостность данных и очерёдность пакетов, нужно ли повторно отправлять потерянные пакеты и т. д.
### Network Layer (Сетевой уровень).
Предназначен для адресации и поиска узла назначения, а также для маршрутизации. В модели TCP/IP сетевой уровень представлен протоколом IP (Internet Protocol — межсетевой протокол).
### Datalink Layer / Interface Layer (Уровень сетевого интерфейса, он же "канальный уровень", либо "уровень сетевого доступа").
Уровень служит интерфейсом между программным обеспечением (ПО) и физическими устройствами, например адаптерами для Ethernet, Wi-Fi, Bluetooth или модемами DSL.  Этот уровень также применяется для соединения устройств, находящихся в одной локальной сети, где используются аппаратные адреса без обращения к IP-адресам.
### Физический уровень (Physical Layer).
Он располагается после уровня сетевого интерфейса и используется для передачи данных по физической среде, например медному проводу, оптическому волокну или воздуху. На этом уровне нет программных протоколов, только физические сигналы.

*В идеальном случае ПО каждого уровня можно легко заменить, не затрагивая другие уровни*
### Инкапсуляция
Уровни модели TCP/IP связаны друг с другом посредством инкапсуляции, то есть помещения простых объектов в более сложные.
### cURL<a id="curl"></a>
```curl [options...] [url]```

cURL означает Client for URL (программный клиент для URL). Это многофункциональный инструмент для взаимодействия с веб-серверами и API:
+ поддерживает все методы HTTP-запросов
+ поддерживаемые протоколы: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS. curl supports TLS certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies (SOCKS4, SOCKS5, HTTP and HTTPS), HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate, Kerberos, Bearer tokens and AWS Sigv4), file transfer resume, proxy tunneling, HSTS, Alt-Svc, unix domain sockets, HTTP compression (gzip, brotli and zstd), etags, parallel transfers, DNS-over-HTTPS)
+ есть возможность скачивать и загружать файлы
+ поддерживает применение cookie
+ поддерживает аутентификацию
+ поддерживает конвейерную обработку HTTP (pipelining)
+ поддерживает прокси-серверы с проверкой подлинности (протоколы HTTP и Socks)
+ позволяет управлять заголовками

Опции команды:
+ -X / --request — указывает применяемый метод HTTP: curl -v -X POST https://example.org/index.html
+ -d / --data — задаёт содержимое тела запроса.
+ -H — определяет заголовки запроса.
+ -u — позволяет передать имя пользователя и пароль, если серверу требуется проверка подлинности.
+ -k — предписывает программе cURL игнорировать проблемы, связанные с сертификатом безопасности (применение этой опции небезопасно!).
+ -v — переключение в режим подробного вывода (чтобы получить больше сведений).

**Примеры**
1. GET-запросы:
   1. ```curl http://example.com``` - вывод в терминал
   2. ```curl http://example.com -o example.html``` - вывод в файл
2. Отправка заголовков
   1. ```curl -H "User-Agent: Mozilla/5.0" http://example.com``` - отправка заголовка
   2. ```curl -H "User-Agent: Mozilla/5.0" -H "Accept: application/json" http://example.com``` - отправка нескольких заголовков
3. POST-запросы
   1. ```curl -X POST -d "username=user&password=pass" http://example.com/login``` - отправка данных формы
   2. ```curl -X POST -H "Content-Type: application/json" -d '{"name": "Petty", "status": "available"}' 'https://petstore.swagger.io/v2/pet'``` - отправка POST-запроса с JSON-данными
4. Аутентификация
   1. ```curl -u username:password http://example.com``` - базовая аутентификация
   2. ```curl -H "Authorization: Bearer YOUR_TOKEN" http://example.com``` - запрос с токеном аутентификации
5. Загрузка файлов
   1. ```curl -O http://example.com/file.zip``` - загрузка файла с указанного URL
   2. ```curl -o myfile.zip http://example.com/file.zip``` - загрузка файла и сохранения его с указанным именем
6. UPLOAD файлов на сервер
   1. ```curl -X POST -F "file=@/path/to/file" http://example.com/upload``` - с использованием метода POST
7. Отправка данных с PATCH-запросом
   1. ```curl -X PATCH -H "Content-Type: application/json" -d '{"age":30}' http://example.com/users/123``` - отправка PATCH-запроса с JSON-данными
8. Просмотр заголовков ответа
   1. ```curl -I http://example.com``` - просмотр только заголовков ответа
   2. ```curl -v http://example.com``` - режим полезен для отладки, так как он показывает процесс подключения и отправки запроса, а также подробные заголовки ответа
9. Выполнение запросов через прокси
   1.  ```curl -x http://proxy.example.com:8080 http://example.com``` - выполнение запроса через HTTP-прокси
   2.  ```curl --socks5-hostname 127.0.0.1:1080 http://example.com``` - выполнение запроса через SOCKS-прокси
   3.  ```curl -x http://username:password@proxy.example.com:8080 http://example.com``` или ```curl -x http://proxy.example.com:8080 --proxy-user username:password http://example.com``` - аутентификация на прокси-сервере
10. Обработка редиректов
    1.  ```curl -L http://example.com``` - автоматическое следование редиректам. Используя опции -L, --max-redirs и другие параметры, можно настроить curl для автоматического следования за редиректами, ограничить их количество и отладить процесс редиректов
11. Сохранение cookies и использование их в последующих запросах
    1.  ```curl -c cookies.txt http://example.com``` - сохранение cookies в файл
    2.  ```curl -b cookies.txt http://example.com``` - использование сохраненных cookies в запросе
12. Ограничение скорости
    1.  ```curl --limit-rate 100K http://example.com/file.zip``` - ограничение скорости загрузки
13. Таймауты
    1.  ```curl --connect-timeout 10 http://example.com``` - установка максимального времени ожидания для соединения
    2.  ```curl --max-time 20 http://example.com``` -установка максимального времени выполнения запроса
14. Опции SSL/TLS
    1.  ```curl -k https://example.com``` - игнорирование проверки SSL-сертификата (не рекомендуется)
    2.  ```curl --cert /path/to/cert.pem https://example.com``` - указание файла сертификата клиента
### Прохождение данных через стек TCP/IP
#### 1. Application Layer. 
На этом  уровне приложения генерируют данные, которые необходимо передать по сети. Эти данные передаются на транспортный уровень.
#### 2. Transport Layer. 
После Application Layer (например, после выполнения команды curl 192.168.100.5) операционная система передаст на Transport Layer, на котором ОС поместит ваши данные в пакет TCP (или UDP).

<img src="resources/tcp.png" alt="Структура TCP-пакета" width="65%"/>

Пакет TCP содержит множество полей, в т.ч. порт назначения (Destination Port у нас - 80), порт источник (Source Port), контрольная сумма (Checksum), данные (Payload - ваш запрос HTTP).
#### 3. Network Layer. 
Transport Layer не занимается адресацией. Эта обязанность лежит на нижележащем уровне, использующем протокол IP.

![Структура IP-пакета](resources/ip.jpg)

На этом уровне ОС поместит в поле:
+ Protocol (протокол) специальное число, говорящее получателю, что в поле Data лежит пакет TCP
+ Source address (адрес источника, отправителя) IP-адрес вашего компьютера
+ Destination address (адрес назначения, получателя) помещает IP-адрес удалённого узла
+ Data весь пакет TCP
+ TTL (Time to live — время существования) максимальное количество шлюзов, через которое может пройти пакет. Значение по умолчанию: 64 для Linux и macOS, 128 для современных версий Windows
#### 4. Datalink Layer / Interface Layer. 
На этом уровне:
+ все предыдущие данные приложения и пакеты протоколов IP и TCP/UDP будут упакованы в поле Data кадра Ethernet (если используется именно Ethernet).
+ Поле DA будет заполнено MAC-адресом узла назначения (или MAC-адресом шлюза, если таковой применяется), полученным с помощью протокола ARP. 
+ Аппаратный адрес вашего сетевого адаптера будет расположен в поле Source address (SA).
+ В поле CRC будет помещена контрольная сумма, необходимая для проверки того, что у отправителя и у получателя одинаковые копии данных

![Структура кадра Ethernet](resources/ethernet.png)
## Основы IP-сетей
### IP адресация
1. IP-адрес - xxx.yyy.zzz.qqq
2. Маска подсети - число между 0 и 32 или формат IP-адреса. Маска подсети должна состоять из непрерывного блока единиц, за которым следуют непрерывные нули. Например, маски подсети "24" и "255.255.255.0" эквивалентны. Маска подсети "/24" означает, что 24 бита из 32 используются для обозначения сети, а остальные 8 бит для обозначения узлов.
3. С помощью побитовой операции между IP-адресом и маской компьютер вычисляет диапазон адресов подсети. Например, узел с IP-адресом 192.168.0.1 и маской подсети 24 является частью подсети 192.168.0.0/24, включающей 256 адресов от 192.168.0.0 до 192.168.0.255. Расчёты проводятся с помощью простой двоичной арифметики: 2 ^ (32 - 24) = 2 ^ 8 = 256.

```ipcalc xxx.yyy.zzz.qqq[/ss]``` - утилита командной строки, которая предоставляет информацию о сетевых параметрах для заданного IP-адреса и маски подсети, например:
```console
vboxuser@devDebian:~$ ipcalc 192.168.33.62
Address:   192.168.33.62        11000000.10101000.00100001. 00111110
Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
=>
Network:   192.168.33.0/24      11000000.10101000.00100001. 00000000
HostMin:   192.168.33.1         11000000.10101000.00100001. 00000001
HostMax:   192.168.33.254       11000000.10101000.00100001. 11111110
Broadcast: 192.168.33.255       11000000.10101000.00100001. 11111111
Hosts/Net: 254                   Class C, Private Internet
```
### Маршрутизация
+ Идея IP-сетей - разделить адресное пространство на подсети, поместить узлы внутрь подсетей, а затем, при необходимости, обеспечить установку соединения между подсетями. 
+ Маршрутизация - механизм взаимодействия между сетями.

Для отображения таблицы маршрутизации на вашем компьютере (Linux) используется команда ```ip route list```:
```console
[user@linux]$ ip route list
default via 192.168.0.1 dev eth0 proto dhcp src 192.168.0.134 metric 1024
10.8.0.0/24 dev tap0 proto kernel scope link src 10.8.0.1
192.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.134
```

Каждая строка таблицы маршрутизации содержит три основных объекта:
1. Первая строка (с default):
+ ```default```: Этот маршрут является маршрутом по умолчанию. Все пакеты, которые не соответствуют другим маршрутам изтаблицы маршрутизации, будут отправляться по этому маршруту.
+ ```via 192.168.0.1```: Этот маршрут направляет пакеты через шлюз с IP-адресом 192.168.0.1.
+ ```dev eth0```: Этот маршрут использует интерфейс eth0 для отправки пакетов.
+ ```proto dhcp```: Маршрут получен через DHCP
+ ```src 192.168.0.134```: IP-адрес источника для отправляемых пакетов, когда они отправляются через этот маршрут.
+ ```metric 1024```: Метрика этого маршрута. Метрика используется для определения приоритета маршрута; меньшее значение метрики указывает на более предпочтительный маршрут.
1. Вторая строка (остальные варианты, без default). Третья строка - аналогична:
+ ```10.8.0.0/24```: Этот маршрут указывает на сеть с адресом 10.8.0.0 и маской подсети /24
+ ```dev tap0```: Этот маршрут использует интерфейс tap0 для отправки пакетов.
+ ```proto kernel```: Маршрут был добавлен ядром.
+ ```scope link```: Маршрут ограничен текущим интерфейсом.
+ ```src 10.8.0.1```: IP-адрес источника для отправляемых пакетов, когда они отправляются через этот маршрут.

#### Системные инструменты для прослеживания маршрута от вашего компьютера к удалённому узлу
+ ```ip route get xxx.yyy.zzz.qqq``` - вернет соответствующее правило для узла назначения (xxx.yyy.zzz.qqq) из таблицы маршрутизации  
+ ```traceroute xxx.yyy.zzz.qqq``` (ОС Linux, macOS) или ```tracert``` (ОС Windows) - сетевая утилита, возращающая список транзитных узлов между вами и удалённым узлом (xxx.yyy.zzz.qqq). Эта команда отправляет узлу назначения специальные пакеты IP со значением поля TTL, начинающимся с 1 (увеличивая значение с каждым шагом на 1 до момента получения ответа от узла назначения). Благодаря такому значению промежуточные шлюзы отправляют обратно другой специальный пакет (об исчерпании поля TTL), таким образом обнаруживая себя (если это не отключено в настройках шлюза).
### Откуда берутся IP-адреса
Пространство IP-адресов:
+ частные
+ глобальные
#### Частные области
Частные области - зарезервированы в документации межсетевого протокола (Internet Protocol — IP) как подсети для создания локальных сетей. Эти сети не участвуют в глобальной маршрутизации

Список зарезервированных для этого подсетей: 10.0.0.0/8, 172.16.0.0/12, 192.0.0.0/24 и 192.168.0.0/16

Два подхода назначения IP-адресов в локальных сетях:
+ использование протокола DHCP (Dynamic Host Configuration Protocol — протокол динамического конфигурирования узлов) для автоматического назначения IP-адресов, адресов подсетей, маршрутов и адресов серверов DNS (применяется большинством современных маршрутизаторов);
+ использование статической конфигурации, полученную от вашего интернет-провайдера или системного администратора, задавая адреса вручную и используя одну из частных подсетей.
#### Глобальные (публичными) области
Публичный адрес выдает интернет-провайдер, а те - у специальных компаний, называемых брокерами IP-адресов, или у региональных интернет-регистраторов
### NAT: преобразование сетевых адресов
![NAT: что происходит, если у вашего компьютера нет глобального IP-адреса](resources/net02-06-NAT.png)

Принцип работы NAT, если у компьютера нет глобального IP-адреса

#### Пояснение на примере работы NAT
Дано:
+ у нас есть адрес 10.0.0.2 в локальной сети 10.0.0.0/24.
+ у нашего маршрутизатора есть два интерфейса с адресами 10.0.0.1 и 1.2.3.4. 
+ Мы хотим отправить запрос публичному серверу DNS с адресом 8.8.8.8.
Тогда:
+ наш компьютер на сетевом уровне упаковывает запрос в пакет IP с адресом назначения 8.8.8.8, ищет в таблице маршрутизации маршрут для адреса 8.8.8.8 и даёт понять, что пакет должен отправляться на маршрутизатор посредством его MAC-адреса. 
+ маршрутизатор получает пакет. Анализируя пакет IP, понимает, что он не конечный получатель. В этот момент в игру и вступает **механизм NAT (Network Address Translation — преобразование сетевых адресов)**.
  1. Маршрутизатор ищет в своей таблице маршрутизации маршрут к узлу назначения. В нашем случае он выберет интерфейс с публичным адресом 1.2.3.4
  2. Маршрутизатор сохраняет у себя информацию, что он теперь является промежуточным узлом между 10.0.0.2 и 8.8.8.8
  3. Маршрутизатор изменяет адрес источника в вашем пакете IP: с 10.0.0.2 на публичный адрес 1.2.3.4
  4. Маршрутизатор уменьшает значение поля TTL в вашем пакете IP на единицу. Это поле не позволяет пакету бесконечно блуждать по сети в случае образования маршрутной петли (контура). Каждый последующий маршрутизатор выполнит те же действия. Пакет с обнулившимся полем TTL будет отброшен
  5. Удалённый сервер DNS с адресом 8.8.8.8 обработает запрос и отправит ответ в новом пакете IP маршрутизатору с адресом 1.2.3.4, так как он думает, что узел с адресом 1.2.3.4 и есть автор запроса
  6. Маршрутизатор получает пакет с ответом от узла с адресом 8.8.8.8, проверяет свой список соединений и определяет, что этот пакет предназначен узлу с адресом 10.0.0.2
  7. Маршрутизатор изменяет в пакете адрес назначения с 1.2.3.4 на 10.0.0.2 и отправляет пакет клиенту.
### Localhost
Localhost - важная частная подсеть — ```127.0.0.0/8```

Используется:
+ когда вашему компьютеру нужно установить соединение с какой-либо сетевой службой, работающей локально (например, тестирование серверного ПО)
+ В современных дистрибутивах Linux, где DNS-сервер устанавливается локально (простое ПО для кэширования запросов и ускорения работы). Поэтому ваша операционная система устанавливает соединение с адресом 127.0.0.1 и портом 53 каждый раз, когда нужно преобразовать какое-либо имя в IP-адрес

**Как это работает:**
1. Есть виртуальный сетевой интерфейс, реализующий механизм «обратной петли», обычно с именем ```lo``` (на ОС Linux) с назначенным адресом ```127.0.0.1``` и маской подсети ```255.0.0.0```. *Хитрость интерфейса с обратной петлей в том, что он всегда ответит, на какой бы адрес этой подсети вы не отправили сообщение*. Поэтому если вы попытаетесь подключиться к любому адресу из подсети 127.0.0.0/8, то результат всегда будет одинаков.
2. Есть специальное имя ```localhost``` (локальный узел), служащее псевдонимом для узла с адресом ```127.0.0.1```. Его можно использовать вместо IP-адреса, если вам так удобнее.
3. Когда вы пытаетесь подключиться к ```127.0.0.1```, операционная система видит, что этот адрес относится к маршруту, связывающему подсеть ```127.0.0.0/8``` с интерфейсом ```lo```. Затем ваши данные будут отправлены виртуальному интерфейсу с обратной петлёй, а операционная система получит входящее сообщение, обработает его и самостоятельно ответит.
## DNS: Система доменных имён (Domain Name System)
Система доменных имён (Domain Name System) предназначена для преобразования доменных имён в IP-адреса
### Общий порядок преобразования имени в IP-адрес
1. ОС начинает поиск соответствия IP-адреса указанному доменному имени узла с файла ```/etc/hosts```, где локально хранятся пары «имя узла — IP-адрес»
2. В случае неудачи ОС возьмёт адрес DNS сервера из файла ```/etc/resolv.conf``` и инициирует отправку запроса ему:
   1. в ```/etc/resolv.conf``` часто указано, что основной DNS-сервер расположен локально на 127.0.0.1
### Преобразование имени в IP-адрес посредством утилит командной строки
#### host
1. Преобразование доменного имени в IP-адрес 
```console
vboxuser@devDebian:~$ host example.com
example.com has address 93.184.215.14
example.com has IPv6 address 2606:2800:21f:cb07:6820:80da:af6b:8b2c
example.com mail is handled by 0
```
2. Преобразование IP-адреса в доменное имя
```console
vboxuser@devDebian:~$ host 8.8.8.8
8.8.8.8.in-addr.arpa domain name pointer dns.google.
```
3. Получение информации о почтовых серверах (MX-записи) для домена
```console
vboxuser@devDebian:~$ host -t mx example.com
example.com mail is handled by 0 .
```
4. Получение информации о сервере имен (NS-записи) для домена
```console
vboxuser@devDebian:~$ host -t ns example.com
example.com name server a.iana-servers.net.
example.com name server b.iana-servers.net.
```
5. Запрос определенного типа записи, например, текстовой записи (TXT)
```console
vboxuser@devDebian:~$ host -t txt example.com
example.com descriptive text "v=spf1 -all"
example.com descriptive text "wgyf8z8cgvm2qmxpnbnldrcltvk4xqfn"
```
6. Использование определенного DNS-сервера для запроса
```console
vboxuser@devDebian:~$ host example.com 8.8.8.8
Using domain server:
Name: 8.8.8.8
Address: 8.8.8.8#53
Aliases: 

example.com has address 93.184.215.14
example.com has IPv6 address 2606:2800:21f:cb07:6820:80da:af6b:8b2c
example.com mail is handled by 0 .
```
#### dig
dig - мощный инструмент для преобразования имён В UNIX-подобных системах. Выводит большой объём информации
1. Запрос A-записи (IP-адрес) для домена
```console
$ dig example.com

; <<>> DiG 9.16.1-Ubuntu <<>> example.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 12345
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      A

;; ANSWER SECTION:
example.com.            3600    IN      A       93.184.216.34

;; Query time: 29 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:24:56 UTC 2021
;; MSG SIZE  rcvd: 65
```
2. Запрос MX-записей (почтовых серверов) для домена
```console
$ dig example.com MX

; <<>> DiG 9.16.1-Ubuntu <<>> example.com MX
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 67890
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 2

;; QUESTION SECTION:
;example.com.                   IN      MX

;; ANSWER SECTION:
example.com.            3600    IN      MX      10 mail1.example.com.
example.com.            3600    IN      MX      20 mail2.example.com.

;; Query time: 30 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:26:34 UTC 2021
;; MSG SIZE  rcvd: 95
```
3. Запрос NS-записей (серверов имен) для домена
```console
$ dig example.com NS

; <<>> DiG 9.16.1-Ubuntu <<>> example.com NS
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 13579
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3

;; QUESTION SECTION:
;example.com.                   IN      NS

;; ANSWER SECTION:
example.com.            3600    IN      NS      ns1.example.com.
example.com.            3600    IN      NS      ns2.example.com.

;; ADDITIONAL SECTION:
ns1.example.com.        3600    IN      A       192.0.2.1
ns2.example.com.        3600    IN      A       192.0.2.2

;; Query time: 31 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:27:45 UTC 2021
;; MSG SIZE  rcvd: 116
```
4. Запрос TXT-записей для домена
```console
$ dig example.com TXT

; <<>> DiG 9.16.1-Ubuntu <<>> example.com TXT
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 24680
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      TXT

;; ANSWER SECTION:
example.com.            3600    IN      TXT     "v=spf1 include:_spf.example.com ~all"

;; Query time: 32 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:28:56 UTC 2021
;; MSG SIZE  rcvd: 90
```
5. Запрос с указанием конкретного DNS-сервера
```console
$ dig @8.8.8.8 example.com

; <<>> DiG 9.16.1-Ubuntu <<>> @8.8.8.8 example.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11223
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      A

;; ANSWER SECTION:
example.com.            3600    IN      A       93.184.216.34

;; Query time: 28 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:30:12 UTC 2021
;; MSG SIZE  rcvd: 65
```
6. Запрос PTR-записей для обратного DNS-запроса (преобразование IP-адреса в доменное имя)
```console
$ dig -x 8.8.8.8

; <<>> DiG 9.16.1-Ubuntu <<>> -x 8.8.8.8
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 98765
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;8.8.8.8.in-addr.arpa.          IN      PTR

;; ANSWER SECTION:
8.8.8.8.in-addr.arpa.   86400   IN      PTR     dns.google.

;; Query time: 27 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:31:23 UTC 2021
;; MSG SIZE  rcvd: 85
```
#### nslookup 
Используется для выполнения DNS-запросов и получения информации о DNS-записях. Она проще в использовании, чем dig, но менее гибкая
1. Запрос A-записи (IP-адрес) для домена
```console
$ nslookup example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   example.com
Address: 93.184.216.34
```
2. Запрос MX-записей (почтовых серверов) для домена
```console
$ nslookup -query=mx example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     mail exchanger = 10 mail1.example.com.
example.com     mail exchanger = 20 mail2.example.com.
```
3. Запрос NS-записей (серверов имен) для домена
```console
$ nslookup -query=ns example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     nameserver = ns1.example.com.
example.com     nameserver = ns2.example.com.
```
4. Запрос TXT-записей для домена
```console
$ nslookup -query=txt example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     text = "v=spf1 include:_spf.example.com ~all"
```
5. Использование конкретного DNS-сервера для запроса
```console
$ nslookup example.com 8.8.8.8

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   example.com
Address: 93.184.216.34
```
6. Обратный DNS-запрос (преобразование IP-адреса в доменное имя)
```console
$ nslookup 8.8.8.8

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
8.8.8.8.in-addr.arpa   name = dns.google.
```
#### FQDN (Fully Qualified Domain Name — полностью определённое имя домена)
+ На самом деле нужно преобразовывать имя с точкой на конце — www.example.com., чтобы быть уверенными, что это полное имя, известное также как FQDN
+ каждое доменное имя может быть разделено точками на зоны (www, example и com)
+ Если зона существует, то должен быть по крайней мере один сервер DNS, располагающий полной информацией об этой зоне. Такие серверы называются **полномочными (authoritative) серверами DNS**
![Иерархическая структура системы доменных имён DNS](resources/net02-07-dns-tree.jpg)

Иерархическая структура системы доменных имён DNS

+ Группа корневых серверов (зелёного цвета на схеме), хранит информацию о зонах первого уровня (жёлтого цвета) и об их полномочных серверах. 
+ серверы зон первого уровня располагают информацией о зонах второго уровня (красный цвет)
+ серверы зон второго уровня и следующих работают в рекурсивном режиме (т.е. отвечают на все запросы про нижестоящие доменные имена), поэтому можно запрашивать у серверов второго уровня информацию о доменах нижних уровней
#### Виды DNS-серверов
##### Авторитативный сервер
1. Функция: Хранит и предоставляет точные данные о доменах.
2. Кэширование: Хранит официальные записи и не зависит от кэширования для предоставления данных
3. Ответы: Предоставляет окончательный и достоверный ответ для доменов, за которые он ответственен
##### Рекурсивный сервер
1. Функция: Обрабатывает запросы клиентов и ищет необходимую информацию, обращаясь к другим серверам.
2. Кэширование: Может кэшировать ответы на запросы для ускорения последующих запросов, но не хранит официальные записи
3. Ответы: Может предоставлять ответы, которые он закэшировал, или будет делать запросы к другим серверам для получения ответа
##### Пример взаимодействия:
1. Клиент делает запрос на преобразование доменного имени в IP-адрес.
2. Запрос идет к рекурсивному серверу (резолверу).
3. Если рекурсивный сервер не имеет закэшированного ответа, он делает последовательные запросы к другим серверам, начиная с корневых серверов, затем к серверам верхнего уровня (TLD) и, наконец, к авторитативному серверу, который хранит запрашиваемую информацию.
4. Авторитативный сервер возвращает точную информацию.
5. Рекурсивный сервер передает эту информацию клиенту и может закэшировать её для ускорения будущих запросов.

*Примечание:*
+ В большинстве случаев полномочные (Авторитативные) серверы не настроены на работу в качестве преобразователей для «чужих» зон. То есть сервер DNS, ответственный за доменную зону google.com, не ответит на запрос, касающийся зоны wikipedia.org.
#### Записи системы DNS (самые распространённые )
##### Запись "A"
+ используется для преобразования имени домена в IP-адрес
+ у домена может быть несколько записей "A", содержащих несколько IP-адресов, назначенных этому домену. В таком случае ОС выберет адрес из списка случайным образом. Этот механизм называют каруселью, циклическим перебором, алгоритмом кругового обслуживания (round robin). У каждого популярного веб-сайта, например yahoo.com или yandex.ru, одному доменному имени может соответствовать множество IP-адресов, служащих для балансировки нагрузки "каруселью"
+ количество доменных имён, связываемых с одним IP-адресом, не ограничено. Для небольших веб-сайтов обычно множество доменов связано с одним и тем же IP-адресом. Такая конфигурация часто используется для вариантов веб-хостинга, когда на одном веб-сервере может располагаться и работать сотни сайтов с доменными именами наподобие сайт_петра.рф, сайт_ивана.рф или johns-site.com, marys-site.com и т.д.
#### Запись PTR (pointer — указатель)
Выполняет обратную функцию, преобразуя IP-адреса в доменные имена. В большинстве случаев значения записей "A" и PTR не синхронизированы между собой, например A-запись для some-site.com может ссылаться на IP-адрес a.b.c.d, но PTR-запись для IP-адреса a.b.c.d будет ссылаться например на node52.some-webhosting.com. Поэтому обычно лучше опираться на запись "A".
Примечание: в случае с записями PTR только одно (или ни одного) имя FQDN может быть связано с конкретным IP-адресом.
#### CNAME (canonical name — каноническое имя)
Это псевдоним. Например, если у вашего веб-сайта несколько доменных имён, то вы можете привязать одно к другому, указав это имя как псевдоним к имени, содержащемуся в записи "A". Пример: А-запись my-site.com ссылается на IP-адрес a.b.c.d, а доменное имя www.my-site.com с помощью CNAME ссылается на my-site.com.
#### MX (mail exchanger — почтовый обменник)
Это запись, указывающая, какой почтовый сервер  обрабатывает электронную почту этого домена. Для одного домена может быть настроено несколько почтовых серверов.
#### Записи NS (Authoritative Name Server — полномочный сервер имён) и SOA (Start-of-authority — начальная запись зоны)
Содержат сведения о полномочных (Авторитативных) серверах зоны. С помощью этих записей «резолверы» получают информацию о следующем сервере DNS, которому следует оправить запрос. Для одной зоны может быть настроено несколько NS-серверов.
#### Записи SRV (Server selection — выбор сервера) и TXT (Text String — текстовая строка)
Можно использовать для хранения любой текстовой информации. SRV (Server selection — выбор сервера) и TXT (Text String — текстовая строка)

