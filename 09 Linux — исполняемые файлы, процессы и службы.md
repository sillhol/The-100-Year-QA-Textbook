# 09 Linux — исполняемые файлы, процессы и службы
## Исполняемые файлы в Linux
### Команды
При выполнении команд в терминале Linux, на самом деле выполняются:

+ Исполняемые файлы - файлы с установленным битом "x":
  + Двоичные исполняемые файлы, например, написанные на C/C++. Примеры: cat, less, grep. Они аналогичны файлам ".exe" в Windows
  + Скрипты, например, скрипты (сценарии) оболочки, Python и т.д. Примеры: egrep, yum (похожи на ".bat" или ".ps" в Windows).
  + Библиотеки - это двоичные файлы, подобные исполняемым файлам, но очень редко запускаемые напрямую.
  + Все вышеперечисленные исполняемые файлы, представленные в виде символических ссылок на "обычные" файлы с установленным битом "x", что широко распространено в UNIX-подобных системах.
+ Псевдонимы (алиасы) - синонимы команды (или другого псевдонима), выполняемой с определенными опциями или без них, например, псевдоним "ll" часто определяет команду "ls -l".
+ Встроенные команды оболочки. Примеры: cd, alias. При их выполнении не вызывается никакая внешняя команда, вместо этого их выполняет сама командная оболочка

Для выполнения команд пользователя и отображения их вывода используются специальные оболочки входа в систему, такие как **bash**, **zsh** и так далее
### Исполняемые файлы
#### PATH
PATH - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов. Она может быть отображена командой "echo":

```console
localhost:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```
#### Переменные оболочки
Вывод списка переменных оболочки осуществляется командой `env`
#### which
`which` - это команда для показа расположения исполняемого файла в каталогах PATH:
```console
localhost:~# which uname
/bin/uname
```
+ Любой исполняемый файл можно запустить, указав путь к нему.
+ Исполняемый файл, если он находится в директории в списке PATH, может быть запущен путем указания имени файла; путь к файлу указывать не нужно.
+ Поиск в директориях, перечисленных в PATH, выполняется последовательно. Таким образом, если файлы с одинаковым именем существуют в нескольких каталогах PATH, для выполнения будет взят файл из первой директории в переменной PATH.
+ Чтобы запустить исполняемый файл, не находящийся ни в одной из директорий в PATH, необходимо вместо имени файла указать его путь - относительный или абсолютный.
#### Управление задачами, запущенными в терминале
##### Запуск процесса в фоновом режиме
Запустить процесс в фоновом режиме можно, добавив символ `&` в конец команды. Это позволяет вашей командной строке быть доступной для ввода новых команд, пока фоновый процесс выполняет `команду &`, например `gedit &`
##### Приостановка задачи (`Ctrl+Z`)
Когда вы выполняете команду в терминале, она обычно работает в переднем плане (foreground). Если вы хотите временно приостановить выполнение этой команды, вы можете использовать сочетание клавиш `Ctrl+Z`. Это переместит задачу в состояние приостановки (stopped).
##### Перевод задачи в фоновый режим (`bg`)
`bg %ID_задачи` - Возобновляет выполнение приостановленной задачи в фоновом режиме. Если не указать ID задачи, будет использована последняя приостановленная задача. `bg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
##### Возвращение задачи в передний план (`fg`)
`fg %ID_задачи` - Возобновляет выполнение задачи в переднем плане. Если не указать ID задачи, будет использована последняя приостановленная или фоновая задача. `fg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
##### Завершение задачи (`Ctrl+C`)
`Ctrl+C`: Прерывает и завершает текущую задачу в переднем плане
##### Просмотр списка задач (jobs)
`jobs` - Отображает список всех задач в текущем терминале, их статус и ID
##### "Убийство" задачи (`kill`)
`kill %ID_задачи` - Отправляет сигнал `SIGTERM` для завершения указанной задачи. Если задача не завершится, можно использовать сигнал `SIGKILL` для принудительного завершения. *В отличие от команд `fg` и `bg` команда `kill` может завершить любой процесс, если у вас есть его PID (идентификатор процесса)*
##### Символ `%` 
Символ `%` используется для ссылки на задачи, управляемые оболочкой (shell). Он применяется с командами `fg` (`fg %ID_задачи`), `bg` (`bg %ID_задачи`) и `kill` (`kill %ID_задачи`) для указания конкретной задачи по её номеру
#### Встроенные команды и псевдонимы оболочки
Некоторые команды не являются исполняемыми файлами; вместо этого они выступают в качестве так называемых "псевдонимов" и "встроенных модулей оболочки".
##### Встроенная команда (built-in commands)
**Встроенные команды** — это команды, которые являются частью самой оболочки (например, `Bash`) и не существуют как отдельные исполняемые файлы на диске. Они выполняются непосредственно оболочкой:
+ что делает их выполнение быстрее
+ позволяет им иметь доступ к внутренним структурам оболочки, что невозможно для внешних команд.

Когда вы вводите команду в терминале, оболочка сначала проверяет, является ли эта команда встроенной. Если да, она выполняет её напрямую. Если нет, она ищет соответствующий исполняемый файл на диске и запускает его.

*Примеры встроенных команд*: `cd`: изменяет текущий каталог, `pwd`: показывает текущий каталог
##### Псевдонимы оболочки
**"Алиас" (псевдоним)** - это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments". Часто система Linux настроена так, что некоторые псевдонимы для всех пользователей доступны сразу же, например, `ll` (`ls -l`), `la` (`ls -a`).

Команда `alias` - это встроенная команда оболочки, которая возвращает просмотр список зарегистрированных в системе псевдонимов (по умолчанию какие-либо псевдонимы могут отсутствовать).

**Создание псевдонима** 

`alias имя_псевдонима='команда'`
+ Определить псевдоним, поместить его в постоянный файл конфигурации оболочки (в файлах ~/.bashrc и(или) ~/.bash_profile):
  + `echo "alias lf='ls -lF'" >> ~/.bashrc`
  + `bash` - запустить новый экземпляр оболочки (`bash`) для применения обновленной конфигурации
+ Проверка, что псевдоним добавлен - вызвать команду `alias`
+ Определить псевдоним «на ходу» (будет действовать до завершения текущего сеанса оболочки):
  + `localhost:~# alias rm='echo You are trying to execute "rm" with the following arguments: '` - теперь "оригинальную" команду `rm` можно вызвать по абсолютному пути, в таком случае выполнится именно она, а не ее псевдоним: `/bin/rm -f ~/file.to.remove`

**Отмена псевдонима**

Для отмены псевдонима вызвать встроенную команду оболочки `unalias имя_псевдонима` (из файла `~/.bashrc`, если он был туда добавлен, нужно вручную удалить соответствующую строку. Если этого не сделать то после новой сессии bash псевдоним будет снова доступен)
## Процессы и сигналы
### Процессы и демоны
#### Процессы
**Процесс** операционной системы (ОС) — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Если программа заканчивает свою работу, то процесс также прекращает своё существование.

Каждый процесс имеет несколько следующих основных атрибутов:
+ `PID` - идентификатор процесса. Уникален для каждого выполняющегося процесса. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми `PID`.
+ `PPID` — родительский идентификатор (`PID`). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, `PPID` - это `PID` родительского процесса. «Главный» системный процесс называется `init` или `systemd` и обладает `PID` = 1, `PPID` = 0. Он создаётся ядром операционной системы при её загрузке.
+ Пользователь и группа, запустившие программу.
+ Название.
+ Аргументы командной строки (но могут быть переданы процессу не только при запуске из терминала, но и при запуске из скриптов, других программ или системных служб).
+ Управляющий терминал. Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме. 
  + Например, командный интерпретатор `bash`, который обычно запускается при входе пользователя в систему, определённо взаимодействует с терминалом и пользователями, и поэтому у него есть управляющий терминал. 
  + Командная оболочка выполняет команды пользователей, поэтому она (например, `bash`) является родительским процессом всех процессов, запущенных с помощью командной строки
  + В графе "Управляющий терминал" у процесса, который был запущен из графической оболочки (например, OpenOffice), будет указано `?` или "неопределённо", т.к. графический интерфейс инициализирует процесс напрямую и управляющий терминал не наследует
  + Псевдотерминалы: когда открывают новый терминал в графической среде (например, GNOME Terminal или xterm), создается новый псевдотерминал, такой как `pts/0`
#### Демоны
**Демоны** — это особый вид процессов, работающих в фоновом режиме и не взаимодействующий с пользователями посредством терминала. Например, процессы сетевых серверных приложений, отвечающие за обработку входящих запросов по сети, обычно являются демонами. Процесс не обязательно должен быть запущен процессом с PID 1 (обычно это `init` или `systemd`), чтобы стать демоном. Однако, когда процесс становится демоном, он часто отсоединяется от своего родительского процесса и его родительским процессом становится процесс с PID 1 (`init` или `systemd`). Это происходит в процессе “демонизации”, который включает несколько шагов:
1. Форк процесса: Процесс создает копию самого себя.
2. Завершение родительского процесса: Оригинальный процесс завершает свою работу, и дочерний процесс продолжает выполнение.
3. Смена родительского процесса: Дочерний процесс становится “сиротой” и его родительским процессом становится процесс с `PID` 1 (`init` или `systemd`).
4. Отсоединение от управляющего терминала: Процесс отсоединяется от терминала, чтобы не зависеть от него.
5. Смена текущей рабочей директории: Обычно демоны меняют текущую рабочую директорию на корневую (`/`), чтобы избежать блокировки файловых систем.
6. Закрытие файловых дескрипторов: Процесс закрывает все открытые файловые дескрипторы.

Таким образом, «настоящий» процесс-демон обладает следующими свойствами:
+ `PPID` = 1
+ Управляющий терминал отсутствует (в отличие от команды, запущенной из терминала в фоновом режиме с помощью выражения `имя_команды &`, у демона в столбце `TTY` в выводе команды `ps` стоит `?`)
+ В большинстве случаев текущей рабочей директорией демона является `/`.
### Как искать процессы и просматривать их списки
Ниже приводятся некоторые из инструментов и способов получения информации обо всех или конкретных запущенных процессах:
+ `ps` — основной инструмент для отображения списка запущенных процессов
+ `top` - инструмент для отслеживания запущенных процессов в реальном времени, аналог диспетчера задач Windows и мониторинга системы macOS
+ `pgrep` - инструмент для поиска процессов по их названию или аргументам
+ `pstree` - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений
+ В псевдо-каталоге `/proc/PID` содержится много подробных сведений о процессе с идентификатором PID. Очень полезен в некоторых случаях
#### Команда `ps`
Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. Самые полезные ее опции следующие:
+ `-e` для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.
+ `-f` для вывода расширенных сведений о каждом процессе. **По умолчанию** отображается только `PID`(Идентификатор процесса), `TTY` (Терминал, связанный с процессом), `TIME` (Общее время использования процессора процессом), `CMD` (Имя команды, запустившая процесс).
  + `ps -ef` вернет следующий набор полей:
    + `UID`: имя пользователя, запустившего процесс
    + `PID`: идентификатор процесса
    + `PPID`: идентификатор родительского процесса
    + `STIME`: время запуска процесса
    + `TTY` или `TT`: управляющий терминал. Знак «?» показывается для процессов, не связанных с терминалом (таких как демоны)
    + `TIME`: суммарное процессорное время выполнения
    + `CMD`: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если название процесса показано в квадратных скобках, значит, этот процесс является частью ядра ОС.
+ `-u username` для отображения процессов, запущенных пользователем c данным именем (`username`).
+ `-p PID` - для вывода сведений об процессе с данным `PID`
+ `-o` список полей для вывода определённых сведений о процессах (`ps -o pid,ppid,cmd,%cpu,%mem`):
  + `pid`: идентификатор процесса
  + `ppid`: идентификатор родительского процесса
  + `uid`: идентификатор пользователя
  + `user`: имя пользователя
  + `gid`: идентификатор группы
  + `group`: имя группы
  + `comm`: имя команды
  + `cmd`: имя команды с аргументами
  + `etime`: время, прошедшее с момента запуска процесса
  + `time`: общее процессорное время, использованное процессом
  + `stime`: время старта процесса в формате `HH:MM` (часы и минуты)
  + `%cpu` или `c`: процент использования процессора
  + `%mem`: процент использования памяти
  + `vsz`: размер виртуальной памяти
  + `rss`: размер резидентной памяти
  + `sid`: идентификатор сессии. *Сессия в контексте операционных систем — это набор процессов, которые были запущены в рамках одной сессии пользователя (временном промежутке, начиная с момента аутентификации и заканчивая выходом из системы). Каждая сессия имеет уникальный идентификатор сессии (`SID`). Сессия может включать процессы, запущенные в разных терминалах. Например, если вы открыли несколько терминалов в одной графической сессии, все процессы в этих терминалах будут принадлежать одной сессии.*
  + `tty`: терминал, связанный с процессом. *Терминал может включать процессы, принадлежащие разным сессиям. Например, если вы используете виртуальные терминалы (TTY), или в терминале запускаете процессы от разных пользователей, то они могут принадлежать разным сессиям.*
  + `stat`: состояние процесса. Варианты вывода:
    + `R`: Running (процесс выполняется)
    + `S`: Sleeping (процесс ожидает события)
    + `D`: Uninterruptible sleep (процесс ожидает события, не может быть прерван)
    + `T`: Stopped (процесс временно приостановлен). Процесс может быть остановлен пользователем с помощью сигналов `SIGSTOP` или `SIGTSTP` (например, при нажатии `Ctrl+Z` в терминале) - `kill -SIGSTOP <pid>`.
    + `Z`: Zombie (процесс завершен, но его запись еще не удалена). Процесс становится зомби, когда он завершает выполнение, но его родительский процесс еще не вызвал `wait()` для получения статуса завершения. Зомби-процессы не используют системные ресурсы (кроме записи в таблице процессов), но их наличие может указывать на проблемы с родительским процессом.
    + `X`: Dead (процесс завершен и его запись в таблице процессов удалена)
    + `W`: Paging (процесс ожидает записи или чтения страниц памяти)
    + Дополнительные символы при выводе `stat` могут включать:
      + `<`: Высокий приоритет
      + `N`: Низкий приоритет
      + `L`: Заблокирован в памяти
      + `s`: Лидер сессии — это процесс, который первым создает сессию. Его `PID` становится идентификатором сессии (`SID`). Все процессы, созданные в этой сессии, будут иметь тот же `SID`.
      + `l`: Многопоточный (использует CLONE_THREAD)
      + `+`: Процесс находится в группе процессов переднего плана
+ `--forest` служит для отображения процессов в виде дерева (аналогично команде pstree). Отображает родительские процессы и их дочерние процессы, наглядно показывая связи между ними.
#### Команда pgrep
Помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep". По умолчанию команда `pgrep` выводит идентификаторы процессов (`PID`), которые соответствуют заданным критериям поиска. Ниже приведены ее основные параметры:
+ `-c`, `--count`: Выводит количество процессов, соответствующих критериям поиска.
+ `-d`, `--delimiter <delimiter>`: Устанавливает значение, используемое для разделения идентификаторов процессов в выводе (по умолчанию - новая строка). `pgrep -d, ssh` - найдет все процессы с именем `ssh` и выведет их `PID`, разделенные запятыми
+ `-f`, `--full <condition>`: Ищет процессы по полному командному строковому имени.
+ `-g`, `--pgroup <pgrp>`: Ищет процессы в указанных группах процессов. Группа процессов — это набор процессов, которые имеют один и тот же идентификатор группы процессов (`PGID`). *Группа процессов имеет уникальный идентификатор группы процессов (`PGID`), который совпадает с идентификатором процесса (`PID`) лидера группы. Лидер группы процессов: Это процесс, который первым создает группу процессов. Его `PID` становится `PGID` для всей группы. Группы процессов позволяют управлять несколькими процессами одновременно. Например, можно отправить сигнал всем процессам в группе.*
+ `-G`, `--group <gid>`: Ищет процессы, принадлежащие указанным группам пользователей (group `IDs`).
+ `-i`, `--ignore-case`: Игнорирует регистр при поиске.
+ `-l`, `--list-name`: Выводит имя процесса вместе с его `PID`.
+ `-a`, `--list-full`: Выводит полную командную строку вместе с `PID`.
+ `-n`, `--newest`: Ищет только самые недавно запущенные процессы.
+ `-o`, `--oldest`: Ищет только самые старые процессы.
+ `-O`, `--older <secs>`: Ищет процессы, запущенные более указанного количества секунд назад.
+ `-P`, `--parent <ppid>`: Ищет процессы, у которых указанный `PID` является родительским.
+ `-s`, `--session <sid>`: Ищет процессы в указанных сессиях.
+ `-t`, `--terminal <term>`: Ищет процессы, запущенные в указанных терминалах. *Терминал может включать процессы, принадлежащие разным сессиям. Например, если вы используете виртуальные терминалы (TTY), каждый терминал может иметь свои процессы, принадлежащие разным сессиям.*
+ `-u`, `--euid <euid>`: Ищет процессы, запущенные пользователями с указанным эффективным идентификатором пользователя (`EUID`). Эффективный `UID` используется системой для определения прав доступа процесса. Это может быть полезно, когда процесс выполняется с правами другого пользователя (например, через `sudo`). `pgrep -u root` - Этот пример найдет все процессы, запущенные с правами пользователя `root`.
+ `-U`, `--uid <uid>`: Ищет процессы, запущенные указанными пользователями. Ищет процессы, запущенные пользователями с указанным реальным идентификатором пользователя (`UID`). Реальный `UID` — это идентификатор пользователя, который изначально запустил процесс. `pgrep -U root` - Этот пример найдет все процессы, изначально запущенные пользователем root.
+ `-v`, `--inverse`: Ищет процессы, не соответствующие указанным критериям.
+ `-x`, `--exact`: Ищет процессы, имя которых точно совпадает с указанным шаблоном.
#### Псевдо-директория `/proc`
+ `/proc` - виртуальная файловая система, содержащая множество сведений о работающих процессах. В реальности на диске нет файлов, расположенных в директории `/proc`. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории `/proc`.
+ Все команды, относящиеся к процессам, такие как `ps`, `pstree`, `pgrep`, берут информацию из директории `/proc`.
+ Можно получить информацию о ваших процессах напрямую из директории `/proc`

Поскольку `/proc` представляется как обычная директория, к ней применимы почти все известные команды, предназначенные для работы с директориями. Например, `ls` для вывода списка содержимого, `egrep -r` для рекурсивного поиска последовательности символов и т.д.:
+ Чтобы определить точный путь к исполняемому файлу конкретного процесса, который обычно не отображается в выводе команды `ps`:
```console
ls -l /proc/айди_процесса/exe
lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/айди_процесса/exe -> /path/to/executable/file
```

+ Чтобы выяснить текущую рабочую директорию конкретного процесса:
```console
ls -l /proc/айди_процесса/cwd
lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/1234/cwd -> /path/to/current/directory
```
#### Отслеживание процессов и команда top
Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу (похожа на диспетчер задач Windows)

Команда top полезна для:
+ Поиска процессов, которые больше других потребляют ресурсы процессора и памяти.
+ Определение текущей загрузки системы.
### Сигналы
**Сигнал** — это короткое сообщение, которое можно отправить процессу
+ `kill [-ЧТО] PID` - отправляет сигнал ЧТО (например, `TERM`, `KILL`, `STOP` и т. д.) процессу с идентификатором PID
  + `kill -KILL PID` или `kill -9 PID`
+ `killall [-ЧТО] [другие опции] название_процесса` - отправляет один и тот же сигнал нескольким процессам с одинаковым названием, более подробно синтксис функции:
  + `killall [-Z, --context шаблон] [-e, --exact] [-g, --process-group] [-i, --interactive] [-n, --ns PID] [-o, --older-than ВРЕМЯ] [-q, --quiet] [-r, --regexp] [-s, --signal СИГНАЛ, -СИГНАЛ] [-u, --user пользователь] [-v, --verbose] [-w, --wait] [-y, --younger-than ВРЕМЯ] [-I, --ignore-case] [-V, --version] [--] название_процесса … :`
    + `-e, --exact` - Требовать полного совпадения для очень длинных имён. Если имя команды длиннее чем 15 символов, то полное имя может быть недоступно (т. е., часть затёрлась). В этом случае, killall завершит все процессы, совпадающие по первым 15 символам. С параметром -e такие элементы не обрабатываются. killall выводит сообщение для каждого необработанного элемента, если вместе с -e дополнительно указан параметр -v.
    + `-I, --ignore-case` - Игнорировать регистр символов в именах процессов.
    + `-g, --process-group` - Завершить группу процесса, в которую входит процесс. На всю группу посылается только один сигнал завершения, даже если в группе найдено несколько процессов.
    + `-i, --interactive` - Запрашивать подтверждение перед завершением процессов.
    + `-l, --list` - Показать все известные имена сигналов.
    + `-n, --ns` - Искать процессы в том же пространстве имён PID что и у PID. По умолчанию поиск выполняется по всем пространствам имён.
    + `-o, --older-than` - Искать процессы, старее (запущенные до) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + `-q, --quiet` - Не сообщать, если ни одного процесса не завершено.
    + `-r, --regexp` - Рассматривать шаблон имени процесса как расширенное регулярное выражение POSIX согласно regex(3).
    + `-s, --signal, -СИГНАЛ` - Посылать указанный СИГНАЛ, а не SIGTERM.
    + `-u, --user` - Завершить процессы, принадлежащие указанному пользователю. Имена команд необязательны.
    + `-v, --verbose` - Уведомлять об успешной отправке сигнала.
    + `-V, --version` - Показать информацию о версии.
    + `-w, --wait` - Ожидать завершения процессов. killall проверяет раз в секунду существование завершаемых процессов и прекращает работу только если никого не осталось.Заметим, что killall может ждать вечно, если сигнал был проигнорирован, никак не повлиял или если процесс остался в состоянии зомби.
    + `-y, --younger-than` - Искать процессы, новее (запущенные после) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + `-Z, --context` - Задать контекст безопасности: завершать только процессы с контекстом безопасности, который совпадает с заданным шаблоном расширенного регулярного выражения. В командной строке должен указываться раньше остальных параметров. Имена команд необязательны.
 + `pkill [-ЧТО][другие опции] название_процесса` - отправляет один и тот же сигнал нескольким процессам, названия которых отвечают некоторому условию. Похожа на команду `pgrep`. , более подробно синтксис функции:
   + `pkill [-signal] [-fvx] [-n|-o] [-P ppid,...] [-g pgrp,...][-s sid,...] [-u euid,...] [-U uid,...] [-G gid,...][-t term,...] [pattern]`
     + `-f` - Обычно шаблон сопоставляется только с именем процесса. Если задано значение -f, используется полная командная строка
     + `-g pgrp,...` - Искать процессы только в перечисленных идентификаторах групп процессов. Группа процессов 0 переводится в собственную группу процессов pgrep или pkill.
     + `-G gid,...` - Искать только те процессы, реальный идентификатор группы которых указан в списке. Может использоваться как числовое, так и символическое значение.
     + `-n` - Выберите только самый новый (недавно запущенный) из совпадающих процессов.
     + `-o` - Выберите только самый старый (запущенный совсем недавно) из соответствующих процессов.
     + `-P ppid,...` - Совпадают только те процессы, идентификатор родительского процесса которых указан в списке.
     + `-s sid,...` - Искать только те процессы, идентификатор сеанса которых указан в списке. Идентификатор сеанса 0 транслируется в собственный идентификатор сеанса pgrep или pkill.
     + `-t term,...` - Искать только те процессы, управляющий терминал которых указан в списке. Имя терминала должно быть указано без префикса "/dev/".
     + `-u euid,...` - Искать только те процессы, чей эффективный идентификатор пользователя указан в списке. Может использоваться как числовое, так и символическое значение.
     + `-U uid,...` - Искать только те процессы, в списке которых указан реальный идентификатор пользователя. Может использоваться как числовое, так и символическое значение.
     + `-v` - Искать обратное соответствию.
     + `-x` - Искать только те процессы, имя которых (или командная строка, если указано -f) точно соответствует шаблону.
     + `-signal` - Определяет сигнал, посылаемый каждому сопоставленному процессу. Можно использовать как числовое, так и символическое имя сигнала.
#### Полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:
+ `TERM (15)`, `terminate` — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
+ `KILL (9)`, `kill` — уничтожить: безусловное завершение работы процесса, не может быть проигнорирован процессом
+ `INT (2)`, `interrupt` — прервать посредством терминала: отправляется, когда пользователь нажимает клавиши `Ctrl+C`. По умолчанию `SIGINT` завершает процесс, но процесс может перехватить сигнал и выполнить какую-либо очистку, альтернативное действие перед завершением или проигнорировать
+ `TSTP (20)`, `terminal (TTY) stop` — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши `Ctrl+Z`. Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.
+ `STOP (19)`, `stop` — приостанавливает работу процесса аналогично `TSTP`, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал `KILL`, не может быть проигноирован процессом.
+ `CONT (18)`, continue — продолжить: отправляется, когда пользователь выполняет команду `fg` или `bg` с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала `STOP`, можно возобновить сигналом `CONT`.
## Службы (services) Linux
 **Служба Linux** - "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС. **Служба Linux**, построена вокруг программы и отвечает на вопрос "КАК именно следует управлять этой программой":
+ Должна ли она запускаться во время загрузки системы?
+ Как запустить ее вручную при необходимости?
+ Какие опции предоставляются программе при запуске?
+ Как отслеживать ее состояние?
+ Как аккуратно завершить ее работу?
+ Нужно ли перезапускать ее в случае нештатного завершения?
+ Какие другие службы должны быть запущены перед запуском этой конкретной?
### Systemd
+ Systemd — это комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами (принята как замена системы инициализации SysV init).
+ Systemd оперирует следующими объектами, называемыми "юнитами":
  + Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
  + Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
  + сокеты, таймеры и др.
### Службы в контексте systemd
+ Службы, добавленные к systemd вместе с их настройками (известными также как **юнит-файлы**), находятся в директории `/etc/systemd/system` и ее вложенных директориях. Обычно **юнит-файлы представляют собой символьные ссылки** на «настоящие» файлы, расположенные в директории `/usr/lib/systemd/system`.
### Структура Unit-файла сервиса
```console
[Unit]
Description=Краткое описание сервиса
Documentation=URL-документации
Requires=другие_юниты_требуемые_для_запуска
Wants=другие_юниты_желательные_для_запуска
After=юниты_которые_должны_запуститься_перед_этим
Before=юниты_которые_должны_запуститься_после_этого
Conflicts=юниты_которые_конфликтуют_с_этим
ConditionPathExists=/путь/к/файлу (условие для запуска)

[Service]
Type=simple (или другие типы: forking, oneshot, dbus, notify, idle)
ExecStart=/путь/к/исполняемому_файлу (основная команда для запуска сервиса)
ExecStartPre=/путь/к/исполняемому_файлу_предварительно (команда, выполняемая перед запуском основного процесса)
ExecStartPost=/путь/к/исполняемому_файлу_после (команда, выполняемая после запуска основного процесса)
ExecStop=/путь/к/исполняемому_файлу_для_остановки (команда для остановки сервиса)
ExecReload=/путь/к/исполняемому_файлу_для_перезагрузки (команда для перезагрузки сервиса)
Restart=always (политика перезапуска: no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, или always)
RestartSec=5 (время ожидания перед перезапуском)
User=имя_пользователя (пользователь, от имени которого запускается сервис)
Group=имя_группы (группа, от имени которой запускается сервис)
WorkingDirectory=/путь/к/рабочему_каталогу (рабочий каталог для процесса)

[Install]
WantedBy=multi-user.target (указывает таргеты, в которые включен этот юнит)
RequiredBy= (другие юниты, которые зависят от этого юнита)
Also= (другие юниты, которые должны быть включены вместе с этим)
Alias= (другие имена для этого юнита)
`
+ Раздел [Unit] содержит общую информацию о юните и его зависимостях
+ Раздел [Service] используется для определения параметров и команд, необходимых для запуска, остановки и перезапуска сервисов.
+ Раздел [Install] определяет параметры, связанные с установкой и включением юнита.
#### Вывод списка активных служб (units) в системе, управляемой systemd
`systemctl list-units --type=service` показывает только те службы, которые в данный момент активны (запущены или в других состояниях активности)
`console
$ systemctl list-units --type=service
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
apparmor.service                    loaded active exited  Load AppArmor profiles
...
```
где 
+ `UNIT`: Название службы.
+ `LOAD`: показывает статус загрузки конфигурационного файла сервиса. Возможные значения:
  + `loaded`: Конфигурационный файл сервиса загружен и разобран успешно.
  + `not-found`: Конфигурационный файл сервиса не найден.
  + `error`: Произошла ошибка при загрузке конфигурационного файла.
  + `masked`: Сервис замаскирован, что предотвращает его случайный запуск
+ `ACTIVE`: показывает общий статус активности сервиса. Возможные значения:
  + `active`: Сервис запущен и работает нормально.
  + `reloading`: Сервис в процессе перезагрузки конфигурации.
  + `inactive`: Сервис не запущен.
  + `failed`: Сервис завершился с ошибкой.
  + `activating`: Сервис находится в процессе запуска.
  + `deactivating`: Сервис находится в процессе остановки.
+ `SUB`: показывает более детальную информацию о состоянии сервиса, дополняя статус в столбце ACTIVE. Возможные значения различаются в зависимости от типа сервиса, но некоторые примеры включают:
  + `running`: Сервис запущен и работает (соответствует active в ACTIVE).
  + `exited`: Сервис завершил работу (может быть нормальное завершение, соответствует inactive в ACTIVE).
  + `dead`: Сервис не работает и не запускается (соответствует inactive в ACTIVE).
  + `auto-restart`: Сервис настроен на автоматический перезапуск (обычно временный статус).
  + `failed`: Сервис завершился с ошибкой (соответствует failed в ACTIVE).
+ `DESCRIPTION`: Описание службы.
#### Вывод списка активных служб (units) в системе, которые находятся в состоянии "running"
```console
$ systemctl list-units --type=service --state=running
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
avahi-daemon.service                loaded active running Avahi mDNS/DNS-SD Stack
...
```
#### Вывод всех файлов units (сервисов) вместе с их состоянием включения
`systemctl list-unit-files` отображает все доступные на системе файлы unit (сервисы), вне зависимости от их текущего состояния активности
```console
$ systemctl list-unit-files --type=service
UNIT FILE                                   STATE   
accounts-daemon.service                     enabled 
apparmor.service                            enabled 
apt-daily-upgrade.service                   enabled 
dbus-org.bluez.service                      alias   
dbus.service                                static  
debug-shell.service                         disabled
grub-common.service                         masked  
...
```
##### Группа состояний настройки запуска служб
+ `enabled`: Служба настроена на автоматический запуск при загрузке системы.
+ `disabled`: Служба не настроена на автоматический запуск при загрузке системы.
+ `static`: в unit-файле службы отсутствует секция [Install], что делает их неспособными к автоматическому запуску. Они могут быть запущены вручную или как зависимости других служб.
+ `masked`: Служба замаскирована это значит, что она заблокирована для запуска и не может быть запущена ни вручную, ни автоматически, пока не будет размаскирована. Замаскированная служба фактически отключена и недоступна для выполнения. `systemctl mask|unmask example.service`
+ `alias`: Служба является псевдонимом другой службы.

Чтобы увидеть только включенные службы, выполните:
`systemctl list-unit-files --type=service --state=enabled` - вернёт список всех unit-файлов для сервисов (.service), которые включены (enabled) в системе. Включенные сервисы автоматически запускаются при загрузке системы или при активации соответствующего таргета.
#### Проверка текущего состояния службы (по названию)
`systemctl status название_службы`
#### Проверка текущего состояния службы (по процессу)
`systemctl status PID_процесса`
#### Запуск/остановка/перезапуск службы
```console
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
Для выполнения необходимы права root
#### Включение и отключение автоматического запуска службы на этапе загрузки ОС
`systemctl enable|disable [--now] название_службы` - включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы).

Для выполнения необходимы права root
#### Узнать настройки автоматического запуска конкретной службы
`systemctl is-enabled название_службы`
## Отличие сервисов (служб) от приложений
| | Серверные приложения | Службы systemd |
|-------------|-------------|-------------|
| Основное назначение    | Обработка запросов пользователей и выполнение действий в рамках прикладной логики (например, сервер MySQL сохраняет данные и обрабатывает запросы на языке SQL)    | Упрощение управления приложениями (запуск, останов, перезапуск, проверка состояния и т. д.)    |
| Управление приложениями    | Для каждого серверного приложения (если он запущено само по себе, а не как служба) предусмотрен свой способ управления. Даже простые операции (проверка, запуск, перезапуск, останов) разных приложений имеют свои особенности    |Приложения, "обернутые" в сервис, управляются одним и тем же способом — посредством команды systemctl и её опций.    |
| Конфигурация | Хранится в файле конфигурации, специфичном для приложения (например, /etc/my.cnf). Содержит главные параметры приложения, такие как прослушиваемые порты, степень подробности журналирования, настройки проверки подлинности пользователей и многие другие | Хранится в юнит-файлах с общим форматом (например, /usr/lib/systemd/system/mysqld.service). Содержит условия запуска, требуемые права пользователя, внешние зависимости от других служб, действия при запуске и останове, путь к исполняемому файлу и аргументы. Не описывает конфигурацию самого приложения! |
| Журналирование (логирование)    | Полностью зависит от конкретного приложения. Настройки журналирования (например, степень подробности и формат) очень гибкие и задаются в файле(ах) конфигурации приложений. Журналы чаще всего представляют собой текстовые файлы (например, /var/log/mysqld.log)    | Файлы журналов служб systemd: обычно содержат меньше информации по сравнению с файлами журналов приложений (записываются только основные события); хранятся в едином двоичном формате; доступ к ним можно получить с помощью команды journalctl    |
## Юнит-файлы сервисов по сравнению с файлами конфигурации приложений
|  | Файл конфигурации приложения java-auth | Юнит-файл сервиса java-auth.st00 |
|-------------|-------------|-------------|
| Местоположение файлов конфигурации    | Полностью зависит от самого приложения. В нашем примере далее показан файл /apps/java/auth/st00/application.properties. Конфигурации основных серверных приложений (например, SSH server) часто содержатся в директории/etc    | Обычно где-то в директории /usr/lib/systemd/system (сами конфигурации) и (или) /etc/systemd/system (обычно символьные ссылки на файлы конфигурации). Показанный далее юнит-файл взят из /etc/systemd/system/multi-user.target.wants/java-auth.st00.service    |
| Основное назначение    | Содержит специфичные для приложения настройки, такие как используемые сервером порты, адрес и тип базы данных для подключения, учётная запись и пароль базы данных. Формат файла и набор параметров полностью зависит от каждого приложения. В нашем примере используется очень простое учебное приложение. Реальное серверное приложение может предусматривать огромные файлы конфигурации с тысячами строк.    | Содержит стартовые условия запуска, требуемые права пользователя (см. переменные User и Group далее), внешние зависимости от других служб (см. After), действия при запуске и останове (см. ExecStop), путь к исполняемому файлу (см. ExecStart) и аргументы. Не описывает конфигурацию самого приложения! Формат един для всех служб системы.    |
| Содержимое файла    | server.port=7000<br> debug=false<br> spring.jpa.hibernate.ddl-auto=updates<br> spring.datasource. url=jdbc:mysql://192.168.40.150:3306/auth_st00<br> spring.datasource.username=dbst00<br> spring.datasource.password=your_password_here    | [Unit]<br>Description=Java auth service for Roles app, per user<br> After=network.target<br><br>[Service]<br>SuccessExitStatus=143<br> User=st00<br> Group=qa<br> Type=simple<br> ExecStart=/apps/java/auth/st00/java-start-auth.sh<br> ExecStop=/bin/kill -15 $MAINPID<br> TimeoutSec=60<br><br>[Install]<br> WantedBy=multi-user.target    |
## Journalctl: вывод журналов служб systemd
`journalctl` — это инструмент для управления журналами служб systemd. 

Для выполнения этой команды необходимы права `root` или включение в группу `systemd-journal`.

### Просмотр всех записанных в журнал событий для службы (по имени)
`journalctl -u service_name` (`journalctl  -e -u service_name` - то же, но с переходом к последним строкам журнала)
### Отслеживание событий службы в реальном времени и вывод их на терминал
`journalctl -f -u service_name` - наподобие команды `tail -f` 
### Просмотр событий от нескольких служб одновременно
`journalctl -u service_name_1 -u service_name_2 ...` - Эту функцию можно сочетать с другими опциями, например -f

