# 09 Linux — исполняемые файлы, процессы и службы
## Выполнение команд в терминале Linux
При выполнении команд в терминале Linux, на самом деле выполняются:
+ Исполняемые файлы - файлы с установленным битом `x`:
  + Двоичные исполняемые файлы, например, написанные на C/C++. Примеры: `cat`, `less`, `grep`. Они аналогичны файлам `.exe` в Windows
  + Скрипты, например, скрипты (сценарии) оболочки, Python и т.д. Примеры: `egrep`, `yum` (похожи на `.bat` или `.ps` в Windows).
  + Библиотеки - это двоичные файлы, подобные исполняемым файлам, но очень редко запускаемые напрямую.
  + Все вышеперечисленные исполняемые файлы, представленные в виде символических ссылок на "обычные" файлы с установленным битом `x`, что широко распространено в UNIX-подобных системах.
+ Встроенные команды оболочки. Примеры: `cd`, `alias`. При их выполнении не вызывается никакая внешняя команда, вместо этого их выполняет сама командная оболочка
+ Псевдонимы (алиасы) - могут ссылаться как на встроенные команды оболочки, так и на внешние команды или даже на комбинации команд, например:
  + `alias ll='ls -l'` - в этом примере псевдоним `ll` ссылается на встроенную команду оболочки `ls` с опцией `-l`;
  + `alias grep='grep --color=auto'` - здесь псевдоним `grep` ссылается на внешнюю команду `grep` с дополнительной опцией `--color=auto`

Для выполнения команд пользователя и отображения их вывода используются специальные оболочки входа в систему, такие как `bash`, `zsh` и так далее
### Исполняемые файлы
#### PATH
`PATH` - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов. Она может быть отображена командой `echo`:

```console
localhost:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```
+ Любой исполняемый файл можно запустить, указав путь к нему.
+ Исполняемый файл, если он находится в директории в списке `PATH`, может быть запущен путем указания имени файла; путь к файлу указывать не нужно.
+ Поиск в директориях, перечисленных в `PATH`, выполняется последовательно. Таким образом, если файлы с одинаковым именем существуют в нескольких каталогах `PATH`, для выполнения будет взят файл из первой директории в переменной `PATH`.
+ Чтобы запустить исполняемый файл, не находящийся ни в одной из директорий в `PATH`, необходимо вместо имени файла указать его путь - относительный или абсолютный.
#### Переменные оболочки
Вывод списка переменных оболочки осуществляется командой `env`
#### which
`which` - это команда для показа расположения исполняемого файла в каталогах PATH:
```console
localhost:~# which uname
/bin/uname
```
### Встроенные команды оболочки (built-in commands)
Это команды, которые являются частью самой оболочки (например, `Bash`) и не существуют как отдельные исполняемые файлы на диске. Они выполняются непосредственно оболочкой:
+ что делает их выполнение быстрее
+ позволяет им иметь доступ к внутренним структурам оболочки, что невозможно для внешних команд.

Когда вы вводите команду в терминале, оболочка сначала проверяет, является ли эта команда встроенной. Если да, она выполняет её напрямую. Если нет, она ищет соответствующий исполняемый файл на диске и запускает его.

*Примеры встроенных команд*: `cd`: изменяет текущий каталог, `pwd`: показывает текущий каталог
### Псевдонимы (alias) оболочки
**Alias** - это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле будет выполнено "a --option1 --option2 --some-options arguments". 
+ `alias` - встроенная команда оболочки, которая возвращает просмотр список зарегистрированных в системе псевдонимов (по умолчанию какие-либо псевдонимы могут отсутствовать).
+ `alias имя_псевдонима='команда'` - создание псевдонима

Часто система Linux настроена так, что некоторые псевдонимы для всех пользователей доступны сразу же, например, `ls` (`ls='ls --color=auto'`).



#### Варианты создания псевдонима
1. Определить псевдоним с помещением его в постоянный файл конфигурации оболочки (в файл `~/.bashrc` и(или) `~/.bash_profile`):
   1. `echo "alias lf='ls -lF'" >> ~/.bashrc` - выполнить команду
   2. `bash` - запустить новый экземпляр оболочки (`bash`) для применения обновленной конфигурации
   3. Проверка, что псевдоним добавлен - вызвать команду `alias`
2. Определить псевдоним «на ходу» (будет действовать до завершения текущего сеанса оболочки):
   1. `alias rm='echo You are trying to execute "rm" with the following arguments: '` - теперь "оригинальную" команду `rm` можно вызвать только по абсолютному пути `/bin/rm -f ~/file.to.remove`(только в таком случае выполнится именно она, а не ее псевдоним)
#### Отмена псевдонима
1. `unalias имя_псевдонима` - отмена псевдонима
2.  Удалить вручную соответствующую строку из файла `~/.bashrc`, если псевдоним был туда добавлен (если этого не сделать то после новой сессии bash псевдоним будет снова доступен)
### Управление задачами, запущенными в терминале
#### Просмотр списка задач (`jobs`)
`jobs` - используется в Unix-подобных системах для отображения списка текущих задач в оболочке (терминале), которые были запущены в фоновом режиме. Эта команда полезна для управления процессами и может показывать статус текущих задач.
#### Запуск процесса в фоновом режиме
Запустить процесс в фоновом режиме можно, добавив символ `&` в конец команды. Это позволяет вашей командной строке быть доступной для ввода новых команд, пока фоновый процесс выполняет `команду &`, например `gedit &`
#### Приостановка задачи (`Ctrl+Z`)
Когда вы выполняете команду в терминале, она обычно работает в переднем плане (foreground). Если вы хотите временно приостановить выполнение этой команды, вы можете использовать сочетание клавиш `Ctrl+Z`. Это переместит задачу в состояние приостановки (stopped).
#### Перевод задачи в фоновый режим (`bg`)
`bg %ID_задачи` - Возобновляет выполнение приостановленной задачи в фоновом режиме. Если не указать ID задачи, будет использована последняя приостановленная задача. `bg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
#### Возвращение задачи в передний план (`fg`)
`fg %ID_задачи` - Возобновляет выполнение задачи в переднем плане. Если не указать ID задачи, будет использована последняя приостановленная или фоновая задача. `fg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
#### Завершение задачи (`Ctrl+C`)
`Ctrl+C`: Прерывает и завершает текущую задачу в переднем плане
#### "Убийство" задачи (`kill`)
`kill %ID_задачи` - Отправляет сигнал `SIGTERM` для завершения указанной задачи. Если задача не завершится, можно использовать сигнал принудительного завершения `SIGKILL` (`kill -s SIGKILL [PID]` или `kill -SIGKILL [PID]` или `kill -KILL [PID]`), который не может быть перехвачен или проигнорирован процессом, и который немедленно завершает процесс. *В отличие от команд `fg` и `bg` команда `kill` может завершить любой процесс, если у вас есть его PID (идентификатор процесса)*
#### Символ `%` 
Символ `%` используется для ссылки на задачи, управляемые оболочкой (shell). Он применяется с командами `fg` (`fg %ID_задачи`), `bg` (`bg %ID_задачи`) и `kill` (`kill %ID_задачи`) для указания конкретной задачи по её номеру
## Процессы и демоны
### Процессы
**Процесс** операционной системы — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Если программа заканчивает свою работу, то процесс также прекращает своё существование. *Примечание: при запуске в терминале встроенной команды также порождается новый процесс.* Например: при вызове в терминале команды `ls` происходит следующее:
+ Создание процесса: Оболочка (например, `Bash`) создает новый процесс для выполнения команды `ls`;
+ Выполнение команды: Новый процесс загружает в память программу `ls` и начинает ее выполнение;
+ Вывод результата: Программа `ls` выполняет свою работу и выводит список файлов на экран;
+ Завершение процесса: После завершения работы программы `ls` процесс, соответствующий этой команде, уничтожается.

Каждый процесс имеет несколько следующих основных атрибутов:
+ `PID` - идентификатор процесса. Уникален для каждого выполняющегося процесса. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми `PID`.
+ `PPID` — родительский идентификатор (`PID`). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, `PPID` - это `PID` родительского процесса. «Главный» системный процесс называется `init` или `systemd` и обладает `PID` = 1, `PPID` = 0. Он создаётся ядром операционной системы при её загрузке.
+ Пользователь и группа, запустившие программу.
+ Название.
+ Аргументы командной строки (могут быть переданы процессу не только при запуске из терминала, но и при запуске из скриптов, других программ или системных служб).
+ `TTY` (Управляющий терминал). Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме
  + Основные назначения `TTY`:
    + Обеспечение взаимодействия пользователя с системой: `TTY` предоставляет интерфейс для ввода текстовых команд (через клавиатуру) и получения вывода (на экран)
    + Связь процессов с терминалом: `TTY` выступает как управляющий терминал для процесса или группы процессов. Это означает, что через `TTY` процессы получают команды пользователя и возвращают результаты.
    + Управление вводом/выводом: каждый терминал обрабатывает **стандартные** потоки:
      + `stdin` (ввод, например, с клавиатуры).
      + `stdout` (вывод текстовых данных на экран).
      + `stderr` (вывод ошибок).
    + Обработка сигналов: `TTY` позволяет отправлять сигналы процессам, например:
      + `Ctrl+C` посылает сигнал `SIGINT` для прерывания выполнения программы.
      + `Ctrl+Z` посылает сигнал `SIGTSTP` для приостановки программы.
    + Работа с группами процессов: `TTY` организует процессы в группы (например, основной процесс оболочки и дочерние процессы), что упрощает управление ими.
  + Процессы `TTY`
    + Основной процесс терминала:
      + Когда вы открываете терминальный эмулятор (например, `GNOME Terminal`), он создаёт пару `PTY` (`master`/`slave`). `Master` (`/dev/ptmx`) управляется терминальным эмулятором (`GNOME Terminal`) и служит "промежуточным звеном". `Slave` (`/dev/pts/0`) напрямую связан с процессом оболочки (`Bash`) и воспринимается как "управляющий терминал" для всех процессов, порождённых `Bash`.
      + Ввод пользователя, записанный в мастер-устройство (`/dev/ptmx`), отправляется в `Slave` (`/dev/pts/0`), а вывод, записанный из `Bash` в `Slave` (`/dev/pts/0`), передаётся обратно в `Master` (`/dev/ptmx`). `GNOME Terminal` считывает вывод из `Master`(`/dev/ptmx`) и отображает его в окне терминала, чтобы пользователь мог увидеть результат
    + Оболочка (`Bash`):
      + При запуске терминальный эмулятор (например, `GNOME Terminal`) запускает процесс оболочки (`Bash`, `Zsh` или другую).
      + `Bash` становится активным процессом, обрабатывающим ввод/вывод, связанный с управляющим терминалом `Slave` (`/dev/pts/0`).
    +  Дочерние процессы:
       +  Когда в терминальный эмулятор вводят команду (например, `ls`), `Bash` запускает её как дочерний процесс.
       +  Этот процесс (например, `ls`) также связывается с тем же управляющим терминалом, что и `Bash` (здесь - `Slave`-устройство `/dev/pts/0`), и становится частью его группы процессов.
  + Процессы, не имеющие `TTY`
    + Серверные или фоновые программы (демоны) не используют управляющий терминал, так как они не предполагают прямого взаимодействия с пользователем. [см. процесс "демонизации"](#daemoniz)
    + Программы, запускаемые с перенаправлением всех стандартных потоков (`stdin`, `stdout`, `stderr`) в `/dev/null` или файлы (но если хотя бы один поток не перенаправлен и остаётся связанным с `TTY`, то и весь процесс также всё ещё привязан к `TTY`)
    + Графические программы (например, `OpenOffice`), которые запускаются из графического интерфейса (например, через меню рабочего стола), не наследуют ни управляющий терминал, ни его потоки ввода/вывода. Поэтому в графе "Управляющий терминал" у процесса, который был запущен из графической оболочки (например, `OpenOffice`), будет указано `?` или "неопределённо"
      + Графические программы могут быть запущены через терминал (например, командой `soffice` для `OpenOffice`). И хотя их основное взаимодействие с пользователем происходит через окна, а не через текстовый интерфейс терминала, но в этом случае:
        + терминал может быть использован для вывода отладочной информации, ошибок и логов;
        + терминал остаётся управляющим терминалом графической программы, пока процесс программы не завершится. 
### Демоны
**Демоны** — это особый вид процессов, работающих в фоновом режиме и не взаимодействующий с пользователями посредством терминала. Например, процессы сетевых серверных приложений, отвечающие за обработку входящих запросов по сети, обычно являются демонами. Процесс не обязательно должен быть запущен процессом с `PID` 1 (обычно это `init` или `systemd`), чтобы стать демоном. Однако, когда процесс становится демоном, он часто отсоединяется от своего родительского процесса и его родительским процессом становится процесс с `PID` 1 (`init` или `systemd`). Это происходит в процессе “демонизации”, который включает несколько шагов <a id="daemoniz"></a>:
1. Форк процесса: Процесс создает копию самого себя.
2. Завершение родительского процесса: Оригинальный процесс завершает свою работу, и выполнение продолжает дочерний процесс.
3. Смена родительского процесса: Дочерний процесс становится “сиротой” и его родительским процессом становится процесс с `PID` 1 (`init` или `systemd`).
4. Отсоединение от управляющего терминала: Процесс отсоединяется от терминала, чтобы не зависеть от него с применением одного из способов (или их комбинации):
   1. `nohup`: Простое средство, чтобы процесс продолжал работать после закрытия терминала
   2. `setsid()`: Инструмент для создания нового сеанса и отвязывания от терминала
   3. `daemon()`: Полноценный способ демонизации процессов, который включает `setsid()` и дополнительные действия, такие как перенаправление потоков
5. Смена текущей рабочей директории: Обычно демоны меняют текущую рабочую директорию на корневую (`/`), чтобы избежать блокировки файловых систем.
6. Закрытие файловых дескрипторов: В процессе демонизации выполняются следующие действия: закрытие стандартных дескрипторов (`stdin` (0), `stdout` (1), `stderr` (2)) или их перенаправление на `/dev/null`, кроме того демон может закрыть все дескрипторы, кроме нужных ему. Таким образом закрытие файловых дескрипторов при демонизации изолирует процесс от терминала, освобождаются ресурсы, устраняются побочные эффекты от неконтролируемых потоков ввода-вывода. *(Файловый дескриптор — это числовой идентификатор, который операционная система использует для отслеживания открытых файлов, сокетов, устройств и других потоков ввода-вывода)* 

Таким образом, «настоящий» процесс-демон обладает следующими свойствами:
+ `PPID` = 1
+ Управляющий терминал отсутствует (в отличие от команды, запущенной из терминала в фоновом режиме с помощью выражения `имя_команды &`, у демона в столбце `TTY` в выводе команды `ps` стоит `?`)
+ В большинстве случаев текущей рабочей директорией демона является `/`.
### Как искать процессы и просматривать их списки
Ниже приводятся некоторые из инструментов и способов получения информации обо всех или конкретных запущенных процессах:
+ `ps` — основной инструмент для отображения списка запущенных процессов
+ `top` - инструмент для отслеживания запущенных процессов в реальном времени, аналог диспетчера задач Windows
+ `pgrep` - инструмент для поиска процессов по их названию или аргументам
+ `pstree` - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений
+ В псевдо-каталоге `/proc/PID` содержится много подробных сведений о процессе с идентификатором PID. Очень полезен в некоторых случаях
#### Команда `ps`
Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. **По умолчанию** выводит следующую информацию для текущего пользователя:
+ `PID`(Идентификатор процесса)
+ `TTY` (Терминал, связанный с процессом)
+ `TIME` (Общее время использования процессора процессом)
+ `CMD` (команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если возвращает название процесса в квадратных скобках, значит, процесс является частью ядра ОС). 

Опции команды `ps`:
+ `-e` отображает процессы всех пользователей (по умолчанию показываются процессы только текущего пользователя).
+ `-U <UID>`: отображает процессы, запущенные пользователем с указанным реальным `UID` или именем пользователя
+ `-u <UID>`: отображает процессы, запущенные пользователем с указанным эффективным `UID` или именем пользователя
+ `-s, --sid <session>`: отображает процессы для заданной сессии. *Сессия в контексте операционных систем — это набор процессов, которые были запущены в рамках одной сессии пользователя (временном промежутке, начиная с момента аутентификации и заканчивая выходом из системы). Каждая сессия имеет уникальный идентификатор сессии (`SID`). Сессия может включать процессы, запущенные в разных терминалах. Например, если вы открыли несколько терминалов в одной графической сессии, все процессы в этих терминалах будут принадлежать одной сессии.*
+ `-g <sid или group>`: если список идентификаторов полностью числовой, `ps` будет выбирать процессы по идентификаторам сеансов (`SID`). Если в списке указаны как числовые значения, так и имена групп, `ps` будет по числам выбирать процессы, относящиеся к указанным сессиям и по именам групп процессы, принадлежащие пользователям из указанных эффективных групп.
+ `-G <group>`: отображает процессы, запущенные пользователем с реальным идентификатором или именем группы.
+ `-p <PID>` : отображает процессы с заданным `PID`
+ `--ppid <PPID>` : отображает процессы, порожденных процессом с указанным идентификатором родительского процесса (`PPID`).
+ `-C <command>`: отображает процессы, которые были запущены с указанной командой (например, `ps -C sshd`). Это полезно, когда вы хотите увидеть все процессы, связанные с определенной программой или командой.
+ `-t <tty>`: отображает процессы, связанные с указанным терминалом, например `ps -t pts/0`
+ `-x`: отображает процессы, которые не связаны с терминалом (например, демоны и фоновые процессы).
+ `-m` : отображает многопоточные процессы.
+ `--ns <PID>`: позволяет фильтровать процессы по пространствам имен. Он принимает аргумент, указывающий идентификатор пространства имен или путь к нему.
+ `-f` для вывода расширенных сведений о каждом процессе. `ps -ef` вернет следующий набор полей:
  + `UID`: имя пользователя, запустившего процесс
  + `PID`: идентификатор процесса
  + `PPID`: идентификатор родительского процесса
  + `STIME`: время запуска процесса
  + `TTY` или `TT`: управляющий терминал. Знак `?` показывается для процессов, не связанных с терминалом (таких как демоны)
  + `TIME`: суммарное процессорное время выполнения
  + `CMD`: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если возвращает название процесса в квадратных скобках, значит, процесс является частью ядра ОС.
+ `-o` задает список полей для вывода определённых сведений о процессах (`ps -o pid,ppid,cmd,%cpu,%mem`):
  + `pid`: идентификатор процесса
  + `ppid`: идентификатор родительского процесса
  + `sess`:  идентификатор сессии
  + `uid`: идентификатор пользователя
  + `user`: имя пользователя
  + `gid`: идентификатор группы
  + `group`: имя группы
  + `comm`: отображает имя команды, с помощью которой был запущен процесс. Оно показывает только имя исполняемого файла (без пути и аргументов). Например, если процесс был запущен командой `/usr/bin/python3 script.py`, поле `comm` отобразит только `python3`
  + `cmd`: имя команды с аргументами
  + `etime`: время, прошедшее с момента запуска процесса
  + `time`: общее процессорное время, использованное процессом
  + `stime`: время старта процесса в формате `HH:MM` (часы и минуты)
  + `%cpu` или `c`: процент использования процессора
  + `%mem`: процент использования памяти
  + `vsz`: размер виртуальной памяти
  + `rss`: размер резидентной памяти
  + `sid`: идентификатор сессии
  + `tty`: терминал, связанный с процессом. *Терминал может включать процессы, принадлежащие разным сессиям. Например, если вы используете виртуальные терминалы (TTY), или в терминале запускаете процессы от разных пользователей, то они могут принадлежать разным сессиям.*
  + `stat`: состояние процесса. Варианты вывода:
    + `R`: Running (процесс выполняется)
    + `S`: Sleeping (процесс ожидает события). Например, ожидание ввода данных от пользователя или завершения сетевой операции. Т.е. временно не активен, но может быть возобновлен при наступлении ожидаемого события. Большинство процессов находятся в этом состоянии большую часть времени
    + `D`: Uninterruptible sleep (не может быть прерван до завершения операции). Процесс ожидает завершения критической операции ввода/вывода, такой как запись на диск, и не может быть прерван по сигналу
    + `T`: Stopped (процесс временно приостановлен). Процесс мог быть остановлен пользователем с помощью сигналов `SIGSTOP` или `SIGTSTP` (например, при нажатии `Ctrl+Z` в терминале) - `kill -SIGSTOP <pid>`.
    + `Z`: Zombie (процесс завершен, но его запись еще не удалена). Процесс становится зомби, когда он завершает выполнение, но его родительский процесс еще не вызвал `wait()` для получения статуса завершения *(1.Когда дочерний процесс завершает выполнение, он отправляет сигнал своему родительскому процессу, чтобы сообщить о своем завершении. 2.Родительский процесс должен вызвать `wait()` или `waitpid()`, чтобы получить информацию о завершении дочернего процесса. Это включает в себя код завершения и другие данные. 3.После вызова `wait()` или `waitpid()`, запись о дочернем процессе удаляется из таблицы процессов, и процесс больше не считается зомби)*. Зомби-процессы не используют системные ресурсы (кроме записи в таблице процессов).
    + `X`: Dead (процесс завершен и его запись в таблице процессов удалена). Указывает на процесс, который больше не существует или находится в неустойчивом состоянии, но информация о нём каким-то образом всё ещё осталась в системе. Этот статус "should never be seen" в нормальных условиях. Если вы видите `X`, это может быть признаком системных проблем, например, повреждения таблицы процессов.
    + `W`: Paging (процесс ожидает записи или чтения страниц памяти). Начиная с версии ядра 2.6.xxи выше, этот статус больше не отображается, так как управление памятью было улучшено и изменено, чтобы избегать долгих ожиданий своппинга
    + Дополнительные символы при выводе `stat` могут включать:
      + `<`: Высокий приоритет
      + `N`: Низкий приоритет
      + `L`: Заблокирован в памяти
      + `s`: Лидер сессии — это процесс, который первым создает сессию. Его `PID` становится идентификатором сессии (`SID`). Все процессы, созданные в этой сессии, будут иметь тот же `SID`. Лидер сессии не имеет управляющего терминала, что позволяет ему работать в фоновом режиме. Лидерами сессии обычно становятся:
        + **Дисплейный менеджер** (Display Manager, например `gdm`, `lightdm`, `sddm`). Эти процессы отвечают за управление графическими логинами пользователей. Они запускают графическую оболочку пользователя после аутентификации и становятся лидерами сессии для всех процессов, запущенных в этой графической оболочке.
        + **Инициализационные системы** (Init systems, например `systemd`, `init`). Инициализационные системы часто создают сессии для системных сервисов, которые они запускают при старте системы.
        + **Приложения с функцией демонизации** (например, `sshd` - SSH daemon). Когда пользователь подключается к серверу через `SSH`, процесс `sshd` создает новую сессию для управления этой подключенной сессией. `sshd` становится лидером этой сессии и управляет всеми дочерними процессами, запущенными в рамках этой сессии.
        + **Командные оболочки** (`Shells`, например, `bash`, `zsh`, `sh`). Когда пользователь входит в систему через терминал, процесс командной оболочки, такой как `bash`, создает новую сессию. Этот процесс становится лидером сессии и управляет всеми процессами, запущенными в этой оболочке
      + `l`: Многопоточный (использует `CLONE_THREAD`)
      + `+`: Процесс находится в группе процессов переднего плана (foreground process group)
+ `--sort <key>`: сортирует вывод по указанному ключу, например, `ps --sort=-%cpu`.
+ `--forest` служит для отображения процессов в виде дерева (аналогично команде `pstree`). Отображает родительские процессы и их дочерние процессы, наглядно показывая связи между ними.
#### Команда `pgrep`
Помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту `egrep`. По умолчанию команда `pgrep` выводит идентификаторы процессов (`PID`), которые соответствуют заданным критериям поиска. Ниже приведены ее основные параметры:
+ `-x`, `--exact`: Ищет процессы, имя которых точно совпадает с указанным шаблоном (по умолчанию ищет вхождения критериев поиска).
+ `-f`, `--full <condition>`: Ищет процессы по всей командной строке (по умолчанию ищет только в названии команды).
+ `-g`, `--pgroup <pgrp>`: Ищет процессы в указанных **процессных группах**. <a id="pgroup"></a>. Вы передаете значение `PGID` (число), а `pgrep` ищет все процессы, которые являются частью этой группы
  + **Процессная группа** - набор процессов, которые имеют общий идентификатор группы процессов (`PGID`). Этот `PGID` совпадает с `PID` **лидера процессной группы** (первого процесса, создавшего группу).
  + **Лидер процессной группы** — это процесс, чей `PID` равен `PGID` всей группы. Когда процесс завершает выполнение, процессная группа остаётся, пока в ней есть другие процессы.
  + Процессная группа создаётся, когда процесс вызывает `setpgid()` и назначает процессу новый `PGID`.
  + Все процессы в процессной группе могут управляться единым сигналом (например, с помощью команды `kill` или `pkill` с флагом `-g`)
  + Это полезно в задачах, где требуется координировать завершение или приостановку связанных процессов, например, при работе с конвейерами (`pipeline`) в `shell` (конвейер в `bash` (`ls | grep foo | sort`) обычно выполняется как одна процессная группа. Лидер группы обычно становится первым процессом в конвейере (например, здесь - `ls`)
+ `-G`, `--group <gid>`: Ищет процессы, принадлежащие указанным группам пользователей (`group IDs`).
+ `-u`, `--euid <euid>`: Ищет процессы, запущенные пользователями с указанным эффективным идентификатором пользователя (`EUID`). Эффективный `UID` используется системой для определения прав доступа процесса. Это может быть полезно, когда процесс выполняется с правами другого пользователя (например, через `sudo`). `pgrep -u root` - Этот пример найдет все процессы, запущенные с правами пользователя `root`.
+ `-U`, `--uid <uid>`: Ищет процессы, запущенные пользователями с указанным реальным идентификатором пользователя (`UID`). Реальный `UID` — это идентификатор пользователя, который изначально запустил процесс. `pgrep -U root` - Этот пример найдет все процессы, изначально запущенные пользователем root.
+ `-P`, `--parent <ppid>`: Ищет процессы, у которых указанный `PID` является родительским.
+ `-s`, `--session <sid>`: Ищет процессы в указанных сессиях.
+ `-t`, `--terminal <term>`: Ищет процессы, запущенные в указанных терминалах. *Терминал может включать процессы, принадлежащие разным сессиям*
+ `-i`, `--ignore-case`: Игнорирует регистр при поиске.
+ `-n`, `--newest`: Ищет только самые недавно запущенные процессы.
+ `-o`, `--oldest`: Ищет только самые старые процессы.
+ `-O`, `--older <secs>`: Ищет процессы, запущенные более указанного количества секунд назад.
+ `-v`, `--inverse`: Ищет процессы, не соответствующие указанным критериям.
+ `-l`, `--list-name`: Выводит имя процесса вместе с его `PID`.
+ `-a`, `--list-full`: Выводит полную командную строку вместе с `PID`.
+ `-c`, `--count`: Выводит количество процессов, соответствующих критериям поиска.
+ `-d`, `--delimiter <delimiter>`: Устанавливает значение, используемое для разделения идентификаторов процессов в выводе (по умолчанию - новая строка). `pgrep -d, ssh` - найдет все процессы с именем `ssh` и выведет их `PID`, разделенные запятыми
#### Псевдо-директория `/proc`
+ `/proc` - виртуальная файловая система, содержащая множество сведений о работающих процессах. В реальности на диске нет файлов, расположенных в директории `/proc`. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории `/proc`.
+ Все команды, относящиеся к процессам, такие как `ps`, `pstree`, `pgrep`, берут информацию из директории `/proc`.
+ Можно получить информацию о ваших процессах напрямую из директории `/proc`

Поскольку `/proc` представляется как обычная директория, к ней применимы почти все известные команды, предназначенные для работы с директориями. Например, `ls` для вывода списка содержимого, `egrep -r` для рекурсивного поиска последовательности символов и т.д.:
+ Чтобы определить точный путь к исполняемому файлу конкретного процесса, который обычно не отображается в выводе команды `ps`:
  ```console
  ls -l /proc/айди_процесса/exe
  lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/айди_процесса/exe -> /path/to/executable/file
  ```

+ Чтобы выяснить текущую рабочую директорию конкретного процесса:
  ```console
  ls -l /proc/айди_процесса/cwd
  lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/1234/cwd -> /path/to/current/directory
  ```
#### Отслеживание процессов и команда top
Команда top выводит в стандартный вывод (`stdout`) в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу (похожа на диспетчер задач Windows)

Команда `top` полезна для:
+ Поиска процессов, которые больше других потребляют ресурсы процессора и памяти.
+ Определение текущей загрузки системы.

Команда `top -b -n 1 > top_output.txt` используется для записи вывода команды `top` в файл в пакетном режиме.
+ `top`: Запускает команду `top`, которая отображает информацию о запущенных процессах и использовании системных ресурсов в реальном времени.
+ `-b`: Опция `-b` переводит `top` в пакетный режим (`batch mode`). В этом режиме `top` выводит данные в стандартный вывод (`stdout`) без интерактивного интерфейса, что удобно для записи в файл.
+ `-n 1`: Опция `-n` указывает количество обновлений, которые `top` должен выполнить перед завершением. В данном случае `-n 1` означает, что `top` выполнит одно обновление и завершит работу.
+ `> top_output.txt`: Перенаправляет вывод команды `top` в файл top_output.txt.

Фильтрация процессов по пользователю username:
+ `top -u username`
### Сигналы
**Сигнал** — это короткое сообщение, которое можно отправить процессу, группе процессов или сессии.
#### `kill`
Используется, когда известны конкретные `PID` или `PGID` процессов, которые нужно завершить

`kill [-ЧТО] PID` - отправляет сигнал ЧТО (например, `TERM`, `KILL`, `STOP` и т. д.) процессу с идентификатором `PID`. Для группы процессов или сессии отличие в вызове `kill` заключается в том, в команду нужно передавать отрицательное значение идентификатора группы процессов (`PGID`) или идентификатора сессии (`SID`).
+ `kill -KILL PID` или `kill -9 PID` - уничтожить процесс
+ `kill -KILL -PGID` или `kill -9 -PGID` - уничтожить [процессную группу](#pgroup)
#### `killall` 
+ используется (в отличие от `kill`) для отправки сигналов всем процессам с определенным именем. Это удобно, когда нужно завершить все процессы с заданным именем, независимо от их `PID`.
+ по умолчанию ищет процессы в имени процесса (без значений аргументов командной строки)
+ синтаксис:

  ```console
  killall [-Z, --context <pattern>] [-e, --exact]
        [-g, --process-group] [-i, --interactive] [-n, --ns <PID>]
        [-o, --older-than <TIME>] [-q, --quiet] [-r, --regexp]
        [-s, --signal <SIGNAL>, -SIGNAL] [-u, --user <user>] [-v, --verbose]
        [-w, --wait] [-y, --younger-than <TIME>] [-I, --ignore-case]
        [-V, --version] [--] name ...
  killall -l, --list
  killall -V, --version
  ```

Опции:
+ `-e, --exact` - используется для точного совпадения имени процесса. Это особенно полезно, если есть несколько процессов с похожими именами, и вы хотите завершить только те, чьё имя совпадает полностью. Без `-e` по умолчанию `killall` выполняет поиск процесса по частичному совпадению имени. Если имя процесса является подстрокой другого имени, команда завершит оба процесса.
+ `-I, --ignore-case` - позволяет игнорировать регистр символов при поиске процессов..
+ `-g, --process-group` - завершить [процессную группу](#pgroup), в которую входит процесс. Когда вы указываете процесс внутри группы с помощью `killall -s <SIGNAL> -g <process_name>`, команда автоматически определяет процессную группу, к которой принадлежит указанный процесс, и отправляет сигнал всей группе.
+ `-i, --interactive` - Запрашивать подтверждение перед завершением процессов.
+ `-l, --list` - Показать все известные имена сигналов, какие можно отправить процессам с помощью команды `killall`.
+ `-n, --ns <PID>` - Искать процессы в пространстве имён `PID` контейнера (Docker и др) (без флага `-n, --ns` по умолчанию поиск выполняется по всем пространствам имён):
  1. сперва нужно получить `PID` контейнера, например: `docker inspect --format '{{ .State.Pid }}' abcdef123456`, предположим, команда вернула `PID` 12345:
     1. `docker inspect` - команда предоставляет подробную информацию о контейнере Docker, включая его конфигурацию, состояние, сетевые настройки и другие параметры
     2. `--format '{{ .State.Pid }}'`: Опция --format используется для вывода конкретной информации из результатов команды `inspect`. В данном случае форматирование `{{ .State.Pid }}` означает, что будет выведен только `PID` контейнера, который находится в состоянии `State`.
     3. abcdef123456: Это идентификатор контейнера или его имя (можно получить из `docker ps`)
  2. теперь завершаем процесс `myprocess` в искомом пространстве имён: `sudo killall --ns 12345 -s SIGTERM myprocess`
+ `-o, --older-than <ВРЕМЯ>` - Искать процессы, старее (запущенные до) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть `s`,`m`,`h`,`d`,`w`,`M`,`y` (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
+ `-q, --quiet` - подавляет вывод сообщений об ошибках, если не удаётся найти процессы с указанным именем. Это делает команду "тихой" и особенно полезной в сценариях автоматизации, где нежелательно, чтобы команда выводила сообщения на стандартный вывод.
+ `-r, --regexp` - позволяет использовать шаблон имени процесса как расширенное регулярное выражение `POSIX` согласно `regex(3)` (менее гибкий стандарт, по сравнению с `POSIX ERE` (Extended Regular Expressions), применяемых в `killall` ).
+ `-s, --signal <СИГНАЛ>` - Посылать указанный `СИГНАЛ`, а не `SIGTERM`.
+ `-u, --user <userName>` - позволяет завершить процессы, принадлежащие указанному пользователю. Имена команд необязательны (если не указывать имя процесса: `sudo killall -u username` - завершит все процессы пользователя `username`).
+ `-v, --verbose` - включает подробный вывод информации о выполняемых действиях. Это означает, что команда будет сообщать, какие процессы она завершила, их `PID` и, в некоторых случаях, статус выполнения.
+ `-V, --version` - Показать информацию о версии.
+ `-w, --wait` - указывает `killall` ожидать завершения процессов, соответствующих заданному условию. `killall` проверяет раз в секунду существование завершаемых процессов и прекращает работу только если никого не осталось. `killall` может ждать вечно, если сигнал был проигнорирован, никак не повлиял или если процесс остался в состоянии зомби. Эта команда полезна, когда вам нужно убедиться, что все процессы действительно завершены перед выполнением следующих действий.
+ `-y, --younger-than <ВРЕМЯ>` - Искать процессы, новее (запущенные после) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть `s`,`m`,`h`,`d`,`w`,`M`,`y` (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
+ `-Z, --context` - Задать контекст безопасности: завершать только процессы с контекстом безопасности, который совпадает с заданным шаблоном расширенного регулярного выражения. В командной строке должен указываться раньше остальных параметров. Имена команд необязательны.
#### pkill
+ ищет по имени процесса, отправляя один и тот же сигнал нескольким процессам, названия которых отвечают некоторому условию, как и `killall`
+ предоставляет полную (в отличие от `killall`) поддержку сложных регулярных выражений, основанных на регулярных выражениях библиотеки `PCRE` (Perl-Compatible Regular Expressions), более гибкие и мощные по сравнению с `POSIX ERE` (Extended Regular Expressions), применяемых в `killall`.;
+ позволяет гибко фильтровать процессы, поддерживая множество атрибутов;
+ *похожа на команду `pgrep`*
+ синтаксис функции:  `pkill [options] <pattern>`

Опции:
+ `-<sig>, --signal <sig>` - сигнал для отправки (номер или имя)
+ `-q, --queue <value>` -  позволяет отправить один из сигналов реального времени (номера начинаются с `SIGRTMIN` и заканчиваются `SIGRTMAX`), который обрабатывается только в том случае, если приложение запрограммировано на это. Если приложение не настроено для работы с сигналами реального времени, сигнал будет проигнорирован. Чтобы отправить сигнал реального времени с номером 3, который соответствует `SIGRTMIN + 3`, вы используете `pkill -q 3 process_name`
  + стандартные сигналы имеют более высокий приоритет перед сигналами реального времени
  + если процесс получает несколько сигналов реального времени, они доставляются в порядке отправки
  + в отличие от стандартных сигналов (например, несколько `SIGTERM` могут быть обработаны как один), сигналы реального времени обрабатываются поштучно
+ `-e, --echo` - предназначена для вывода на экран имен процессов, которые были завершены
+ `-c, --count` - используется для вывода количества процессов, которые будут или были завершены. Это полезно, если вы хотите узнать, сколько процессов соответствует заданным критериям, не завершая их фактически.
+ `-f, --full`- используется для поиска процессов по полному командному пути или строке команды, а не только по имени процесса. Это позволяет точнее указывать процессы, которые нужно завершить, особенно если у вас запущено несколько процессов с одинаковым именем
+ `-g, --pgroup <PGID,...>`- используется для завершения процессов, принадлежащих к определенным [процессным группам](#pgroup)
+ `-G, --group <GID,...>` - используется для завершения процессов, принадлежащих определенным группам пользователей (`GID`). Эта опция позволяет завершать процессы, которые принадлежат пользователям из указанных групп.
+ `-i, --ignore-case` - используется для игнорирования регистра символов при поиске процессов по имени.
+ `-n, --newest` - используется для завершения самого недавно запущенного процесса, соответствующего указанным критериям. Эта опция позволяет нацелиться на последний процесс, который был запущен, если у вас есть несколько процессов с одинаковым именем или другими критериями.
+ `-o, --oldest` - используется для завершения самого старого запущенного процесса, соответствующего указанным критериям. Это позволяет нацелиться на первый запущенный процесс из группы процессов с одинаковыми характеристиками
+ `-O, --older <seconds>` - используется для завершения процессов, которые были запущены раньше, чем заданное количество секунд назад. Это позволяет нацелиться на процессы, которые работают более длительное время, чем указано в параметре
+ `-P, --parent <PPID,...>` - используется для завершения процессов, чьими родительскими процессами являются указанные идентификаторы родительских процессов (`PPID`). Это позволяет нацелиться на процессы, запущенные конкретными родительскими процессами
+ `-s, --session <SID,...>` - используется для завершения процессов, принадлежащих указанным сессиям (`SID`). Это позволяет нацелиться на процессы, запущенные в определенных сессиях, что может быть полезно для управления процессами пользователей, работающих в различных сессиях
+ `-t, --terminal <tty,...>` - используется для завершения процессов, которые связаны с указанными терминалами
+ `-u, --euid <ID,...>` - используется для завершения процессов, принадлежащих пользователям с указанными эффективными пользовательскими идентификаторами (`EUID`).
+ `-U, --uid <ID,...>`- используется для завершения процессов, принадлежащих пользователям с указанными реальными пользовательскими идентификаторами (`UID`)
+ `-x, --exact` - используется для выполнения точного совпадения имени процесса. Это означает, что только те процессы, чьи имена полностью совпадают с указанным шаблоном, будут завершены.
+ `-F, --pidfile <file>` - используется для указания файла, содержащего идентификаторы процессов (`PID`), которые нужно завершить. Файл должен содержать один или несколько `PID`, каждый на отдельной строке. В этом случае команда `pkill` прочитает заданный файл, извлечет из него идентификаторы процессов и завершит их.
+ `-L, --logpidfile <file>` - используется для записи идентификаторов процессов (`PID`) в указанный `PID`-файл. Обычно эта опция применяется вместе с другими командами и параметрами, чтобы сохранить информацию о процессах, которые были завершены `pkill -L /path/to/logfile -u myuser`.
+ `-r, --runstates <state>` - используется для завершения процессов, которые находятся в определенных состояниях выполнения. Процессы в Unix-подобных операционных системах могут находиться в различных состояниях, таких как `R`: работающий (Running), `S`: спящий (Sleeping), `D`: ожидание (Uninterruptible Sleep), `T`: остановленный (Stopped), `Z`: зомби (Zombie).
+ `-A, --ignore-ancestors` - используется для исключения процессов-родителей из поиска. Это особенно полезно, если вы хотите завершить процесс, но не хотите затронуть его предка (например, оболочку или процесс-родитель, который его запустил)
+ `--cgroup <grp,...>` - используется для завершения процессов, принадлежащих определенным группам управления (`cgroup`). `Cgroups` или `control groups` - это механизм в Linux, который позволяет ограничивать, учитывать и изолировать использование ресурсов (таких как ЦП, память, ввод-вывод) для группы процессов
+ `--ns <PID>` - используется для выбора процессов, которые находятся в одном и том же пространстве имен (`namespace`) процессов, что и указанный процесс с идентификатором (`PID`). Пространства имен (`namespaces`) в Linux позволяют изолировать процессы и ресурсы, создавая таким образом отдельные рабочие среды для процессов.
+ `--nslist <ns,...>` - используется для выбора процессов, которые находятся в определенных пространствах имен (namespaces). Пространства имен в Linux позволяют изолировать различные аспекты системы, такие как процессы, сеть, файловая система, и т.д. Список доступных пространств имен, которые можно использовать с этой опцией, может включать следующие: `mnt` (пространство имен монтирования), `uts` (пространство имен узла), `ipc` (пространство имен межпроцессного взаимодействия), `net` (пространство имен сети), `pid` (пространство имен процессов), `user` (пространство имен пользователей)
 + `-h, --help` - используется для отображения справочной информации по команде и ее опциям 
 + `-V, --version` - используется для отображения версии программы `pkill`
#### Полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:
+ `TERM (15)` — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
+ `KILL (9)` — уничтожить: безусловное завершение работы процесса без выполнения каких-либо завершающих действий, таких как удаление временных файлов или закрытие открытых файлов. Не может быть проигнорирован процессом
+ `INT (2)` — прервать посредством терминала: отправляется, когда пользователь нажимает клавиши `Ctrl+C`. По умолчанию `SIGINT` завершает процесс, но процесс может перехватить сигнал и выполнить какую-либо очистку, альтернативное действие перед завершением или проигнорировать. (т.е. по своему действию похож на `TERM`)
+ `TSTP (20)` — приостанавливает работу процесса посредством терминала: автоматически отправляется системой, когда пользователь нажимает клавиши `Ctrl+Z`. Предназначен для процессов, работающих в интерактивном режиме.
+ `STOP (19)` — приостанавливает работу процесса аналогично `TSTP`, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал `KILL`, не может быть проигноирован процессом.
+ `CONT (18)` — продолжить: также отправляется автоматически системой, когда пользователь выполняет команду `fg` или `bg` с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала `STOP`, можно возобновить сигналом `CONT`.

Если приложение, включая демон, не настроено на обработку определенных сигналов, оно, скорее всего, будет игнорировать такие сигналы. **НО ЕСТЬ СИГНАЛЫ, КОТОРЫЕ ПРОГРАММА БУДЕТ ОБРАБАТЫВАТЬ**, даже если специально не настроена на это. Эти сигналы не могут быть проигнорированы или заблокированы. К ним относятся:
+ `KILL (9)`: Этот сигнал завершает процесс немедленно. Процесс не может поймать, игнорировать или блокировать этот сигнал. Он используется для принудительного завершения процессов.
+ `STOP (19)`: Этот сигнал приостанавливает выполнение процесса. Подобно `KILL (9)`, процесс не может поймать, игнорировать или блокировать этот сигнал. Он часто используется для временной приостановки процессов.
## Службы (services) Linux
 **Служба Linux** - "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС. **Служба Linux**, построена вокруг программы и отвечает на вопрос "КАК именно следует управлять этой программой":
+ Должна ли она запускаться во время загрузки системы?
+ Как запустить ее вручную при необходимости?
+ Какие опции предоставляются программе при запуске?
+ Как отслеживать ее состояние?
+ Как аккуратно завершить ее работу?
+ Нужно ли перезапускать ее в случае нештатного завершения?
+ Какие другие службы должны быть запущены перед запуском этой конкретной?
### Systemd
+ Systemd — это комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами (принята как замена системы инициализации SysV init).
+ Systemd оперирует следующими объектами, называемыми "юнитами":
  + Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
  + Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
  + сокеты, таймеры и др.
### Службы в контексте systemd
+ Службы, добавленные к systemd вместе с их настройками (известными также как **юнит-файлы**), находятся в директории `/etc/systemd/system` и ее вложенных директориях. Обычно **юнит-файлы представляют собой символьные ссылки** на «настоящие» файлы, расположенные в директории `/usr/lib/systemd/system`.
### Структура Unit-файла сервиса
```console
[Unit]
Description=Краткое описание сервиса
Documentation=URL-документации
Requires=другие_юниты_требуемые_для_запуска
Wants=другие_юниты_желательные_для_запуска
After=юниты_которые_должны_запуститься_перед_этим
Before=юниты_которые_должны_запуститься_после_этого
Conflicts=юниты_которые_конфликтуют_с_этим
ConditionPathExists=/путь/к/файлу (условие для запуска)

[Service]
Type=simple (или другие типы: forking, oneshot, dbus, notify, idle)
ExecStart=/путь/к/исполняемому_файлу (основная команда для запуска сервиса)
ExecStartPre=/путь/к/исполняемому_файлу_предварительно (команда, выполняемая перед запуском основного процесса)
ExecStartPost=/путь/к/исполняемому_файлу_после (команда, выполняемая после запуска основного процесса)
ExecStop=/путь/к/исполняемому_файлу_для_остановки (команда для остановки сервиса)
ExecReload=/путь/к/исполняемому_файлу_для_перезагрузки (команда для перезагрузки сервиса)
Restart=always (политика перезапуска: no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, или always)
RestartSec=5 (время ожидания перед перезапуском)
User=имя_пользователя (пользователь, от имени которого запускается сервис)
Group=имя_группы (группа, от имени которой запускается сервис)
WorkingDirectory=/путь/к/рабочему_каталогу (рабочий каталог для процесса)

[Install]
WantedBy=multi-user.target (указывает таргеты, в которые включен этот юнит)
RequiredBy= (другие юниты, которые зависят от этого юнита)
Also= (другие юниты, которые должны быть включены вместе с этим)
Alias= (другие имена для этого юнита)
`
+ Раздел [Unit] содержит общую информацию о юните и его зависимостях
+ Раздел [Service] используется для определения параметров и команд, необходимых для запуска, остановки и перезапуска сервисов.
+ Раздел [Install] определяет параметры, связанные с установкой и включением юнита.
#### Вывод списка активных служб (units) в системе, управляемой systemd
`systemctl list-units --type=service` показывает только те службы, которые в данный момент активны (запущены или в других состояниях активности)
`console
$ systemctl list-units --type=service
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
apparmor.service                    loaded active exited  Load AppArmor profiles
...
```
где 
+ `UNIT`: Название службы.
+ `LOAD`: показывает статус загрузки конфигурационного файла сервиса. Возможные значения:
  + `loaded`: Конфигурационный файл сервиса загружен и разобран успешно.
  + `not-found`: Конфигурационный файл сервиса не найден.
  + `error`: Произошла ошибка при загрузке конфигурационного файла.
  + `masked`: Сервис замаскирован, что предотвращает его случайный запуск
+ `ACTIVE`: показывает общий статус активности сервиса. Возможные значения:
  + `active`: Сервис запущен и работает нормально.
  + `reloading`: Сервис в процессе перезагрузки конфигурации.
  + `inactive`: Сервис не запущен.
  + `failed`: Сервис завершился с ошибкой.
  + `activating`: Сервис находится в процессе запуска.
  + `deactivating`: Сервис находится в процессе остановки.
+ `SUB`: показывает более детальную информацию о состоянии сервиса, дополняя статус в столбце ACTIVE. Возможные значения различаются в зависимости от типа сервиса, но некоторые примеры включают:
  + `running`: Сервис запущен и работает (соответствует active в ACTIVE).
  + `exited`: Сервис завершил работу (может быть нормальное завершение, соответствует inactive в ACTIVE).
  + `dead`: Сервис не работает и не запускается (соответствует inactive в ACTIVE).
  + `auto-restart`: Сервис настроен на автоматический перезапуск (обычно временный статус).
  + `failed`: Сервис завершился с ошибкой (соответствует failed в ACTIVE).
+ `DESCRIPTION`: Описание службы.
#### Вывод списка активных служб (units) в системе, которые находятся в состоянии "running"
```console
$ systemctl list-units --type=service --state=running
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
avahi-daemon.service                loaded active running Avahi mDNS/DNS-SD Stack
...
```
#### Вывод всех файлов units (сервисов) вместе с их состоянием включения
`systemctl list-unit-files` отображает все доступные на системе файлы unit (сервисы), вне зависимости от их текущего состояния активности
```console
$ systemctl list-unit-files --type=service
UNIT FILE                                   STATE   
accounts-daemon.service                     enabled 
apparmor.service                            enabled 
apt-daily-upgrade.service                   enabled 
dbus-org.bluez.service                      alias   
dbus.service                                static  
debug-shell.service                         disabled
grub-common.service                         masked  
...
```
##### Группа состояний настройки запуска служб
+ `enabled`: Служба настроена на автоматический запуск при загрузке системы.
+ `disabled`: Служба не настроена на автоматический запуск при загрузке системы.
+ `static`: в unit-файле службы отсутствует секция [Install], что делает их неспособными к автоматическому запуску. Они могут быть запущены вручную или как зависимости других служб.
+ `masked`: Служба замаскирована это значит, что она заблокирована для запуска и не может быть запущена ни вручную, ни автоматически, пока не будет размаскирована. Замаскированная служба фактически отключена и недоступна для выполнения. `systemctl mask|unmask example.service`
+ `alias`: Служба является псевдонимом другой службы.

Чтобы увидеть только включенные службы, выполните:
`systemctl list-unit-files --type=service --state=enabled` - вернёт список всех unit-файлов для сервисов (.service), которые включены (enabled) в системе. Включенные сервисы автоматически запускаются при загрузке системы или при активации соответствующего таргета.
#### Проверка текущего состояния службы (по названию)
`systemctl status название_службы`
#### Проверка текущего состояния службы (по процессу)
`systemctl status PID_процесса`
#### Запуск/остановка/перезапуск службы
```console
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
Для выполнения необходимы права root
#### Включение и отключение автоматического запуска службы на этапе загрузки ОС
`systemctl enable|disable [--now] название_службы` - включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы).

Для выполнения необходимы права root
#### Узнать настройки автоматического запуска конкретной службы
`systemctl is-enabled название_службы`
## Отличие сервисов (служб) от приложений
| | Серверные приложения | Службы systemd |
|-------------|-------------|-------------|
| Основное назначение    | Обработка запросов пользователей и выполнение действий в рамках прикладной логики (например, сервер MySQL сохраняет данные и обрабатывает запросы на языке SQL)    | Упрощение управления приложениями (запуск, останов, перезапуск, проверка состояния и т. д.)    |
| Управление приложениями    | Для каждого серверного приложения (если он запущено само по себе, а не как служба) предусмотрен свой способ управления. Даже простые операции (проверка, запуск, перезапуск, останов) разных приложений имеют свои особенности    |Приложения, "обернутые" в сервис, управляются одним и тем же способом — посредством команды systemctl и её опций.    |
| Конфигурация | Хранится в файле конфигурации, специфичном для приложения (например, /etc/my.cnf). Содержит главные параметры приложения, такие как прослушиваемые порты, степень подробности журналирования, настройки проверки подлинности пользователей и многие другие | Хранится в юнит-файлах с общим форматом (например, /usr/lib/systemd/system/mysqld.service). Содержит условия запуска, требуемые права пользователя, внешние зависимости от других служб, действия при запуске и останове, путь к исполняемому файлу и аргументы. Не описывает конфигурацию самого приложения! |
| Журналирование (логирование)    | Полностью зависит от конкретного приложения. Настройки журналирования (например, степень подробности и формат) очень гибкие и задаются в файле(ах) конфигурации приложений. Журналы чаще всего представляют собой текстовые файлы (например, /var/log/mysqld.log)    | Файлы журналов служб systemd: обычно содержат меньше информации по сравнению с файлами журналов приложений (записываются только основные события); хранятся в едином двоичном формате; доступ к ним можно получить с помощью команды journalctl    |
## Юнит-файлы сервисов по сравнению с файлами конфигурации приложений
|  | Файл конфигурации приложения java-auth | Юнит-файл сервиса java-auth.st00 |
|-------------|-------------|-------------|
| Местоположение файлов конфигурации    | Полностью зависит от самого приложения. В нашем примере далее показан файл /apps/java/auth/st00/application.properties. Конфигурации основных серверных приложений (например, SSH server) часто содержатся в директории/etc    | Обычно где-то в директории /usr/lib/systemd/system (сами конфигурации) и (или) /etc/systemd/system (обычно символьные ссылки на файлы конфигурации). Показанный далее юнит-файл взят из /etc/systemd/system/multi-user.target.wants/java-auth.st00.service    |
| Основное назначение    | Содержит специфичные для приложения настройки, такие как используемые сервером порты, адрес и тип базы данных для подключения, учётная запись и пароль базы данных. Формат файла и набор параметров полностью зависит от каждого приложения. В нашем примере используется очень простое учебное приложение. Реальное серверное приложение может предусматривать огромные файлы конфигурации с тысячами строк.    | Содержит стартовые условия запуска, требуемые права пользователя (см. переменные User и Group далее), внешние зависимости от других служб (см. After), действия при запуске и останове (см. ExecStop), путь к исполняемому файлу (см. ExecStart) и аргументы. Не описывает конфигурацию самого приложения! Формат един для всех служб системы.    |
| Содержимое файла    | server.port=7000<br> debug=false<br> spring.jpa.hibernate.ddl-auto=updates<br> spring.datasource. url=jdbc:mysql://192.168.40.150:3306/auth_st00<br> spring.datasource.username=dbst00<br> spring.datasource.password=your_password_here    | [Unit]<br>Description=Java auth service for Roles app, per user<br> After=network.target<br><br>[Service]<br>SuccessExitStatus=143<br> User=st00<br> Group=qa<br> Type=simple<br> ExecStart=/apps/java/auth/st00/java-start-auth.sh<br> ExecStop=/bin/kill -15 $MAINPID<br> TimeoutSec=60<br><br>[Install]<br> WantedBy=multi-user.target    |
## Journalctl: вывод журналов служб systemd
`journalctl` — это инструмент для управления журналами служб systemd. 

Для выполнения этой команды необходимы права `root` или включение в группу `systemd-journal`.

### Просмотр всех записанных в журнал событий для службы (по имени)
`journalctl -u service_name` (`journalctl  -e -u service_name` - то же, но с переходом к последним строкам журнала)
### Отслеживание событий службы в реальном времени и вывод их на терминал
`journalctl -f -u service_name` - наподобие команды `tail -f` 
### Просмотр событий от нескольких служб одновременно
`journalctl -u service_name_1 -u service_name_2 ...` - Эту функцию можно сочетать с другими опциями, например -f

