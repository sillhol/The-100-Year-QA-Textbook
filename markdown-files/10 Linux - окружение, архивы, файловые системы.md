# 10 Linux - окружение, архивы, файловые системы
## Информация о системе. Что и как собирать
При создании отчёта о дефекте важно предоставить информацию об окружении, в котором дефект был найден. Наиболее востребованная и запрашиваемая информация следующая:
+ Версия ядра операционной системы (ОС).
+ Название и версия дистрибутива Linux.
+ Имя компьютера, IP-адрес(а) и другие настройки сети (об этом поговорим в секциях, посвящённых сетям).
+ (В некоторых случаях.) Запущенные процессы и службы — это мы подробно обсудили в предыдущей секции.
+ (В некоторых случаях.) Сведения об аппаратном обеспечении: центральном процессоре (ЦП), памяти и жёстких дисках.
+ (В некоторых случаях.) Подключённые файловые системы, их полный и свободный объём.
### Операционная система и дистрибутив Linux
#### Ядро (Linux Kernel):
##### Определение
Ядро — это центральный компонент операционной системы, который управляет аппаратными ресурсами компьютера и предоставляет основные услуги для других частей системы.
##### Функция
Ядро управляет процессами, памятью, файловыми системами, аппаратными устройствами (через драйверы) и обеспечивает коммуникацию между программным обеспечением и аппаратным обеспечением.
##### Примеры версий ядра
5.4.0, 4.19.0, 3.10.0.
##### Состав
Содержит модули для управления памятью, процессами, файловыми системами, сетевыми стеками, драйверами устройств и прочими низкоуровневыми функциями.
#### Архитектура (Hardware Architecture):
##### Определение
Архитектура — это дизайн и структура аппаратного обеспечения, на котором работает операционная система.
##### Примеры
x86 (32-битная архитектура), x86_64 (64-битная архитектура, также известная как AMD64), ARM, ARM64.
##### Функция
Определяет, каким образом процессор и другие компоненты компьютера взаимодействуют и обрабатывают инструкции.
##### Состав
Описывает процессорные регистры, команды, размер адресного пространства, способ взаимодействия с памятью и периферийными устройствами.
#### Дистрибутив (дистрибутивная версия):
##### Определение
Дистрибутив Linux — это комплект программного обеспечения, основанный на ядре Linux и включающий в себя различные дополнительные компоненты, такие как системные библиотеки, приложения, утилиты и средства управления пакетами.
##### Примеры
Ubuntu, Fedora, Debian, Arch Linux.
##### Функция
Дистрибутивы обеспечивают удобную установку и использование операционной системы, предоставляют предварительно настроенные и готовые к использованию системы, а также регулярно выпускают обновления и исправления.
##### Состав
Включает ядро Linux, системные утилиты, графические интерфейсы, менеджеры пакетов (например, apt для Debian/Ubuntu, dnf для Fedora), и другие приложения.
#### Методы получить информацию про дистрибутив и ядро
+ ```uname``` - Узнать название ОС
+ ```uname -r``` - Узнать версию ядра ОС
+ ```uname -a``` - Узнать больше сведений о компьютере, включая имя узла
+ ```cat /etc/os-release``` - Узнать версию дистрибутива Linux
+ ```hostnamectl``` -  Узнать информацию о системе, включая операционную систему, ядро и архитектуру (используется в системах, работающих с systemd):
```console
$ hostnamectl
   Static hostname: myhostname
         Icon name: computer-laptop
           Chassis: laptop
  Operating System: Ubuntu 20.04.2 LTS
            Kernel: Linux 5.4.0-73-generic
      Architecture: x86-64
```
### Сведения об аппаратном обеспечении и производительности
#### CPU (процессоры)
+ ```lscpu```. Предоставляет следующую информацию:
  + **Architecture (архитектура)**: в большинстве современных устройств это x86_64, но могут встречаться и другие. Например: процессор с архитектурой ARM не может выполнять программы, написанные для x86_64.
  + CPU(s) (процессор): суммарное количество потоков = количество ЦП × кол-во ядер на разъём × кол-во потоков на ядро.
  + **On-line CPU(s) list** (список процессоров, отображаемый в реальном времени): какие ядра доступны в текущий момент; в большинстве случаев доступны все ядра. Номера процессоров начинаются с 0.
  + **Thread(s) per core**: (потоков на ядро): как говорилось выше, существуют однопоточные и многопоточные процессоры. Эти сведения указываются в этом поле.
  + **Core(s) per socket**: (ядер на разъём): количество ядер у каждого процессора.
  + **Socket(s)**: (разъёмы): количество процессоров (не ядер), установленных на компьютере. Для бытовых устройств, таких как настольные персональные компьютеры, ноутбуки и т. д., этот параметр почти всегда равен 1. Для мощных серверов этот параметр, как правило, превышает 1.
  + **Vendor ID, Model name** (идентификатор производителя, название модели): описывает модель процессора.
  + **CPU MHz**: (частота процессора в МГц): частота, которая может динамически варьироваться, как видно на снимке экрана, показанного выше
+ ```cat /proc/cpuinfo``` - выводит ту же информацию, но сведения для каждого ядра ЦП приводятся отдельно. Поэтому объём данных в этом файле намного больше, они представлены в менее ясной форме и не содержат ничего нового по сравнению с выводом команды lscpu.

Один физический процессор, который содержит четыре ядра с двумя потоками в каждом, будет виден операционной системе как восемь отдельных процессоров, способных одновременно обрабатывать восемь вычислительных задач

**Ядро** — это по большей части независимый вычислительный блок внутри процессора, способный выполнять программы самостоятельно, без взаимодействия с другими ядрами. Поэтому каждое ядро операционная система воспринимает как отдельный процессор

**Потоки**: для многопоточных ядер возможно одновременное выполнение более одного процесса на ядро. Это не означает, что одно многопоточное ядро имеет такую же производительность, как два однопоточных; на самом деле, этот показатель можно приблизительно оценить как 1,5

**Тактовая частота процессора**: чем больше значение частоты в МГц, тем быстрее выполняются инструкции процессора, что приводит к повышению производительности

##### Команда top в Linux
Команда top в Linux предоставляет информацию о текущих процессах и использовании системных ресурсов в реальном времени. 

Поля ```us```, ```sy```, ```ni``` в верхней части вывода команды top отображают процентное использование процессора различными типами задач:
+ ```us (user)```: Описание: Процент времени, в течение которого процессор занят выполнением задач в пользовательском пространстве (user space). Это время включает выполнение приложений и команд, запущенных пользователем, за исключением задач с изменённым приоритетом.
+ ```sy (system)```: Описание: Процент времени, в течение которого процессор занят выполнением задач в системном пространстве (kernel space). Это время включает выполнение системных вызовов, работы с драйверами и другими задачами ядра.
+ ```ni (nice)```: Описание: Процент времени, в течение которого процессор занят выполнением задач с изменённым приоритетом (nice value). Это пользовательские процессы, которым было присвоено определённое значение приоритета (nice value), влияющее на их приоритет выполнения.

Постоянно высокие значения полей ``us``, ```sy```, ```ni``` означают, что компьютер находится под высокой нагрузкой

Поле ```wa (wait)``` в выводе команды top отображает процент времени, в течение которого процессор ожидает завершения операций ввода-вывода (I/O wait). Это время, в течение которого процессор не выполняет никаких задач, так как он ждет, пока операции ввода-вывода (например, ожидание данных от жесткого диска, сетевых устройств и других периферийных устройств) будут завершены

Пример вывода команды top:

```%Cpu(s):  2.3 us,  1.5 sy,  0.0 ni, 95.7 id,  0.3 wa,  0.0 hi,  0.2 si,  0.0 st```

Для сохранения вывода команды top, включая значения ```%Cpu(s)```, в файл, можно использовать перенаправление вывода команды в файл: 

```top -b -n 1 | grep -E '^%Cpu' > cpu_usage.txt```, где
+ ```top -b -n 1```: Запускает команду ```top``` в пакетном режиме (```-b```), который выводит результаты в текстовом формате, а также останавливает команду после выполнения одного цикла. Параметр ```-n 1``` указывает, что ```top``` должен выполнить только один цикл и завершиться.
+ ```grep -E '^%Cpu'```: Фильтрует вывод ```top```, оставляя только строки, начинающиеся с ```%Cpu```. Параметр ```-E``` позволяет использовать расширенные регулярные выражения.
+ ```> cpu_usage.txt```: Перенаправляет вывод отфильтрованной команды в файл cpu_usage.txt.
#### Оперативная память
В современных операционных системах используется два типа памяти:
+ RAM (ОЗУ, оперативное запоминающее устройство): это «настоящая» память.
+ Swap (память подкачки): память на диске, обычно используемая для выгрузки на диск неактивных приложений, когда ОЗУ заполнено. Она намного медленнее по сравнению с ОЗУ, поэтому если память подкачки активно используется, то работа компьютера будет также значительно замедленна.
+ ```free``` - используется для вывода информации о использовании оперативной памяти (RAM) и области подкачки (swap). Она предоставляет общее количество доступной, используемой, свободной памяти и размер подкачки. Поля вывода ```free```:
  + ```total```: Общее количество памяти в системе.
  + ```used```: Количество использованной памяти.
  + ```free```: Количество доступной свободной памяти для новых процессов.
  + ```shared```: Количество памяти, которая используется для совместного использования между процессами.
  + ```buff/cache```: Количество памяти, используемой в качестве кэша и буферов.
  + ```available```: Оценка доступной памяти для новых процессов, учитывая кэш и буферы (которые можно очистить).

```free -m``` - Объём памяти показывается командой free в МБ (по умолчанию - в килобайтах)
#### Другие параметры: lsblk, lsusb, lspci 
##### lsblk
Используется для вывода информации о блочных устройствах, таких как жесткие диски и разделы, на вашей системе. Она предоставляет структурированный список блочных устройств, их разделов и связанных с ними меток

Пример вывода ```lsblk```:

```console
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda           8:0    0 931.5G  0 disk 
├─sda1        8:1    0   512M  0 part /boot/efi
├─sda2        8:2    0   244M  0 part /boot
└─sda3        8:3    0 930.8G  0 part 
  └─ubuntu--vg-root
            252:0    0 917.8G  0 lvm  /
sr0          11:0    1  1024M  0 rom  
```
*Поля вывода lsblk*:
+ NAME: Имя устройства.
+ MAJ:MIN: Мажорный и минорный номера устройства.
+ RM: Съемное устройство (1) или нет (0).
+ SIZE: Общий размер устройства.
+ RO: Флаг "только для чтения" (1) или нет (0).
+ TYPE: Тип устройства (disk, part, rom и т. д.).
+ MOUNTPOINT: Точка монтирования для раздела или устройства. !!! Эту информацию можно также получить с помощью команд mount и df

*Какие устройства отображаются lsblk*:
+ ```sda```, ``sdb``, ...: Жесткие диски.
+ ```sda1```, ```sda2```, ...: Разделы на жестком диске.
+ ```sr0```, ```sr1```, ...: CD/DVD-ROM устройства.
+ ```mmcblk0```, ```nvme0n1```, ...: Другие блочные устройства:
  + ```mmcblkX```: MMC/SD устройства: Например, SD-карты или eMMC-накопители, обозначаемые как mmcblkX.
  + ```nvme0nX```: NVMe устройства: SSD, подключенные через интерфейс NVMe

*Полезные флаги команды lsblk:*
+ ```-f```: Выводит подробную информацию о файловой системе.
+ ```-m```: Отображает информацию в мегабайтах, гигабайтах и т. д.
+ ```-p```: Показывает устройства в виде полных путей к устройствам.
+ ```-o```: Позволяет выбрать, какие поля должны быть отображены в выводе.
##### lsusb
Используется для вывода списка всех периферийных устройств, обычно подключаемых к порту USB компьютера, и информации о них.

Пример вывода ```lsusb```:

```console
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 004: ID 046d:c534 Logitech, Inc. Unifying Receiver
Bus 001 Device 003: ID 045e:07fd Microsoft Corp. Nano Transceiver 1.1
Bus 001 Device 002: ID 2109:0813 VIA Labs, Inc. USB2.0 Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```
##### lspci
Используется для вывода списка всех устройств, подключенных к шине PCI (Peripheral Component Interconnect) в вашем компьютере, и информации о них (сетевые интерфейсы, контроллеры Wi-Fi, видеокарты и т.д.)

Пример вывода ```lspci```

```console
00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6/7th Gen Core Processor Host Bridge/DRAM Registers (rev 02)
00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor PCIe Controller (x16) (rev 02)
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 630 (rev 04)
00:04.0 Signal processing controller: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem (rev 02)
```
##### interfaces
Файл ```/etc/network/interfaces``` обычно используется для настройки сетевых интерфейсов в системах на базе Debian и Ubuntu Linux, а также в других дистрибутивах, использующих инструменты настройки сети, основанные на ifupdown
+ ```sudo nano /etc/network/interfaces```
## Файловые системы
+ Каждая файловая система ОС Linux подключена к определённому месту главного «дерева» иерархии файлов и директорий.
+ Действие по подключению файловой системы к надлежащему месту дерева называется монтированием (mounting)
+ Специальное место называется точкой монтирования (точкой подключения, mounting point)
### mount
С помощью команды ```mount``` можно посмотреть, как физические (и виртуальные) устройства подключены к своим точкам монтирования (каждая точка монтирования — это существующая директория):
```console
[st00@c7-sandbox ~]$ mount | egrep -v tmpfs | egrep /dev 
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
/dev/mapper/rootvg-rootlv on / type ext4 (rw,relatime,seclabel,data=ordered)
mqueue on /dev/mqueue type mqueue (rw,relatime,seclabel)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,seclabel)
/dev/sda1 on /boot type ext4 (rw,relatime,seclabel,data=ordered)
/dev/mapper/rootvg-tmplv on /tmp type ext2 (rw,relatime,seclabel)
/dev/mapper/rootvg-homelv on /home type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)
```
**Третье «слово»** каждой строки содержит соответствующую точку подключения, например /, /boot, /tmp, /home. !!! Информацию про точку монтирования можно также получить с помощью команд lsblk и df

#### Пример подготовки и монтирования логического тома
1. **Создание нового раздела `sda4`**:
   - Вам нужно создать новый раздел на диске `sda` с помощью инструментов, таких как `fdisk`, `parted` или `gparted`. Этот новый раздел будет использовать оставшееся свободное пространство на диске или пространство, выделенное для этого раздела.
2. **Инициализация физического тома (PV) для `sda4`**:
   - После создания раздела `sda4` его нужно инициализировать как физический том:
     ```bash
     pvcreate /dev/sda4
     ```
3. **Создание группы томов**:
   ```bash
   vgcreate ubuntu-vg /dev/sda4 /dev/sdb1
   ```

или

3. **Добавление нового PV в существующую группу томов (VG)**:
   - Добавьте новый физический том (`/dev/sda4`) в существующую группу томов (`ubuntu-vg`):
     ```bash
     vgextend ubuntu-vg /dev/sda4
     ```
4. **Объединение логических томов**:
   - Логический том (`root`) теперь будет использовать пространство, предоставляемое обоими физическими томами (`/dev/sda3` и `/dev/sda4`). LVM автоматически управляет пространством внутри группы томов.
5. **Создание логического тома**:
   ```bash
   lvcreate -L 20G -n homelv rootvg
   ```
   Эта команда создает логический том `homelv` размером 20 ГБ в группе томов `rootvg`.
6. **Форматирование логического тома**:
   После создания логического тома его нужно отформатировать в файловую систему, например, `ext4`:
   ```bash
   mkfs.ext4 /dev/rootvg/homelv
   ```
   Это создаст файловую систему `ext4` на логическом томе.
7. **Создание точки монтирования**:
   Создайте директорию, куда вы хотите монтировать логический том. Например:
   ```bash
   mkdir /mnt/homelv
   ```
8. **Монтирование логического тома**:
   Теперь можно монтировать логический том в созданную директорию:
   ```bash
   mount /dev/rootvg/homelv /mnt/homelv
   ```
9. **Настройка автоматического монтирования логического тома при загрузке системы**
Чтобы логический том автоматически монтировался при загрузке системы, добавьте запись в файл `/etc/fstab`. Откройте `/etc/fstab` в текстовом редакторе и добавьте строку:
	```bash
	/dev/rootvg/homelv /mnt/homelv ext4 defaults 0 2
	```
### df
Если в вашей системе закончилось свободное дисковое пространство и получено сообщение «No space left on device», то нужно запустить команду ```df -h [fileName]```. Без ```fileName``` - для всей системы, а с ```fileName``` - для отображения информации о файловой системе, в которой находится указанный файл или директория:
```console
[st00@c7-sandbox ~]$ df -m | egrep -v tmpfs
Filesystem                1M-blocks  Used Available Use% Mounted on
/dev/mapper/rootvg-rootlv     22047  9515     11493  46% /
/dev/sda1                       488   246       207  55% /boot
/dev/mapper/rootvg-tmplv       4032    58      3770   2% /tmp
/dev/mapper/rootvg-homelv     25071  4409     19535  19% /home
```
опции:
+ ```-m``` - для использования мегабайтов (по умолчанию - kB)
+ ```-h``` (для удобного для человека формата вывода)

!!! Информацию про точку монтирования можно также получить с помощью команд lsblk и df
#### inode
Сообщение об ошибке «No space left on device» может быть показано, даже когда в файловой системе ещё много свободного места:
```console
[st00@c7-backend shared]$ touch /mnt/testfs/shared/new.empty.file
touch: cannot touch '/mnt/testfs/shared/new.empty.file': No space left on device

[st00@c7-backend shared]$ df -h /mnt/testfs/shared
Filesystem      Size  Used Avail Use% Mounted on
/dev/loop0       93M  2.5M   84M   3% /mnt/testfs
```
Здесь причина в **inode** (index node) - отдельный дексриптор для каждого файла и директории в файловой системе, в котором хранятся настройки прав доступа, указан владелец-пользователь и группа-владелец и другая служебная информация, называемая метаданными и метаинформацией. Для каждого дескриптора требуется немного дискового пространства, поэтому в файловой системе может быть только ограниченное количество дескрипторов, устанавливаемое в момент создания файловой системы. Когда индексные дескрипторы заканчиваются, в файловой системе уже больше нельзя создавать новые объекты, и поэтому выводится сообщение об ошибке «No space left on device».

```df -i [fileName]``` - отображает дескрипторы inode, вместо дискового пространства. Без ```fileName``` - для всей системы, а с ```fileName``` - для отображения информации о файловой системе, в которой находится указанный файл или директория:
```console
[st00@c7-backend shared]$ df -i /mnt/testfs
Filesystem     Inodes IUsed IFree IUse% Mounted on
/dev/loop0      25688 25688     0  100% /mnt/testfs
```
### du
+ ```du -s -m|-h``` - подсчитывает размер текущей директори
+ ``` du -s dir1 dir2 dirN``` - подсчитывает размер директорий dir1 dir2 dirN

**!!!** Этот инструмент может посчитать размер только тех каталогов, для которых у вас есть права на чтение и выполнение, остальные будут проигнорированы с выводом сообщения об ошибке «Permission denied»
## Архивы и сжатие
### gzip и bzip2
+ ```gzip``` устанавливается везде, ```bzip2``` является опциональным и может отсутствовать.
+ Они могут сжимать и распаковывать ТОЛЬКО отдельные файлы (НЕ каталоги).
+ Они могут читать ввод из ```stdin```, т.е. действовать по принципу ```что-то ... | gzip -9c > /some/where```.
+ Входные файлы удаляются по умолчанию, если не указана опция ```-c```.
+ ```bzip2``` сжимает лучше, чем ```gzip```, но работает дольше.
+ Оба инструмента однопоточны, т.е. могут использовать только одно ядро процессора, а не все сразу.

Наиболее полезные опции gzip и bzip2:
+ -1...-9: степень сжатия от 1 до 9, где 1 - минимальная, 9 - максимальная.
+ ```-d```: распаковать файл. Коэффициент сжатия здесь не требуется.
+ ``-с``: вывести результат на stdout. Входные файлы не удаляются при использовании ```-с```.

Примеры использования gzip и bzip2:
+ ```gzip -9 некий_файл``` -  Сжатие одного файла: ```некий_файл``` удаляется и создаётся файл ```некий_файл.gz```
+ ```gzip -9 *.txt``` - Сжатие всех файлов ```*.txt``` в текущей директории: все входные файлы удаляются, вместо них создаются новые файлы ```*.txt.gz```
+ ```bzip2 -9c некий_файл > некий_файл.bz2``` - Сжатие файла “некий_файл” и вывод результата в stdout. При работе с stdout входные файлы сохраняются
+ ```bzip2 -d некий_файл.bz2``` - Распаковка файла. ```некий_файл.bz2``` удаляется, вместо него создается ```некий_файл```
+ ```gzip -dc некий_файл.gz > некий_файл``` - Распаковка с сохранением исходного файла: входной файл ```некий_файлe.gz``` сохраняется, так как указано ```-c```
+ ```cat *.log | bzip2 -5c > /tmp/compressed-logs.bz2``` - Сжатие данных, поступающих из stdout другой команды: при чтении входных данных из stdin через пайп необходимо указать опцию ```-c``` и перенаправить их вывод в какой-либо файл; в противном случае он будет выведен в терминал (что нежелательно в большинстве ситуаций).
### tar
```tar``` - основной инструмент создания архивов из нескольких файлов: 
+ имея на входе каталог, ``tar`` конкатенирует его содержимое в один файл.
+ ```tar``` может создавать сжатые архивы за один раз, подобно инструменту Windows zip.

Архив UNIX:
+ это "склеенная" пара входных файлов и каталогов, не обязательно сжатая
+ может быть сжат как во время, так и после его создания.
  
Для сжатия архивов могут использоваться внешние инструменты, такие как gzip и bzip2.

Наиболее полезные опции ```tar```
+ ```-с```: создать архив
+ ```-x```: извлечь все объекты
+ ```-t```: вывести список его содержимого
+ ```-f /path/to/file.tar```: имя входного или выходного файла. Опция ```-f``` в команде tar используется для указания имени файла архива. Она указывает tar, где именно находится архив, который нужно создать, распаковать или просмотреть. Если опция ```-f``` используется с ключом ```-c``` (создание архива), то ```/path/to/file.tar``` указывает, куда сохранить созданный архив. Если опция ```-f``` используется с ключом ```-t``` (просмотр содержимого архива) или ```-x``` (извлечение архива), то ```/path/to/file.tar``` указывает путь к файлу архива, который нужно просмотреть или извлечь.
+ ```-z```: сжать архив с помощью ```gzip``` во время создания
+ ```-j```: сжать архив с помощью ```bzip2``` (если установлен) во время создания

Примеры использования tar:
+ ```tar -c -f /путь/к/архиву.tar /некая/директория``` - Создать архив директории ```/некая/директория```
+ ```tar -t -f /путь/к/архиву.tar``` - Отобразить содержимое архива, то есть вывести имена файлов и директорий в стандартный поток вывода stdout
+ ```tar -xf /путь/к/архиву.tar.gz``` - Извлечь содержимое архива в текущую директорию
+ ```tar -xf /путь/к/архиву.tar -C /новое/место``` - Извлечь содержимое архива и поместить в другое место, НЕ в текущую директорию. Содержимое архива будет распаковано и помещено в /новое/место. Это место должно существовать перед выполнением “tar -xf” 
+ ```tar -czf /путь/к/архиву.tar.gz некая_директория``` - Архивировать каталог с помощью gzip
+ ```tar -cjf /путь/к/архиву.tar.bz2 некая_директория``` - Архивировать каталог некий_каталог с помощью bzip2
+ ```tar -cf - /path/to/dir | gzip -9c > my-archive.tar.gz``` - Архивирование директории с помощью gzip с использованием пайпов
+ ```gzip -dc my-archive.tar.gz | tar -xf``` - Распаховка существующего архива с использованием пайпов (или ```tar -xf my-archive.tar.gz -O | gzip -dc > my-archive.tar```)
+ ```tar cf - /path/to/dir | 7z a -si /path/to/file.tar.7z``` - упаковка tar + инструмент сжатия, не поддерживаемый tar внутренне (например, 7z)
## Передача файлов между компьютерами с помощью протокола SCP
Для передачи файлов с (или на) Linux-машин по сети следует использовать протокол SCP (Secure CoPy, или SSH CoPy). Соответствующий инструмент командной строки под названием "scp" поставляется с Linux, macOS и современными версиями Windows (для предыдущих версий Windows необходимо отдельно установить программу WinSCP, а также PuTTY для SSH-соединений), а также многими сетевыми устройствами, такими как Cisco

Полезные факты о SCP:
+ Он работает "поверх" SSH. Чтобы работать с удаленными машинами, необходимо иметь соответствующие учетные данные для входа в систему SSH. Логины и пароли такие же, как и для входа в SSH. (На удаленном хосте должен быть установлен и запущен SSH сервер)
+ SCP позволяет отправлять и получать как файлы, так и директории.

Примеры работы с scp:
+ ```scp некий_файл someone@host:/путь``` - Отправка файла на компьютер с именем ```host``` (можно указать как в виде IP-адреса, так и в виде доменного имени) от имени учётной записи ```someone```
+ ```scp некий_файл someone@host:/путь/другой_файл``` - Отправка файла на компьютер с именем ```host``` от имени ```someone```. Если файл ```/путь/другой_файл``` уже существует, он будет  перезаписан содержимым файла некий_файл. !!!При перезаписи файлов никаких предупреждений не выводится. Для SCP нельзя задать поведение, аналогичное "cp -i"
+ ```scp -r someone@host:/path/to/target_dir ~/``` - копирование всей директории со всем содержимым. Это пример скачивания с использованием SCP. В результате вы получите директорию ```target_dir```, созданную в вашей домашней директории.