# 09 Linux — исполняемые файлы, процессы и службы
## Исполняемые файлы в Linux
### Команды
При выполнении команд в терминале Linux, на самом деле выполняются:

+ Исполняемые файлы - файлы с установленным битом "x":
  + Двоичные исполняемые файлы, например, написанные на C/C++. Примеры: cat, less, grep. Они аналогичны файлам ".exe" в Windows
  + Скрипты, например, скрипты (сценарии) оболочки, Python и т.д. Примеры: egrep, yum (похожи на ".bat" или ".ps" в Windows).
  + Библиотеки - это двоичные файлы, подобные исполняемым файлам, но очень редко запускаемые напрямую.
  + Все вышеперечисленные исполняемые файлы, представленные в виде символических ссылок на "обычные" файлы с установленным битом "x", что широко распространено в UNIX-подобных системах.
+ Псевдонимы (алиасы) - синонимы команды (или другого псевдонима), выполняемой с определенными опциями или без них, например, псевдоним "ll" часто определяет команду "ls -l".
+ Встроенные команды оболочки. Примеры: cd, alias. При их выполнении не вызывается никакая внешняя команда, вместо этого их выполняет сама командная оболочка

Для выполнения команд пользователя и отображения их вывода используются специальные оболочки входа в систему, такие как **bash**, **zsh** и так далее
### Исполняемые файлы
#### PATH
PATH - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов. Она может быть отображена командой "echo":

```console
localhost:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```
#### Переменные оболочки
Вывод списка переменных оболочки осуществляется командой ```env```
#### which
```which``` - это команда для показа расположения исполняемого файла в каталогах PATH:
```console
localhost:~# which uname
/bin/uname
```
+ Любой исполняемый файл можно запустить, указав путь к нему.
+ Исполняемый файл, если он находится в директории в списке PATH, может быть запущен путем указания имени файла; путь к файлу указывать не нужно.
+ Поиск в директориях, перечисленных в PATH, выполняется последовательно. Таким образом, если файлы с одинаковым именем существуют в нескольких каталогах PATH, для выполнения будет взят файл из первой директории в переменной PATH.
+ Чтобы запустить исполняемый файл, не находящийся ни в одной из директорий в PATH, необходимо вместо имени файла указать его путь - относительный или абсолютный.
#### Управление задачами
##### Запуск процесса в фоновом режиме из командной строки:
Запустить процесс в фоновом режиме можно, добавив символ & в конец команды. Это позволяет вашей командной строке быть доступной для ввода новых команд, пока фоновый процесс выполняется ```команда &```, например:
+ gedit &
##### Приостановка задачи
Когда вы выполняете команду в терминале, она обычно работает в переднем плане (foreground). Если вы хотите временно приостановить выполнение этой команды, вы можете использовать сочетание клавиш Ctrl+Z. Это переместит задачу в состояние приостановки (stopped).
##### Перевод задачи в фоновый режим (bg)
```bg %ID_задачи``` - Возобновляет выполнение приостановленной задачи в фоновом режиме. Если не указать ID задачи, будет использована последняя приостановленная задача
##### Возвращение задачи в передний план (fg)
```fg %ID_задачи``` - Возобновляет выполнение задачи в переднем плане. Если не указать ID задачи, будет использована последняя приостановленная или фоновая задача.
##### Завершение задачи (Ctrl+C)
```Ctrl+C```: Прерывает и завершает текущую задачу в переднем плане
##### Просмотр списка задач (jobs)
```jobs``` - Отображает список всех задач в текущем терминале, их статус и ID
##### "Убийство" задачи (kill)
```kill %ID_задачи``` - Отправляет сигнал SIGTERM для завершения указанной задачи. Если задача не завершится, можно использовать сигнал SIGKILL для принудительного завершения
#### Встроенные команды и псевдонимы оболочки
Некоторые команды не являются исполняемыми файлами; вместо этого они выступают в качестве так называемых "псевдонимов" и "встроенных модулей оболочки":
+ "Алиас" (псевдоним) - это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments". Часто система Linux настроена так, что некоторые псевдонимы для всех пользователей доступны сразу же, например, "ll" (ls -l), "la" (ls -a).
+ Встроенная команда - это имя команды, которая поддерживается оболочкой входа в систему (/bin/bash является оболочкой входа в систему в большинстве случаев), но не существует в виде отдельного исполняемого файла. Примеры: ```cd```, ```pwd```, ```test``` - эти команды часто представлены в виде "настоящих" исполняемых файлов, но если это не так, оболочка входа в систему может выполнить соответствующие действия и сама.
##### alias
Команда ```alias``` - это встроенная команда оболочки, которая возвращает просмотр список зарегистрированных в системе псевдонимов (по умолчанию какие-либо псевдонимы могут отсутствовать).

**Создать псевдоним**
+ Определим псевдоним и поместим его в постоянный файл конфигурации оболочки (в файлах ~/.bashrc и(или) ~/.bash_profile)
  + ```localhost:~# echo "alias lf='ls -lF'" >> ~/.bashrc```
+ Чтобы применить обновленную конфигурацию, необходимо запустить новый экземпляр "bash":
  + ```localhost:~# bash```
+ Проверка, что псевдоним добавлен - вызвать команду ```alias```
+ Также псевдонимы можно определять «на ходу». В таком случае они будут действовать до завершения текущего сеанса оболочки
  + ```localhost:~# alias rm='echo You are trying to execute "rm" with the following arguments: '```
  + теперь "оригинальную" команду ```rm``` можно вызвать по абсолютному пути, в таком случае выполнится именно она, а не ее псевдоним: ```/bin/rm -f ~/file.to.remove```
+ после того как псевдоним более не нужен, можно отменить его, вызвав из оболочки встроенную команду unalias (чтобы окончательно удалить псевдоним из файла ~/.bashrc, если он был туда добавлен, то нужно вручную удалить соответствующую строку из файла ~/.bashrc. Если этого не сделать то после новой сессии bash псевдоним будет снова доступен)
  + ```unalias имя_псевдонима```
## Процессы и сигналы
### Процессы и демоны
**Процесс** операционной системы (ОС) — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Если программа заканчивает свою работу, то процесс также прекращает своё существование.

Каждый процесс имеет несколько следующих основных атрибутов:
+ ```PID``` - идентификатор процесса. Уникален для каждого выполняющегося процесса. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми ```PID```.
+ ```PPID``` — родительский идентификатор (```PID```). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, ```PPID``` - это ```PID``` родительского процесса. «Главный» системный процесс называется **init** или **systemd** и обладает ```PID``` = 1, ```PPID``` = 0. Он создаётся ядром операционной системы при её загрузке.
+ Пользователь и группа, запустившие программу.
+ Название.
+ Аргументы командной строки.
+ Управляющий терминал. Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме. Например, командный интерпретатор **bash**, который обычно запускается при входе пользователя в систему, определённо взаимодействует с терминалом и пользователями, и поэтому у него есть управляющий терминал. *Командная оболочка выполняет команды пользователей, поэтому логично предположить, что она (например, bash) является родительским процессом всех процессов, запущенных с помощью командной строки*

**Демоны** — это особый вид процессов, работающих в фоновом режиме и не взаимодействующий с пользователями посредством терминала. Например, процессы сетевых серверных приложений, отвечающие за обработку входящих запросов по сети, обычно являются демонами.
+ «Настоящий» процесс-демон обладает следующими свойствами:
  + PPID = 1
  + Управляющий терминал отсутствует
  + В большинстве случаев текущей рабочей директорией демона является "/".
### Как искать процессы и просматривать их списки
Ниже привдоятся некоторые из инструментов и способов получения информации обо всех или конкретных запущенных процессах:
+ ps — основной инструмент для отображения списка запущенных процессов
+ top - инструмент для отслеживания запущенных процессов в реальном времени, аналог диспетчера задач Windows и мониторинга системы macOS
+ pgrep - инструмент для поиска процессов по их названию или аргументам
+ pstree - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений
+ В псевдо-каталоге /proc/PID содержится много подробных сведений о процессе с идентификатором PID. Очень полезен в некоторых случаях
#### Команда ps
Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. Самые полезные ее опции следующие:
+ -e для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.
+ -f для вывода расширенных сведений о каждом процессе. По умолчанию отображается только ограниченный объём информации.
+ -u username для отображения процессов, запущенных пользователем c данным именем (username).
+ -p PID - для вывода сведений об процессе с данным PID
+ -o поле1, поле2,... - для вывода определённых сведений о процессах (см. подробное руководство с помощью команды man ps)
+ --forest служит для отображения процессов в виде дерева (аналогично команде pstree). Отображает родительские процессы и их дочерние процессы, наглядно показывая связи между ними.

```ps -ef``` вернет следующий набор полей:
+ ```UID```: имя пользователя, запустившего процесс
+ ```PID```: идентификатор процесса
+ ```PPID```: идентификатор родительского процесса
+ ```STIME```: время запуска процесса
+ ```TTY``` или ```TT```: управляющий терминал. Знак «?» показывается для процессов, не связанных с терминалом (таких как демоны)
+ ```TIME```: суммарное процессорное время выполнения
+ ```CMD```: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если название процесса показано в квадратных скобках, значит, этот процесс является частью ядра ОС.
#### Команда pgrep
Помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep". Ниже приведены ее основные параметры:
+ -f: для поиска в полной командной строке (т.е. как имена команд, так и аргументы). По умолчанию проверяются только имена команд
+ -a: для вывода списка всей командной строки, а не только PID
#### Псевдо-директория /proc
+ ```/proc``` - виртуальная файловая система, содержащая множество сведений о работающих процессах. В реальности на диске нет файлов, расположенных в директории ```/proc```. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории ```/proc```.
+ Все команды, относящиеся к процессам, такие как ps, pstree, pgrep, берут информацию из директории /proc.
+ Можно получить информацию о ваших процессах напрямую из директории /proc

Порой бывает полезно заглянуть в директорию /proc напрямую:
+ Чтобы определить точный путь к исполняемому файлу конкретного процесса, который обычно не отображается в выводе команды ps.
+ Чтобы выяснить текущую рабочую директорию конкретного процесса.

Поскольку /proc представляется как обычная директория, к ней применимы почти все известные команды, предназначенные для работы с директориями. Например, ```ls``` для вывода списка содержимого, ```egrep -r``` для рекурсивного поиска последовательности символов и т.д.
#### Отслеживание процессов и команда top
Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу (похожа на диспетчер задач Windows)

Команда top полезна для:
+ Поиска процессов, которые больше других потребляют ресурсы процессора и памяти.
+ Определение текущей загрузки системы.
### Сигналы
**Сигнал** — это короткое сообщение, которое можно отправить процессу
+ ```kill [-ЧТО] PID``` - отправляет сигнал ЧТО (например, ```TERM```, ```KILL```, ```STOP``` и т. д.) процессу с идентификатором PID
  + ```kill -KILL PID``` или ```kill -9 PID```
+ ```killall [-ЧТО] [другие опции] название_процесса``` - отправляет один и тот же сигнал нескольким процессам с одинаковым названием, более подробно синтксис функции:
  + ```killall [-Z, --context шаблон] [-e, --exact] [-g, --process-group] [-i, --interactive] [-n, --ns PID] [-o, --older-than ВРЕМЯ] [-q, --quiet] [-r, --regexp] [-s, --signal СИГНАЛ, -СИГНАЛ] [-u, --user пользователь] [-v, --verbose] [-w, --wait] [-y, --younger-than ВРЕМЯ] [-I, --ignore-case] [-V, --version] [--] название_процесса … :```
    + ```-e, --exact``` - Требовать полного совпадения для очень длинных имён. Если имя команды длиннее чем 15 символов, то полное имя может быть недоступно (т. е., часть затёрлась). В этом случае, killall завершит все процессы, совпадающие по первым 15 символам. С параметром -e такие элементы не обрабатываются. killall выводит сообщение для каждого необработанного элемента, если вместе с -e дополнительно указан параметр -v.
    + ```-I, --ignore-case``` - Игнорировать регистр символов в именах процессов.
    + ```-g, --process-group``` - Завершить группу процесса, в которую входит процесс. На всю группу посылается только один сигнал завершения, даже если в группе найдено несколько процессов.
    + ```-i, --interactive``` - Запрашивать подтверждение перед завершением процессов.
    + ```-l, --list``` - Показать все известные имена сигналов.
    + ```-n, --ns``` - Искать процессы в том же пространстве имён PID что и у PID. По умолчанию поиск выполняется по всем пространствам имён.
    + ```-o, --older-than``` - Искать процессы, старее (запущенные до) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + ```-q, --quiet``` - Не сообщать, если ни одного процесса не завершено.
    + ```-r, --regexp``` - Рассматривать шаблон имени процесса как расширенное регулярное выражение POSIX согласно regex(3).
    + ```-s, --signal```, -СИГНАЛ - Посылать указанный СИГНАЛ, а не SIGTERM.
    + ```-u, --user``` - Завершить процессы, принадлежащие указанному пользователю. Имена команд необязательны.
    + ```-v, --verbose``` - Уведомлять об успешной отправке сигнала.
    + ```-V, --version``` - Показать информацию о версии.
    + ```-w, --wait``` - Ожидать завершения процессов. killall проверяет раз в секунду существование завершаемых процессов и прекращает работу только если никого не осталось.Заметим, что killall может ждать вечно, если сигнал был проигнорирован, никак не повлиял или если процесс остался в состоянии зомби.
    + ```-y, --younger-than``` - Искать процессы, новее (запущенные после) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + ```-Z, --context``` - Задать контекст безопасности: завершать только процессы с контекстом безопасности, который совпадает с заданным шаблоном расширенного регулярного выражения. В командной строке должен указываться раньше остальных параметров. Имена команд необязательны.
 + ```pkill [-ЧТО][другие опции] название_процесса``` - отправляет один и тот же сигнал нескольким процессам, названия которых отвечают некоторым условиям. Похожа на команду ```pgrep```. , более подробно синтксис функции:
   + ```pkill [-signal] [-fvx] [-n|-o] [-P ppid,...] [-g pgrp,...][-s sid,...] [-u euid,...] [-U uid,...] [-G gid,...][-t term,...] [pattern]```
     + ```-f``` - Обычно шаблон сопоставляется только с именем процесса. Если задано значение -f, используется полная командная строка
     + ```-g pgrp,...``` - Искать процессы только в перечисленных идентификаторах групп процессов. Группа процессов 0 переводится в собственную группу процессов pgrep или pkill.
     + ```-G gid,...``` - Искать только те процессы, реальный идентификатор группы которых указан в списке. Может использоваться как числовое, так и символическое значение.
     + ```-n``` - Выберите только самый новый (недавно запущенный) из совпадающих процессов.
     + ```-o``` - Выберите только самый старый (запущенный совсем недавно) из соответствующих процессов.
     + ```-P ppid,...``` - Совпадают только те процессы, идентификатор родительского процесса которых указан в списке.
     + ```-s sid,...``` - Искать только те процессы, идентификатор сеанса которых указан в списке. Идентификатор сеанса 0 транслируется в собственный идентификатор сеанса pgrep или pkill.
     + ```-t term,...``` - Искать только те процессы, управляющий терминал которых указан в списке. Имя терминала должно быть указано без префикса "/dev/".
     + ```-u euid,...``` - Искать только те процессы, чей эффективный идентификатор пользователя указан в списке. Может использоваться как числовое, так и символическое значение.
     + ```-U uid,...``` - Искать только те процессы, в списке которых указан реальный идентификатор пользователя. Может использоваться как числовое, так и символическое значение.
     + ```-v``` - Искать обратное соответствию.
     + ```-x``` - Искать только те процессы, имя которых (или командная строка, если указано -f) точно соответствует шаблону.
     + ```-signal``` - Определяет сигнал, посылаемый каждому сопоставленному процессу. Можно использовать как числовое, так и символическое имя сигнала.
#### Полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:
+ ```TERM (15)```, terminate — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
+ ```KILL (9)```, ```kill``` — уничтожить: безусловное завершение работы процесса, не может быть проигнорирован процессом
+ ```INT (2)```, ```interrupt``` — прервать посредством терминала: отправляется, когда пользователь нажимает клавиши ```Ctrl+C```. По умолчанию ```SIGINT``` завершает процесс, но процесс может перехватить сигнал и выполнить какую-либо очистку, альтернативное действие перед завершением или проигнорировать
+ ```TSTP (20)```, ```terminal (TTY) stop``` — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши ```Ctrl+Z```. Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.
+ ```STOP (19)```, ```stop``` — приостанавливает работу процесса аналогично ```TSTP```, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал ```KILL```, не может быть проигноирован процессом.
+ ```CONT (18)```, continue — продолжить: отправляется, когда пользователь выполняет команду ```fg``` или ```bg``` с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала ```STOP```, можно возобновить сигналом ```CONT```.
## Службы (services) Linux
 Не составляет труда запустить какой-либо исполняемый файл вручную. После запуска процесса его также можно приостановить, возобновить и принудительно завершить. Но это неудобно для управления сложными приложениями, требующими выполнения множества файлов, добавления этих приложений в список автозапуска ОС, поиска их запущенных процессов и их остановки.
 
 **Служба Linux** - "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС. **Служба Linux**, построенна вокруг программы и отвечает на вопрос "КАК именно следует управлять этой программой":
+ Должна ли она запускаться во время загрузки системы?
+ Как запустить ее вручную при необходимости?
+ Какие опции предоставляются программе при запуске?
+ Как отслеживать ее состояние?
+ Как аккуратно завершить ее работу?
+ Нужно ли перезапускать ее в случае нештатного завершения?
+ Какие другие службы должны быть запущены перед запуском этой конкретной?
### Структура Unit-файла сервиса
```console
[Unit]
Description=Краткое описание сервиса
Documentation=URL-документации
Requires=другие_юниты_требуемые_для_запуска
Wants=другие_юниты_желательные_для_запуска
After=юниты_которые_должны_запуститься_перед_этим
Before=юниты_которые_должны_запуститься_после_этого
Conflicts=юниты_которые_конфликтуют_с_этим
ConditionPathExists=/путь/к/файлу (условие для запуска)

[Service]
Type=simple (или другие типы: forking, oneshot, dbus, notify, idle)
ExecStart=/путь/к/исполняемому_файлу (основная команда для запуска сервиса)
ExecStartPre=/путь/к/исполняемому_файлу_предварительно (команда, выполняемая перед запуском основного процесса)
ExecStartPost=/путь/к/исполняемому_файлу_после (команда, выполняемая после запуска основного процесса)
ExecStop=/путь/к/исполняемому_файлу_для_остановки (команда для остановки сервиса)
ExecReload=/путь/к/исполняемому_файлу_для_перезагрузки (команда для перезагрузки сервиса)
Restart=always (политика перезапуска: no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, или always)
RestartSec=5 (время ожидания перед перезапуском)
User=имя_пользователя (пользователь, от имени которого запускается сервис)
Group=имя_группы (группа, от имени которой запускается сервис)
WorkingDirectory=/путь/к/рабочему_каталогу (рабочий каталог для процесса)

[Install]
WantedBy=multi-user.target (указывает таргеты, в которые включен этот юнит)
RequiredBy= (другие юниты, которые зависят от этого юнита)
Also= (другие юниты, которые должны быть включены вместе с этим)
Alias= (другие имена для этого юнита)
```

### Systemd
+ Systemd — это комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами (принята как замена системы инициализации SysV init).
+ Systemd оперирует следующими объектами, называемыми "юнитами":
  + Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
  + Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
  + сокеты, таймеры и др.
### Службы в контексте systemd
+ Службы, добавленные к systemd вместе с их настройками (известными также как **юнит-файлы**), находятся в директории ```/etc/systemd/system``` и ее вложенных директориях. Обычно **юнит-файлы представляют собой символьные ссылки** на «настоящие» файлы, расположенные в директории ```/usr/lib/systemd/system```.
#### Вывод списка активных служб (units) на системе, управляемых systemd
```systemctl list-units --type=service``` показывает только те службы, которые в данный момент активны (запущены или в других состояниях активности)
```console
$ systemctl list-units --type=service
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
apparmor.service                    loaded active exited  Load AppArmor profiles
...
```
где 
+ ```UNIT```: Название службы.
+ ```LOAD```: показывает статус загрузки конфигурационного файла сервиса. Возможные значения:
  + ```loaded```: Конфигурационный файл сервиса загружен и разобран успешно.
  + ```not-found```: Конфигурационный файл сервиса не найден.
  + ```error```: Произошла ошибка при загрузке конфигурационного файла.
  + ```masked```: Сервис замаскирован, что предотвращает его случайный запуск
+ ```ACTIVE```: показывает общий статус активности сервиса. Возможные значения:
  + ```active```: Сервис запущен и работает нормально.
  + ```reloading```: Сервис в процессе перезагрузки конфигурации.
  + ```inactive```: Сервис не запущен.
  + ```failed```: Сервис завершился с ошибкой.
  + ```activating```: Сервис находится в процессе запуска.
  + ```deactivating```: Сервис находится в процессе остановки.
+ ```SUB```: показывает более детальную информацию о состоянии сервиса, дополняя статус в столбце ACTIVE. Возможные значения различаются в зависимости от типа сервиса, но некоторые примеры включают:
  + ```running```: Сервис запущен и работает (соответствует active в ACTIVE).
  + ```exited```: Сервис завершил работу (может быть нормальное завершение, соответствует inactive в ACTIVE).
  + ```dead```: Сервис не работает и не запускается (соответствует inactive в ACTIVE).
  + ```auto```-restart: Сервис настроен на автоматический перезапуск (обычно временный статус).
  + ```failed```: Сервис завершился с ошибкой (соответствует failed в ACTIVE).
+ ```DESCRIPTION```: Описание службы.
#### Вывод списка активных служб (units) на системе, которые находятся в состоянии "running"
```console
$ systemctl list-units --type=service --state=running
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
avahi-daemon.service                loaded active running Avahi mDNS/DNS-SD Stack
...
```
#### Вывод всех файлов units (сервисов) вместе с их состоянием включения
```systemctl list-unit-files``` отображает все доступные на системе файлы unit (сервисы), вне зависимости от их текущего состояния активности
```console
$ systemctl list-unit-files --type=service
UNIT FILE                                   STATE   
accounts-daemon.service                     enabled 
apparmor.service                            enabled 
apt-daily-upgrade.service                   enabled 
dbus-org.bluez.service                      alias   
dbus.service                                static  
debug-shell.service                         disabled
grub-common.service                         masked  
...
```
##### Состояния служб
+ ```enabled```: Служба настроена на автоматический запуск при загрузке системы.
+ ```disabled```: Служба не настроена на автоматический запуск при загрузке системы.
+ ```static```: в unit-файле службы отсутствует секция [Install], что делает их неспособными к автоматическому запуску. Они могут быть запущены вручную или как зависимости других служб.
+ ```masked```: Служба замаскирована это значит, что она заблокирована для запуска и не может быть запущена ни вручную, ни автоматически, пока не будет размаскирована. Замаскированная служба фактически отключена и недоступна для выполнения. systemctl mask|unmask example.service
+ ```alias```: Служба является псевдонимом другой службы.

Чтобы увидеть только включенные службы, выполните:
```systemctl list-unit-files --type=service --state=enabled``` - вернёт список всех unit-файлов для сервисов (.service), которые включены (enabled) в системе. Включенные сервисы автоматически запускаются при загрузке системы или при активации соответствующего таргета.
#### Проверка текущего состояния службы (по названию)
```systemctl status название_службы```
#### Проверка текущего состояния службы (по процессу)
```systemctl status PID_процесса```
#### Запуск/остановка/перезапуск службы
```console
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
Для выполнения необходимы права root
#### Включение и отключение автоматического запуска службы на этапе загрузки ОС
```systemctl enable|disable [--now] название_службы``` - включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы).

Для выполнения необходимы права root
#### Узнать настройки автоматического запуска конкретной службы
```systemctl is-enabled название_службы```
## Отличие сервисов (служб) от приложений
| | Серверные приложения | Службы systemd |
|-------------|-------------|-------------|
| Основное назначение    | Обработка запросов пользователей и выполнение действий в рамках прикладной логики (например, сервер MySQL сохраняет данные и обрабатывает запросы на языке SQL)    | Упрощение управления приложениями (запуск, останов, перезапуск, проверка состояния и т. д.)    |
| Управление приложениями    | Для каждого серверного приложения (если он запущено само по себе, а не как служба) предусмотрен свой способ управления. Даже простые операции (проверка, запуск, перезапуск, останов) разных приложений имеют свои особенности    |Приложения, "обернутые" в сервис, управляются одним и тем же способом — посредством команды systemctl и её опций.    |
| Конфигурация | Хранится в файле конфигурации, специфичном для приложения (например, /etc/my.cnf). Содержит главные параметры приложения, такие как прослушиваемые порты, степень подробности журналирования, настройки проверки подлинности пользователей и многие другие | Хранится в юнит-файлах с общим форматом (например, /usr/lib/systemd/system/mysqld.service). Содержит условия запуска, требуемые права пользователя, внешние зависимости от других служб, действия при запуске и останове, путь к исполняемому файлу и аргументы. Не описывает конфигурацию самого приложения! |
| Журналирование (логирование)    | Полностью зависит от конкретного приложения. Настройки журналирования (например, степень подробности и формат) очень гибкие и задаются в файле(ах) конфигурации приложений. Журналы чаще всего представляют собой текстовые файлы (например, /var/log/mysqld.log)    | Файлы журналов служб systemd: обычно содержат меньше информации по сравнению с файлами журналов приложений (записываются только основные события); хранятся в едином двоичном формате; доступ к ним можно получить с помощью команды journalctl    |
## Юнит-файлы сервисов по сравнению с файлами конфигурации приложений
|  | Файл конфигурации приложения java-auth | Юнит-файл сервиса java-auth.st00 |
|-------------|-------------|-------------|
| Местоположение файлов конфигурации    | Полностью зависит от самого приложения. В нашем примере далее показан файл /apps/java/auth/st00/application.properties. Конфигурации основных серверных приложений (например, SSH server) часто содержатся в директории/etc    | Обычно где-то в директории /usr/lib/systemd/system (сами конфигурации) и (или) /etc/systemd/system (обычно символьные ссылки на файлы конфигурации). Показанный далее юнит-файл взят из /etc/systemd/system/multi-user.target.wants/java-auth.st00.service    |
| Основное назначение    | Содержит специфичные для приложения настройки, такие как используемые сервером порты, адрес и тип базы данных для подключения, учётная запись и пароль базы данных. Формат файла и набор параметров полностью зависит от каждого приложения. В нашем примере используется очень простое учебное приложение. Реальное серверное приложение может предусматривать огромные файлы конфигурации с тысячами строк.    | Содержит стартовые условия запуска, требуемые права пользователя (см. переменные User и Group далее), внешние зависимости от других служб (см. After), действия при запуске и останове (см. ExecStop), путь к исполняемому файлу (см. ExecStart) и аргументы. Не описывает конфигурацию самого приложения! Формат един для всех служб системы.    |
| Содержимое файла    | server.port=7000<br> debug=false<br> spring.jpa.hibernate.ddl-auto=updates<br> spring.datasource. url=jdbc:mysql://192.168.40.150:3306/auth_st00<br> spring.datasource.username=dbst00<br> spring.datasource.password=your_password_here    | [Unit]<br>Description=Java auth service for Roles app, per user<br> After=network.target<br><br>[Service]<br>SuccessExitStatus=143<br> User=st00<br> Group=qa<br> Type=simple<br> ExecStart=/apps/java/auth/st00/java-start-auth.sh<br> ExecStop=/bin/kill -15 $MAINPID<br> TimeoutSec=60<br><br>[Install]<br> WantedBy=multi-user.target    |
## Journalctl: вывод журналов служб systemd
```journalctl``` — это инструмент для управления журналами служб systemd. 

Для выполнения этой команды необходимы права ```root``` или включение в группу ```systemd-journal```.

### Просмотр всех записанных в журнал событий для службы (по имени)
```journalctl -u service_name``` (```journalctl  -e -u service_name``` - то же, но с переходом к последним строкам журнала)
### Отслеживание событий службы в реальном времени и вывод их на терминал
```journalctl -f -u service_name``` - наподобие команды ```tail -f``` 
### Просмотр событий от нескольких служб одновременно
```journalctl -u service_name_1 -u service_name_2 ...``` - Эту функцию можно сочетать с другими опциями, например -f