# 16 HTTP, REST, API — инструменты и тестирование
## REST
REST (REpresentational State Transfer) - архитектурный стиль программного обеспечения, определяющий набор правил/ограничений/рекомендаций, которым необходимо следовать при разработке веб-приложений (в основном веб-сервисов/API).

*Приложения, разработанные в соответствии с правилами/ограничениями/рекомендациями REST, называют "RESTful".*

### Ресурсы
В REST архитектуре основная концепция — это "ресурс". Ресурс — это любая информация или объект, который можно идентифицировать и к которому можно получить доступ через уникальный URL. В контексте веб-приложений, например, социальные сети, ресурсами могут быть профили пользователей, посты, комментарии и другие элементы.
#### Примеры ресурсов в REST
1. Профиль пользователя: Может быть представлен как ресурс с URL /users/{user_id}.
2. Пост: Может быть представлен как ресурс с URL /posts/{post_id}.
3. Комментарий: Может быть представлен как ресурс с URL /comments/{comment_id}.
#### Операции с ресурсами
В REST архитектуре для взаимодействия с ресурсами используются стандартные HTTP-методы:
+ GET: Получить представление ресурса (например, получить данные профиля пользователя).
+ POST: Создать новый ресурс (например, создать новый пост).
+ PUT: Полностью обновить существующий ресурс (например, обновить информацию о профиле пользователя), является идемпотентным (выполнение одного и того же запроса PUT несколько раз приводит к одному и тому же результату)
+ PATCH: Частичное обновление ресурса. PATCH не обязательно является идемпотентным
+ DELETE: Удалить ресурс (например, удалить комментарий).
#### Тестирование ресурсов
Подобно тому, как детали автомобиля (двигатель, тормоза, шины и т.д.) проверяются отдельно и в совокупности, чтобы убедиться, что автомобиль работает правильно, ресурсы в RESTful API также должны быть тщательно протестированы:
+ отдельные детали (ресурсы): Каждая деталь проверяется на соответствие ожиданиям и стандартам (например, проверка профиля пользователя, поста или комментария).
+ система в целом: Все детали (ресурсы) работают вместе, корректно взаимодействуют, состояния, переходы, обработка ошибка в системе соответствуют ожиданиям (например, проверка того, что пользователь может создавать посты и комментарии, и они правильно отображаются на его профиле).
#### Примеры тестирования
1. Тестирование отдельных ресурсов: Каждый ресурс нужно тестировать отдельно, чтобы убедиться, что он правильно создается, обновляется, удаляется и возвращает корректные данные.
   1. Тестирование профиля пользователя:
      1. Создание нового профиля.
      2. Получение профиля по ID.
      3. Обновление профиля.
      4. Удаление профиля.
   2. Тестирование постов:
      1. Создание нового поста.
      2. Получение поста по ID.
      3. Обновление поста.
      4. Удаление поста.
   3. Тестирование комментариев:
      1. Создание нового комментария.
      2. Получение комментария по ID.
      3. Обновление комментария.
      4. Удаление комментария.
2. Тестирование взаимодействий: Нужно проверять, как ресурсы взаимодействуют друг с другом. Например, когда создается новый комментарий, он должен быть правильно связан с соответствующим постом.
   1. Создание комментария для поста:
      1. Создать новый пост.
      2. Создать комментарий к этому посту.
      3. Убедиться, что комментарий правильно связан с постом и отображается при запросе комментариев для этого поста.
   2. Получение всех постов пользователя:
      1. Создать пользователя.
      2. Создать несколько постов от имени этого пользователя.
      3. Запросить список всех постов этого пользователя и убедиться, что они все правильно возвращаются.
3. Тестирование состояния и переходов: Проверка, что ресурсы правильно изменяют свое состояние в ответ на различные операции. Например, после удаления комментария он больше не должен быть доступен через API.
   1. Публикация и архивирование поста:
      1. Создать новый пост.
      2. Изменить статус поста на "опубликован" и убедиться, что он виден в списке опубликованных постов.
      3. Изменить статус поста на "архивирован" и убедиться, что он больше не виден в списке опубликованных постов, но доступен через запрос по ID.
4. Тестирование ошибок и исключений: Убедиться, что система корректно обрабатывает ошибки, такие как попытка доступа к несуществующему ресурсу или нарушение правил валидации.
   1. Попытка получения несуществующего ресурса:
      1. Запросить профиль пользователя по несуществующему ID и убедиться, что сервер возвращает ошибку 404 (Not Found).
   2. Создание ресурса с некорректными данными:
      1. Попытаться создать нового пользователя без обязательных полей (например, без email) и убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
   3. Удаление ресурса, который связан с другими ресурсами:
      1. Создать пост с несколькими комментариями.
      2. Попытаться удалить этот пост и убедиться, что система либо удаляет все связанные комментарии (если такая логика предусмотрена), либо возвращает ошибку, указывая на наличие зависимых ресурсов.
### Форматы данных
RESTful API используют стандартные форматы данных для передачи информации между клиентом и сервером. Наиболее часто используемый формат — JSON, но также могут использоваться и другие форматы, такие как XML, YAML и т. д. Формат данных определяет структуру передаваемой информации, чтобы обе стороны знали, как правильно ее интерпретировать.
#### Тестирование форматов данных
Тестирование форматов данных включает проверку следующих аспектов:
1. Соответствие структуры данных ожидаемому формату:
   1. Убедиться, что данные содержат все необходимые поля.
   2. Убедиться, что поля имеют правильные типы данных (строки, числа, URL и т. д.).
2. Обработка различных форматов данных:
   1. Убедиться, что сервер правильно обрабатывает запросы и ответы в различных форматах данных (например, JSON и XML).
#### Примеры тестов для проверки форматов данных
1. Тестирование структуры данных:
   1. Создание пользователя:
      1. Отправить запрос на создание нового пользователя с корректным JSON-форматом.
      2. Убедиться, что ответ содержит все необходимые поля и правильные типы данных.
		```json
		{
		"name": "Alice",
		"email": "alice@example.com",
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
      3. Проверить ответ сервера:
		```json
		{
		"id": 124,
		"name": "Alice",
		"email": "alice@example.com",
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
   2. Получение профиля пользователя:
      1. Отправить запрос на получение профиля пользователя по ID.
      2. Убедиться, что ответ содержит все необходимые поля и правильные типы данных.
		```json
		{
		"id": 123,
		"name": "John Doe",
		"email": "john.doe@example.com",
		"profile_picture": "https://example.com/profiles/johndoe.jpg"
		}
		```
2. Тестирование обработки различных форматов данных:
   1. Отправка запроса в формате JSON:
      1. Отправить запрос на создание нового пользователя в формате JSON.
      2. Убедиться, что сервер правильно обрабатывает запрос и возвращает корректный ответ.
   2. Отправка запроса в формате XML:
      1. Отправить запрос на создание нового пользователя в формате XML.
      2. Убедиться, что сервер правильно обрабатывает запрос и возвращает корректный ответ.
		```json
		<user>
		<name>Alice</name>
		<email>alice@example.com</email>
		<profile_picture>https://example.com/profiles/alice.jpg</profile_picture>
		</user>
		```
      3. Проверить ответ сервера:
		```json
		<user>
		<id>124</id>
		<name>Alice</name>
		<email>alice@example.com</email>
		<profile_picture>https://example.com/profiles/alice.jpg</profile_picture>
		</user>
		```
3. Тестирование ошибок в формате данных:
   1. Отправка некорректного JSON:
      1. Отправить запрос с некорректным JSON (например, отсутствует запятая или кавычка).
      2. Убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
		```json
		{
		"name": "Alice"
		"email": "alice@example.com"
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
   2. Отправка запроса с неправильным типом данных:
      1. Отправить запрос, где поле email содержит число вместо строки.
      2. Убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
```json
		{
		"name": "Alice",
		"email": 12345,
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
```
## Инструменты работы с API
### curl 
[cURL](12%20Сетевые%20уровни%20и%20протокол%20IP.md#curl) можно использовать для тестирования REST-методов.
### [OpenAPI](15%20HTTP,%20URL,%20JSON,%20API.md#openapi) 
### [Swagger](15%20HTTP,%20URL,%20JSON,%20API.md#swagger) 
Главное удобство этого инструмента заключается в том, что разработчик или тестировщик может выполнить любой описанный метод.

Пример: 
+ https://catfact.ninja/
+ https://petstore.swagger.io/
### Boomerang (Chrome)
Плагин позволяет тестировщику применять разные методы HTTP, указывать URL назначения, определять заголовки запросов, содержимое тела и т. д. Также есть возможность импортировать запросы из файла и сохранять запросы для дальнейшего использования

Его аналог в Firefox - RESTED
### Postman
+ Postman — это инструмент для разработки и тестирования API (интерфейсов прикладного программирования). Позволяет создавать, тестировать и документировать API, а также автоматизировать тестирование и мониторинг.
+ Postman предоставляет удобный интерфейс для создания коллекций запросов, добавления тестов, управления окружениями и выполнения запросов к API. 
+ Postman позволяет импортировать спецификации API, такие как OpenAPI, и генерировать коллекции запросов на их основе.
+ Postman поддерживает интеграцию с инструментами CI/CD, такими как Jenkins и Newman.
+ Postman поддерживает как [веб-версия](https://web.postman.co/), так и версия для [десктопов](https://www.postman.com/downloads/).
#### Простые действия Postman
+ отправлять запросы;
+ сохранять запросы для последующего использования;
+ организовывать запросы в коллекции;
+ сохранять ответы в качестве примеров;
+ импортировать/экспортировать запросы или коллекции;
**+ создавать коллекции запросов путем импорта документации в формате OpenAPI (Swagger), RAML, WSDL или других форматов;**
+ использовать различные виды серверной аутентификации;
+ проводить некоторую автоматизацию тестирования.
#### Работа с коллекциями Postman
Основная идея - пакетная (совместная) обработка всех методов:
+ импорт и экспорт их в один файл
+ обмен коллекциями с коллегами
+ документирование API
+ автоматизация работы Postman
+ форк коллекции (т.е. отделение версии).
#### Postman: Переменные
Переменные в коллекциях Postman используются для упрощения и улучшения управления запросами и их параметрами. Они помогают сделать API-запросы более гибкими, повторяемыми и легко изменяемыми. Вот основные назначения и преимущества использования переменных в коллекциях:
##### Основные назначения переменных
1. Динамическое управление параметрами запросов
Переменные позволяют динамически изменять параметры запросов, такие как URL, заголовки, параметры пути, параметры строки запроса и тело запроса. Это делает запросы более гибкими и уменьшает количество дублирующегося кода. ```GET {{base_url}}/api/v1/pets``` - В данном примере {{base_url}} является переменной, которую можно легко изменить для переключения между разными окружениями (например, разработка, тестирование, продакшн).
2. Управление окружениями
Использование переменных коллекций в сочетании с переменными окружения позволяет легко переключаться между различными окружениями, не изменяя сами запросы. Например, вы можете создать разные окружения для разработки, тестирования и продакшн, каждое из которых имеет свои значения переменных.
3. Безопасное хранение чувствительных данных
Переменные могут использоваться для безопасного хранения и использования конфиденциальной информации, такой как ключи API, токены доступа и пароли. Эти данные можно хранить в переменных окружения, что позволяет избежать их жесткого кодирования в запросах. ```Authorization: Bearer {{api_token}}```
4. Автоматизация тестов
Переменные могут использоваться для хранения значений, полученных из ответов предыдущих запросов, что позволяет создавать сложные сценарии тестирования и автоматизировать их выполнение. ```pm.environment.set("user_id", pm.response.json().id);```
5. Переменные для тела запроса
В теле запросов можно использовать переменные для параметров, значения которых могут изменяться.
```json
{
    "name": "{{pet_name}}",
    "status": "{{pet_status}}"
}
```
##### Типы переменных в Postman
1. Глобальные переменные (Global Variables):
Доступны во всех коллекциях и запросах.
2. Переменные окружения (Environment Variables):
Доступны только в определенном окружении. Полезны для переключения между различными настройками окружений (например, разработка, тестирование).
3. Переменные коллекции (Collection Variables):
Доступны только в рамках определенной коллекции. Полезны для значений, которые используются во всей коллекции, но не зависят от окружения.
4. Переменные запроса (Local Variables):
Доступны только в рамках одного запроса или его тестов. Они временные и существуют только в течение выполнения одного запроса.
##### Порядок выбора Postman значений переменных
Postman использует определенный порядок разрешения переменных переменных, когда встречает конструкцию вида ```{{variable_name}}```:
1. Local Variables (Локальные переменные):
Локальные переменные задаются и используются внутри одного запроса или его тестов. Они имеют наивысший приоритет и существуют только в течение выполнения одного запроса. 
```javascript
pm.variables.set("variable_name", "value");
```
2. Data Variables (Переменные данных):
Переменные данных предоставляются при запуске коллекции с использованием Collection Runner или Newman. Эти переменные задаются в CSV или JSON файлах, используемых для параметризации тестов.
3. Collection Variables (Переменные коллекции):
Переменные коллекции доступны во всех запросах, входящих в данную коллекцию. Они используются для значений, которые применяются во всей коллекции.
```javascript
pm.collectionVariables.set("variable_name", "value");
```
4. Environment Variables (Переменные окружения):
Переменные окружения задаются для определенного окружения (например, разработка, тестирование, продакшн). Они позволяют изменять значения переменных в зависимости от выбранного окружения.
```javascript
pm.environment.set("variable_name", "value");
```
5. Global Variables (Глобальные переменные):
Глобальные переменные доступны во всех коллекциях и запросах в Postman. Они имеют наименьший приоритет и используются, если переменная не найдена в других контекстах.
```javascript
pm.globals.set("variable_name", "value");
```
##### Postman: Автоматизация
+ В Postman можно настраивать выполняющиеся скрипты и **автоматически проверять ответы методов**. 
+ Существуют специальные шаблоны, называемые сниппетами, позволяющие использовать заранее написанный код для часто повторяющихся операций и проверок. 

Пример теста для проверки того, что код ответа https://petstore.swagger.io/v2/pet/{id} равен 200:
```javascript
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});
```
## Тестирование REST API - POST, PUT, GET, DELETE
### Цель тестирования REST API
Цель тестирования REST API - выявление ошибок неправильной реализации методов API:
1. Нарушенная авторизация или аутентификация
2. Неправильная проверка значений свойств метода API
3. Ошибочные типы данных и, как следствие, некорректное отображение в пользовательском интерфейсе 
4. Неправильные ограничения на уровне API
5. Несоответствие между обработкой значений в API, UI и БД, например, разные типы данных для одного и того же объекта или разные границы для одного и того же значения.

Чтобы убедиться, что все эти случаи учтены, тестировщик должен принять во внимание следующее:
1. Поддерживает ли тестируемый программный интерфейс API все методы HTTP?
2. Структура запросов и ответов: какая структура корректная, какая некорректная, какие запросы и ответы вообще возможны.
3. Обязательные и необязательные параметры URL-адреса и поля тела запроса (перечень конкретных параметров и полей). И что должно прийти в ответ на запрос без обязательных данных.
4. Какие поддерживаются типы данных: символьные строки, числа, даты (значения дата-время обычно не являются источником проблем).
5. Пределы и ограничения: например, ограничение по длине имени пользователя в 121 знак. Что, если в теле запроса будет имя из 122 знаков?
6. Коды ответов: какие коды, приходящие в ответах, может получать клиент.

Первый пункт следует проверить перед началом работы, а следующие 5 пунктов выглядят немного по-разному для разных методов. Рассмотрим их на примере https://petstore.swagger.io/(opens in a new tab), отсортировав по HTTP-методам.
### Проверьте перед началом тестирования: Какие методы поддерживает тестируемый API?
Обычно используются следующие HTTP-методы:
+ POST (используется для создания изображения для питомца с заданным ID, нового питомца, обновления питомца с заданным ID, нового магазина, нового пользователя и т. д.)
+ PUT (используется только для обновления пользователя с заданным ID)
+ GET (используется для получения информации о питомце, магазине, пользователе и т. д.)
+ DELETE (используется для удаления питомца, магазина и пользователя).

Время от времени методы PUT и DELETE не используются из-за ограничений браузера и могут быть пропущены в RESTful-части. Иногда в браузере это выглядит как POST, но на уровне API преобразуется в PUT. Учитывайте эти нюансы.
### Тестирование POST/PUT
Тестирование этих методов очень похоже, разница лишь в том, что в POST мы обычно создаем новый объект, а в PUT только изменяем некоторые параметры. 
1. Протестируем POST https://petstore.swagger.io/v2/pet со следующим телом запроса:
```json
{
    "name": "doggie",
    "photoUrls": [
        "elit cillum exercitation",
        "tempor cupidatat sint aliqua"
    ],
    "id": -36071088,
    "category": {
        "id": 36135777,
        "name": "laborum elit"
    },
    "tags": [
        {
            "id": -58986065,
            "name": "id ut dolore ipsum dol"
        },
        {
            "id": -20316514,
            "name": "adipisicing nostrud"
        }
    ],
    "status": "available"
}
```
2. Структура запроса/ответа
   1. Протестируем POST с пустым JSON в BODY
   2. Протестируем POST с пустым телом.
3. Протестируем, что один и тот же объект можно изменить 2 раза. Этот тест должен корректно работать с PUT, но для POST, скорее всего, он просто создаст двух питомцев
4. Обязательные|опциональные параметры URL или поля тела запроса
   1. Попробуйте удалить некоторые обязательные параметры из тела запроса
   2. Сделать некоторые обязательные параметры пустыми
5. Какие типы данных поддерживаются
Понимание типов данных дает вам простор для исследований. Очевидно, что в рассмотренном выше сервисе POST /pet типами данных параметров тела являются:
+ id - числовой
+ category - (id - числовое значение, название - строка) 
+ name - строка
+ photoUrls - строка в специальном формате
+ tags - (id - числовое значение, имя - строка) 
+ status - список предопределенных строк

Попробуйте найти максимальное и минимальное значение и длину, попробуйте изменить значение ожидаемого типа на другое (например, дать строку вместо числового и т.д.)
6. Границы и ограничения 
Выполняют последовательное тестирование каждого из параметров, для чего необходимо использовать стандартные техники тестирования различных типов данных. 
   1. Для проверки параметра имени нужно создать:
   + Питомца с именем из одной буквы
   + Питомца с именем максимальной длины (если мы ее не знаем, то используем ограничение на тип string).
   + Питомец с пустым именем
   + Питомца со специальными символами в имени.
   2. Для тестирования параметра-список (например, photoUrls) использовать принципы тестирования списков. Создать:
   + Только один элемент списка (<string>)
   + Несколько элементов списка
   + Пустой список
   3. Проверить правильность самого URL и создать объекты, у которых он есть:
   + Правильный формат URL
   + Неправильный формат URL
   + Пустая строка вместо URL
   + URL максимальной длины
   + URL минимальной длины
   + URL, содержащий символы Unicode, например https://mentorpiece.ru/%d0%be%d0%b1%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e/
   4. И т.д.
7. Коды ответов
Повторить описанные выше эксперименты, обращая особое внимание на коды ответов:
+ Объект создан - код ответа 201
+ Обязательные параметры пусты - это может быть код ответа 400 или 200, а значения назначены по умолчанию

*!!!Внимание JSON должен быть валидным, иначе будет ошибка от валидатора, а не от тестируемой системы.*
### Тестирование GET
Прежде чем приступить к тестированию ```GET https://petstore.swagger.io/v2/pet/:petId```, необходимо подготовить тестовые данные, содержащие нужные нам значения. Для этого требуется либо база данных (если она доступна и разрешена операция INSERT), либо метод POST, создающий соответствующий объект. Таким образом проверяется как корректность метода POST или PUT (если GET не выводит созданный объект, то, очевидно, что-то пошло не так), так и корректность самого метода GET (выведет ли он, например, животное без статуса?).
1. Структура запроса/ответа
Самый простой способ показать, как проверить структуру запроса и ответа, - это пример GET /pet/{petId}.
+ проверить действительный ли идентификатор питомца (как мы сделали с идентификатором питомца = 1)?
+ проверить несуществующий ID питомца? Попробуйте сделать это с идентификатором питомца = 234343.
+ пропустить идентификатор (GET /pet - без идентификатора).
+ задать вместо ID не число? 
+ проверить Id = 0

Как изменится структура ответа?  Попробуйте поэкспериментировать.
2. Обязательные|опциональные параметры URL или поля тела запроса 
В GET /pet/{petId} параметр Id является обязательным. Попробуйте запустить GET без ID /pet/{petId}.
3. Какие типы данных поддерживаются
Тип данных ID здесь Integer (ожидается числовое значение). Попробуйте вместо этого задать строку. GET /pet/wrwerw
4. Границы и ограничения
Проверить максимальный и минимальный ID
5. Коды ответов
Теперь повторите описанные выше эксперименты, обращая особое внимание на коды ответов. 
+ Проверить действительный идентификатор питомца - код ответа 200
+ Проверить несуществующий ID питомца - код ответа 404 (Питомец не найден)
+ Пропустить идентификатор. Код ответа - ? 
+ ID выглядит не как число. Код ответа - ?
+ Id был равен 0 - код ответа 404 (Pet not found).
### Тестирование DELETE
Проверив, как GET обрабатывает каждый из созданных объектов, вы можете удалить его с помощью метода ```DELETE https://petstore.swagger.io/v2/pet/:petId.```
Прежде чем приступить к тестированию, необходимо подготовить тестовые данные, содержащие нужные нам значения. Для этого требуется либо база данных (если она доступна и разрешена операция INSERT), либо метод POST, создающий соответствующий объект.
1. Структура запроса/ответа
+ проверить действительный идентификатор питомца
+ проверить несуществующий ID питомца.
+ пропустить идентификатор.
+ задать не число в качестве ID 
+ проверить Id = 0?

Изучить как изменяется структура ответа?  Попробуйте поэкспериментировать.
2. Обязательные|опциональные параметры URL или поля тела запроса
В DELETE /pet/{petId} параметр Id является обязательным. Попробовать запустить DELETE без параметра: DELETE /pet/.
3. Какие типы данных поддерживаются
Тип данных ID здесь Integer (ожидается числовое значение). Попробовать вместо этого задать строку. DELETE /pet/wrwerw
4. Границы и ограничения
   1. Кроме исследования вокруг конкретного значения, попробовать удалить объект с максимальным и минимальным идентификатором.
   2. Удалите один и тот же объект 2 раза. Во второй раз должна быть получена ошибка.
5. Коды ответов
Повторить описанные выше эксперименты, обращая особое внимание на коды ответов. 
+ проверить действительный идентификатор питомца - код ответа 200
+ проверить несуществующий ID питомца - код ответа 404 (Питомец не найден)
+ пропустить идентификатор? (DELETE /pet - без ID) 
+ заменить ID на не число 
+ попробовать Id = 0 - код ответа 404 (Pet not found).
### Вывод
1. В результате должен получиться следующий позитивный сценарий:
POST (создать объект) --> GET (получить информацию о созданном объекте) --> PUT (изменить характеристики объекта) --> GET (убедиться, что характеристики изменились) --> DELETE (удалить объект) --> GET (убедиться, что объект был удален).
2. Негативные сценарии генерируются на основе предложенных выше тестов и их комбинаций.

