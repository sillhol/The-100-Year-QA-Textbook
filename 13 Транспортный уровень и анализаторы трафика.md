# 13 Транспортный уровень и анализаторы трафика
## Транспортный уровень модели TCP/IP
Суть транспортного уровня - в определении как именно данные будут передаваться

Транспортный уровень модели TCP/IP представлен в большинстве случаев протоколами TCP (Transmission Control Protocol — протокол управления передачей) и UDP (User Datagram Protocol — протокол пользовательских датаграмм).
### Основные принципы и понятия
#### Сетевые пакеты
+ нельзя передать большой файл за раз одной порцией - он разделяется на пакеты, которые принимающая сторона собирает в файл и передает приложению
+ максимальный размер пакета зависит от настроек канального уровня (Datalink Layer / Interface Layer). В современных сетях MTU (Maximum Transmission Unit) для Ethernet (максимально допустимый размер полезной нагрузки (payload) пакета на уровне канала передачи данных (Layer 2 OSI)) составляет 1500 байт. Это означает, что полезная нагрузка пакета не может превышать 1500 байтов. Включая заголовки и трейлеры, полный размер Ethernet-кадра будет чуть больше 1500 байт, поэтому:
  + когда вы запрашиваете файл или веб-страницу, обычно ваш запрос помещается в один пакет, а ответ сервера обычно превышает размер пакета и поэтому разделяется на части, которые доставляются приложению вашего клиента.
  + когда клиент загружает что-либо, отправляет электронное письмо и т.д. - размер запроса превышает размер одного пакета, потому запрос разделяется на несколько частей и отправляется серверу в виде нескольких пакетов.
#### Сетевые порты
*Сетевой порт* - это логический конструктивный элемент, используемый для идентификации конкретного процесса или сетевой службы на узле в сетевой архитектуре, при отправке данных к нужным процессам, обеспечивая, таким образом, надлежащую доставку информации в системах связи (используются как TCP, так и UDP протоколами)
##### Как это работает
+ Сетевое серверное приложение (например, веб-сервер) при запуске  открывает порт и начинает прослушивать его (веб-сервер прослушивает порт 80, а приложение сервера электронной почты слушает порт 25 для принятия входящих запросов)
+ Когда клиент хочет получить веб-страницу, то он должен отправить запрос на порт 80, но если он хочет отправить электронное письмо, то он должен направить его на порт 25.
+ Когда клиент обменивается данными с сервером, порт также открыт и на стороне клиента. Этот порт используется приложением клиента, для взаимодействия с удалённым сервером:
  + Каждое соединение представлено уникальным кортежем значений: {transport_protocol, client_IP, client_port, server_IP, server_port}. Это позволяет ОС клиента различать соединения разных программ, обменивающихся данными с разными удалёнными серверами.
  + Узел клиента может работать с несколькими серверами одновременно.
  + Более того, один и тот же узел клиента может работать с одним и тем же приложением сервера (например, 1.2.3.4:80), используя одновременно несколько приложений (например, запрашивая страницы одного и того же веб-сайта с помощью браузеров Firefox, Safari, Chrome, Opera, — для каждого соединения будет использоваться свой порт клиента, поэтому потоки данных не перепутаются).

Для каждого протокола, TCP и UDP, доступно по 65 536 портов
### TCP — протокол управления передачей
+ управляет очерёдностью данных. На стороне получателя пакеты собираются воедино в том же порядке, в котором они были отправлены.
+ повторная отправка потерянных пакетов. Если получение пакета не подтверждено любой из сторон, этот пакет запрашивается снова.
+ Управление потоком. Если одна конечная точка отправляет данные быстрее, чем вторая способна обрабатывать, то более медленная сторона может запросить снижение скорости отправки.

Обеспечения выше указанных функций приводит к дополнительным накладным расходам:
+ к каждой порции данных пакета, не превышающей 64 килобайт (это максимально допустимый размер IP-пакета для IPv4), добавляется заголовок TCP размером от 20 и 40 байтами; 
+ процессор должен выполнить намного больше работы, чтобы заполнить все поля заголовка. 

*Примечание: Эти накладные расходы особенно обременительны, если вы используете протокол TCP для передачи небольших пакетов данных. Например, протокол SSH отправляет каждый введённый вами с помощью клавиатуры символ как отдельный пакет. Таким образом, на один байт (на самом деле больше — из-за шифрования) «полезных данных» придется 20–40 байт заголовка TCP, поэтому протокол TCP обычно используется как основа для обмена данными между сетевыми приложениями, которым необходим строгий порядок отправки и получения данных и гарантия доставки. Примеры таких приложений:*
+ Электронная почта
+ Торговля через Интернет и банковские приложения;
+ Базы данных
+ Веб-сервисы 

<img src="resources/tcp.png" alt="Структура TCP-пакета" width="50%"/>

Поля TCP-пакета
1. Sequence number (порядковый номер) - Протокол TCP сохраняет порядок следования пакетов. Sequence number используется для нумерации пакетов. У каждого пакета есть свой номер.
2. Acknowledgment number (номер подтверждения) - В протоколе TCP предусмотрен механизм подтверждения, поэтому узел должен отправлять подтверждение для каждого полученного пакета.
3. Window (окно)  - с помощью этого поля Window получатель может ограничивать объём входящих данных от отправителя, управляя скоростью передачи данных.
4. Flags (флаги) - используется для добавления в пакет специальных меток.
5. Source Port (порт источника) - результат работы ОС на обращение приложения с просьбой установить соединение TCP с узлом x.y.w.v, порт abc. Порядок применения поля следующий:
   1. приложения с просит ОС установить TCP-соединение с узлом x.y.w.v, порт abc
   2. ОС резервирует локальный порт со случайным номером, связанным с IP-адресом, который будет использоваться для установки соединения
   3. ОС создаёт специальный программный интерфейс [сокет](#socket-position), представленный и идентифицирующийся в ОС с помощью уникального **кортежа** {transport_protocol, client_IP, client_port, server_IP, server_port}, который ассоциирует адрес памяти вашего компьютера с ссылкой на этот порт
   4. Далее, когда приложение хочет отправить некоторые данные этому удалённому узлу и порту, оно просто использует сокет, не заботясь о процессе передачи данных

*Пример на Python программного создания/применения TCP-сокета (SOCK_STREAM - оначает TCP-сокет) для сервера:*
```python
# Создание TCP сокета
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Привязка сокета к порту и прослушивание
server_address = ('localhost', 10000)
sock.bind(server_address)
sock.listen(1)

print('TCP сервер готов принимать соединения...')

while True:
    connection, client_address = sock.accept()
    try:
        print(f'Подключено к {client_address}')
        
        while True:
            data = connection.recv(4096)
            if data:
                print(f'Получено: {data}')
                connection.sendall(data)
            else:
                break
    finally:
        connection.close()
```
*Пример на Python программного создания/применения TCP-сокета (SOCK_STREAM - оначает TCP-сокет) для клиента:*
```python
# Создание TCP сокета
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_address = ('localhost', 10000)
sock.connect(server_address)

try:
    message = b'Hello, Server'
    print(f'Отправка {message}')
    sock.sendall(message)

    data = sock.recv(4096)
    print(f'Получено {data}')
finally:
    sock.close()
```
#### Процедура установки соединения - «рукопожатие TCP» (TCP handshake)
![«рукопожатие TCP»](resources/TCP_handshake.png)

По протоколу TCP данные можно отправлять только после установки соединения между клиентом и сервером. Алгоритм следующий:
1. В самом начале у нас есть клиент без каких-либо соединений и связанных с ними состояний, и сервер в состоянии LISTEN (прослушивание), которое означает, что сервер ждёт запроса на установку соединение. Если клиент попытается соединиться с портом, который никто не прослушивает, то он получит пакет с флагом RST (reset — сброс).
2. Клиент генерирует случайный номер (X) и в поле Sequence Number отправляет его серверу в  TCP пакете с меткой SYN, помещённой в поле флагов. SYN означает «синхронизация». Теперь соединение находится в состоянии SYN-SENT (SYN отправлен).
3. Сервер получает от клиента пакет SYN и формирует пакет с подтверждением устанавливая флаг ACK и копируя в поле Acknowledgment Number значение X + 1. Также сервер устанавливает в своём пакете флаг SYN и записывает свой случайный номер (Y) в поле Sequence Number, а затем отправляет TCP-пакет клиенту. Теперь соединение находится в состоянии SYN-RECEIVED (SYN получен).
4. Клиент получает от сервера пакет SYN+ACK и отправляет обратно пакет с флагом ACK и номером Y + 1 в поле Acknowledgment Number. Теперь у нас есть соединение в состоянии ESTABLISHED (установлено).
5. Теперь обе стороны знают, что между ними установлена связь, и могут отправлять полезные данные 

Обмен данными происходит тем же образом (но без пакетов SYN): при отправке пакетов узлы просто увеличивают на единицу свои порядковые номера и отправляют подтверждения для полученных пакетов.
#### Процедура завершением соединения (TCP teardown)
![TCP teardown](resources/tcp_close.gif)

1. Первый способ закрыть соединение TCP — это просто перестать отвечать. Удалённый узел выждет определённый период (время ожидания, настроенное в операционной системе) и удалит информацию об этом соединении из памяти. Это произойдёт, например, в случае перезагрузки одного из узлов.
2. Второй способ:
   1. Вначале узел отправляет пакет с флагом FIN.
   2. Второй узел отправляет первому подтверждение.
   3. Второй узел отправляет свой пакет с флагом FIN.
   4. Первый узел отправляет последний пакет с флагом ACK.
#### Список состояний TCP-соединения
  + LISTEN: Сервер ждет входящих соединений от клиентов. Это состояние ожидает, когда кто-то инициирует соединение.
  + SYN-SENT: Клиент отправил запрос на установление соединения (SYN) и ждет подтверждения от сервера. Это состояние устанавливается после отправки SYN-пакета.
  + SYN-RECEIVED: Сервер получил запрос на установление соединения (SYN) и отправил подтверждение (SYN-ACK). Это состояние устанавливается после отправки SYN-ACK, но до получения ACK от клиента.
  + ESTABLISHED: Соединение установлено, и данные могут передаваться в обоих направлениях. Это основное состояние для активного соединения.
  + FIN-WAIT-1: Активная сторона (которая инициировала завершение соединения) отправила запрос на завершение соединения (FIN) и ждет подтверждения (ACK) от другой стороны.
  + FIN-WAIT-2: Активная сторона получила подтверждение (ACK) на свой запрос на завершение соединения (FIN) и ждет запроса на завершение (FIN) от другой стороны.
  + CLOSE-WAIT: Пассивная сторона (которая не инициировала завершение) получила запрос на завершение соединения (FIN) и отправила подтверждение (ACK). Теперь она ждет, когда приложение закроет соединение.
  + CLOSING: Обе стороны одновременно отправили запрос на завершение соединения (FIN). Это редкое состояние, когда каждая сторона ждет подтверждения от другой.
  + LAST-ACK: Пассивная сторона отправила запрос на завершение соединения (FIN) после получения запроса на завершение (FIN) от активной стороны и теперь ждет подтверждения (ACK).
  + TIME-WAIT: Активная сторона завершила соединение и ждет, чтобы убедиться, что другая сторона получила подтверждение (ACK) на ее запрос на завершение (FIN). Это состояние длится в течение времени, называемого TIME-WAIT (обычно 2 * MSL, максимальная длительность жизни сегмента).
  + CLOSED: Соединение закрыто, и никаких дальнейших данных не передается. Это состояние представляет завершенное соединение.
#### Диаграмма переходов между состояниями TCP в зависимости от полученных и отправленных пакетов (RFC 793):
1. LISTEN:
   + Получение SYN → SYN-RECEIVED
   + Отправка SYN → SYN-SENT
2. SYN-SENT:
   + Получение SYN-ACK → ESTABLISHED
   + Получение SYN → SYN-RECEIVED
   + Получение RST → CLOSED
3. SYN-RECEIVED:
   + Получение ACK → ESTABLISHED
   + Получение SYN-ACK → SYN-RECEIVED (если устанавливается симметричное соединение)
4. ESTABLISHED:
   + Получение FIN → CLOSE-WAIT
   + Отправка FIN → FIN-WAIT-1
5. FIN-WAIT-1:
   + Получение ACK → FIN-WAIT-2
   + Получение FIN → CLOSING
6. FIN-WAIT-2:
   + Получение FIN → TIME-WAIT
7. CLOSE-WAIT:
   + Отправка FIN → LAST-ACK
8. CLOSING:
   + Получение ACK → TIME-WAIT
9. LAST-ACK:
   + Получение ACK → CLOSED
10. TIME-WAIT:
    + По истечении времени → CLOSED
11. CLOSED:
    + Конечное состояние, никаких переходов не происходит.

#### Пример процесса установки и завершения соединения:
1. Установка соединения:
   1. Клиент в состоянии CLOSED отправляет SYN и переходит в состояние SYN-SENT.
   2. Сервер в состоянии LISTEN получает SYN, отправляет SYN+ACK и переходит в состояние SYN-RECEIVED.
   3. Клиент в состоянии SYN-SENT получает SYN+ACK, отправляет ACK и переходит в состояние ESTABLISHED.
   4. Сервер в состоянии SYN-RECEIVED получает ACK и переходит в состояние ESTABLISHED.
2. Обмен данными:
   1. Оба участника находятся в состоянии ESTABLISHED и обмениваются данными.
3. Завершение соединения:
   1. Клиент в состоянии ESTABLISHED отправляет FIN и переходит в состояние FIN-WAIT-1.
   2. Сервер в состоянии ESTABLISHED получает FIN, отправляет ACK и переходит в состояние CLOSE-WAIT.
   3. Клиент в состоянии FIN-WAIT-1 получает ACK и переходит в состояние FIN-WAIT-2.
   4. Сервер в состоянии CLOSE-WAIT отправляет FIN и переходит в состояние LAST-ACK.
   5. Клиент в состоянии FIN-WAIT-2 получает FIN, отправляет ACK и переходит в состояние TIME-WAIT.
   6. Сервер в состоянии LAST-ACK получает ACK и переходит в состояние CLOSED.
   7. Клиент в состоянии TIME-WAIT ждет определенное время и переходит в состояние CLOSED.
### UDP — протокол пользовательских датаграмм
В отличие от TCP, UDP обеспечивает ненадежную и неупорядоченную передачу данных, что делает его более быстрым и легковесным, но менее надежным (нет упорядочивания пакетов, подтверждения получения данных и управления скоростью потока, UDP не использует соединение: нет ни «рукопожатия», ни вежливого «прощания», только передача данных от одной точки к другой)

![Структура UDP-пакета](resources/udp.gif)

Структура заголовка UDP (поле Data (данные) содержит данные приложения, инкапсулируемые в пакете). 

Протокол UDP применяют в случае когда нет времени на повторную отправку повреждённых данных т.к. моменту повторной отправки эти данные уже утратят актуальность:
+ потоковой передачи мультимедиа
+ голосовой связи (VoIP)
+ преобразования доменных имён в системе DNS и онлайн-игр

Как и в TCP, в протоколе UDP предусмотрено следующее:
+ Порты как для клиента, так и сервера.
+ Работа с сокетами - основным механизмом для передачи данных между устройствами в сети.
### Quick
Протокол QUIC (Quick UDP Internet Connections) представляет собой современный транспортный протокол, разработанный Google, который работает поверх UDP

Ключевые особенности QUIC:
+ Быстрое установление соединения: QUIC использует меньший накладной трафик для установления соединений по сравнению с TCP, что сокращает задержки.
+ Интегрированное шифрование: QUIC встроенно поддерживает шифрование, что делает соединения более безопасными.
+ Мультиплексирование потоков: QUIC позволяет передавать несколько потоков данных одновременно по одному соединению, что улучшает производительность и надежность.
+ Устойчивость к потере пакетов: QUIC более эффективно обрабатывает потерю пакетов по сравнению с TCP, что улучшает стабильность соединения.

Примеры протоколов прикладного уровня, которые взаимодействуют с QUIC, включают HTTP/3, DNS over QUIC, gRPC over QUIC, SMB over QUIC, WebRTC over QUIC и FTP over QUIC.
### Средства командной строки для работы с портами
#### Мониторинг прослушиваемых портов TCP и UDP:
Это порты, на которых сервер ожидает входящих соединений от клиентов:
+ ОС Linux: ```netstat -vpntul``` или ```ss -pntul```
+ macOS: ```netstat -anf inet | egrep -v 'EST|WAIT' | sort | uniq```
+ Windows: ```netstat```
#### Мониторинг активных портов TCP и UDP (ESTABLISHED):
Это порты, на которых сетевое соединение активно передает данные:
+ ОС Linux: ```netstat -vpntu```
+ macOS: ```netstat -anf inet | egrep EST```
+ Windows: ```netstat -a```
#### Cоотнесение портов с сетевыми приложениями
+ (только для Linux) с помощью сведений в правом столбце: ```netstat -vpntul``` (за соотнесение портов с сетевыми приложениями отвечает параметр -p).
+ (только для  Linux и macOS) в файле ```/etc/services```:
  ```http            80/tcp          www     # WorldWideWeb HTTP```
#### netstat подробно
netstat — самая известная (но немного устаревшая) из инструментов анализа сетевых соединений. Часто используемые опции следующие:
+ ```-n```: отображение портов и адресов узлов в виде чисел и IP-адресов соответственно. Рекомендуется ее применять. Если эту опцию упустить, то вместо чисел будут показываться имена служб (из файла ```/etc/services```) и имена узлов, что очень неудобно, поэтому если вам нужны номера портов, то используйте опцию ```-n```.
+ ```-t``` отображение портов TCP.
+ ```-u```: отображение портов UDP; может сочетаться с ```-t```.
+ ```-l```: отображение только прослушиваемых портов. Если эту опцию упустить, то будут отображаться только активные соединения (а не прослушиваемые порты).
+ ```-a```: отображение как прослушиваемых портов, так и активных соединений.
+ ```-p```: отобразить процессы, открывшие эти порты и соединения; показывается ограниченный объём информации, если вы не являетесь пользователем root.
<a id="socket-position"></a>
## Заголовок или текст, на который вы хотите сослаться
### Сокеты и сетевые порты
#### Как сокеты соотносятся с портами и процессами
Сокеты представлены и идентифицируются в ОС с помощью уникального **кортежа** 
+ {transport_protocol, client_IP, client_port, server_IP, server_port}

Значение **кортежа** в виде значений колонок ```Proto```, ```LocalAddress``` и ```Foreign Address``` образует вывод команды ```netstat```:
```console
$ netstat -pnt
Не все процессы могут быть идентифицированы, информация о не принадлежащих процессах не будет показана, вам придется стать root, чтобы увидеть все это.)
Активные интернет-соединения (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp       25      0 192.168.31.18:52024     170.114.52.3:443        CLOSE_WAIT  61649/zoom          
tcp        0      0 192.168.31.18:59570     52.149.21.60:443        ESTABLISHED 6802/skypeforlinux  
tcp       25      0 192.168.31.18:52034     170.114.52.3:443        CLOSE_WAIT  61649/zoom          
tcp        0      0 192.168.31.18:51420     3.68.61.181:443         ESTABLISHED 9223/Slack --standa
[ ...  и ниже еще больше строк ... ]
```
*Примечание: Строки 1 и 3 относятся к двум процессам zoom, которые закрывают соединения с удалённым сервером 170.114.52.3. ОС клиента их различает по разным сокетам, так как клиентские порты разные.*
#### Серверные (т.е. прослушиваемые) порты
Порты серверов (т.е. прослушиваемые порты) показываются тоже как сокеты, но у них ненастоящие адреса в поле ```Foreign Address``` (внешний адрес), так как никто ещё не подключён.
```
$ netstat -ntul
Активные интернет-соединения (только сервера)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
tcp6       0      0 :::7031                 :::*                    LISTEN     
tcp6       0      0 ::1:25                  :::*                    LISTEN     
tcp6       0      0 :::33060                :::*                    LISTEN     
tcp6       0      0 :::9031                 :::*                    LISTEN     
tcp6       0      0 :::3306                 :::*                    LISTEN  
udp        0      0 127.0.0.53:53           0.0.0.0:*             
```
*!!! На примере выше:*
+ Для прослушиваемых портов внешние адреса показываются как 0.0.0.0:* или :::* (для tcp6)
+ Локальные адреса, наподобие 1.2.3.4:5000, показывают, на каком IP-адресе доступен этот порт
  + 0.0.0.0 означает, что этот порт доступен на всех IP-адресах этого сервера. Например, если у сервера IP-адреса 1.2.3.4 и 5.6.7.8, то клиенты для доступа к этому порту (и соответствующему приложению, прослушивающему этот порт) могут указать любой из этих адресов
  + 127.0.0.1 означает, что этот порт доступен только на этом IP-адресе, то есть, чтобы получить доступ к этому порту (например, 25), клиент должен использовать IP-адрес 127.0.0.1. (IP-адрес 127.0.0.1 говорит, согласно сказанному ранее в этом модуле, что такое возможно, только если клиентское приложение и сервер работают на одном компьютере).
+ ":::7031" вместе с меткой "tcp6" означают, что порт TCP 7031 доступен посредством протокола TCP, при использовании как IPv4, так и IPv6, на любом IP-адресе компьютера. Символы “::” в версии IPv6 являются аналогом 0.0.0.0 в версии IPv4, обозначающим все IP-адреса.
+ "::1:25" означает то же, что и 127.0.0.1:25, но для IPv6. Поэтому "::1" в версии IPv6  это аналог адреса 127.0.0.1 версии IPv4.
+ Для портов UDP состояние LISTEN не показывается, но в действительности они являются прослушиваемыми портами.
+ порт 53 не используется дважды как кажется, а дважды открыт для двух разных протоколов: TCP и UDP.

*Примечание:*
+ У одного процесса может быть много сокетов. Каждый сокет может быть связан с одним и только одним локальным IP-адресом и одним локальным портом (и с одним внешним IP-адресом и внешним портом, если говорить об активных соединениях). Поэтому взаимосвязи между ними следующие:
  + процесс и сокеты: один-ко-многим
  + сокеты и кортежи {transport_protocol, local_IP, local_port, remote_IP, remote_port}: один-к-одному.
+ Если приложение хочет создать прослушиваемый порт (например, 22) с использованием определённого протокола (например, TCP), этот порт должен быть свободен. В противном случае, ОС отправит сообщение об ошибке и прервёт эту попытку.
+ Если порт сервера не прослушивается ни одним процессом, то он называется закрытым портом (то есть он свободен). Такие порты не показаны в выводе программы netstat из примера выше.
+ Если клиентское приложение попытается соединиться с закрытым портом, то ответ сервера будет зависеть от протокола:
  + TCP: сервер отправит пакет с установленным флагом RST, означающим, что это соединение было сброшено из-за сбоя.
  + UDP: для этого протокола флаги наподобие RST не предусмотрены. Вместо пакета с таким флагом сервер может отправить сообщение ICMP Destination Unreachable (порт недоступен), говорящее клиенту, что этот порт никто не прослушивает. Отправка такого сообщения ICMP является желательным поведением согласно стандартам, но не обязательным. Сервер может быть настроен на игнорирование таких запросов по разным причинам, например, для обеспечения безопасности.
+ Когда клиентское приложение соединяется с сервером, серверное приложение (прослушивающее соответствующий порт) открывает активный сокет для обработки запроса. В то же время прослушиваемый сокет не затрагивается и остаётся готовым для новых соединений с другими клиентами.

![Схематическое представление клиентских и серверных сокетов](resources/09-sockets.png)

Схематическое представление клиентских и серверных сокетов
## Анализаторы сетевого трафика «снифферы»
Самые популярные анализаторы — **tcpdump** и **Wireshark**. Они могут значительно помочь в поиске и устранении сложных неисправностей, связанных с сетью, например:
+ Сервер работает, но не отвечает
+ Сервер работает, но его ответы выглядят некорректно.
+ Состояние сервера неизвестно, удалённый доступ (например, посредством сессии SSH) запрещён, поэтому нам нужно посмотреть, что происходит с сетевым трафиком
### tcpdump
**tcpdump** — это анализатор пакетов с интерфейсом командной строки, совместимый с большинством современных ОС

```tcpdump <options> <expression>```, где опции (options) определяют, что и как будет собираться, а (expression) - фильтры
#### Опции для сбора пакетов:
Опции определяют, что и как будет собираться:
+ ```-c <N>``` (например, ```-c 20```): собрать первые N пакетов и выйти. По умолчанию, "tcpdump" работает до остановки нажатием Ctrl+C;
+ ```-i <interface_name>``` (название интерфейса): задают сетевой интерфейс, например ```lo``` или ```eth0```; по умолчанию берётся первый интерфейс, не являющийся ```lo```. Для сбора пакетов со всех интерфейсов нужно указать следующее: ```-i any```, например, ```tcpdump -i eth0,eth1```;
+ ```-s <N>```: установка захватываемой длины пакета. ```-s 0``` — для сбора полных пакетов; ```-s60``` — для сбора только первых 60 байт каждого пакета;
+ ```-w <file>``` (файл): вместо вывода на терминал сохранять поток собранных данных в файле формата PCAP (формат файлов для хранения необработанных сетевых данных);
+ ```-r <file>``` (файл): считывать пакеты из файла PCAP, а не из сетевых интерфейсов. Опция полезна для глубокого исследования сетевого потока.
#### Опции для отображения:
Эти опции определяют, как  данные пакетов будут отображаться программой tcpdump, и не влияют на параметры сбора. Поэтому их можно применить как для вышеупомянутых файлов PCAP (если используется опция -r), так и для сбора пакетов в реальном времени (опция -i):
+ ```-n```: не преобразовывать IP-адреса в имена узлов;
+ ```-nn```: показывать адреса узлов в виде IP-адресов, а порты в виде номеров. Эту опцию рекомендуется использовать в большинстве случаев;
+ ```-X```: вывод необработанного содержимого пакетов, представленного как шестнадцатеричной формой, так и форматом, удобным для человека (символы ASCII). Очень полезна для более тщательного анализа содержимого пакетов при изучении неисправностей;
+ ```-A```: вывод необработанного содержимого пакетов в компактном формате без шестнадцатеричной части. Если не указаны -X, и -A, то в формате, удобном для человека, отображаются только заголовки;
+ ```-ttt```: вместо полной временной метки выводить прирост времени с момента предыдущего элемента;
+ ```-v``` / ```-vv``` / ```-vvv```: три степени подробности.
#### Выражения (фильтры):
С помощью выражений (также называемых фильтрами) определяются элементы, которыми необходимо ограничить сбор данных. Элементы можно сочетать с помощью ключевых слов or (или), and (и), not (не), а также с помощью скобок. Если применяются скобки, то выражение необходимо заключать в кавычки, например: "(tcp or icmp)", а не (tcp or icmp). Можно применять как двойные, так и одинарные кавычки.

| Синтаксис  | Значения  | Примеры выражений (фильтров)  | Пояснение  |
|-----------|-----------|-----------|-----------|
| host X | Только трафик, исходящий от узла X или предназначающийся ему. Это двунаправленное условие, поэтому собираются как запросы клиентов, так и ответы серверов | host example.com<br><br>host 8.8.8.8 | Весь поток пакетов между данным узлом (на котором установлена программа tcpdump) и удалённым узлом example.com. То же для узла 8.8.8.8 |
| net X/Y | Подобно host, но собирается поток данных для всех узлов этой сети. X — адрес сети, Y — маска подсети. Например, tcpdump может быть запущен на узле, который видит весь трафик этой сети. Это может быть маршрутизатор, коммутатор с настроенным SPAN-портом или сервер, через который проходит весь трафик сети. | net 8.8.0.0/16 | Весь поток пакетов, проходящий между данным узлом и любым узлом сети 8.8.0.0/16 |
| tcp / udp / icmp | Название протокола, поток которого будет собираться | tcp and port 8080<br><br>udp and not port 53<br><br>icmp | Пакеты TCP, исходящие из порта 8080 или предназначающиеся ему.<br>Пакеты UDP, исходящие из любого порта или предназначающиеся любому порту кроме 53.<br>Все пакеты протокола ICMP |
| port X | Номер порта протокола TCP или UDP. Не применимо к ICMP, так как в рамках этого протокола порты не используются | "tcp and (port 22 or port 3389)"<br><br>port 53 | Пакеты TCP, исходящие из порта 22 или 3389 или предназначающиеся им.<br><br>Пакеты TCP и UDP, исходящие из порта 53 или предназначающиеся ему |
| src | Применимо к ключевым словам host, net, port, portrange. Означает поток данных, исходящий  от этого источника: узла, сети, порта или диапазона портов (portrange) | tcp and src host 192.168.40.150 and src port 22<br><br>udp and dst host 8.8.8.8 and dst port 53 | Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.<br><br>Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться). |
| dst | Подобно src, но означает поток данных, идущий к указанному узлу, сети, порту, диапазону портов | tcp and src host 192.168.40.150 and src port 22<br><br>udp and dst host 8.8.8.8 and dst port 53 | Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.<br><br>Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться). |
| portrange X-Y | Сбор только пакетов протокола TCP или UDP с любым номером порта (исходящего и входящего) в диапазоне от X до Y | tcp and src portrange 1-1023 | Все пакеты TCP, исходящие от портов с номерами от 1 до 1023 |

*Пример 1. Собрать все пакеты TCP с портами 80 или 443, идущие между данным узлом и узлом example.com*
```console
$ sudo tcpdump 'tcp and host example.com and (port 80 or port 443)'
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes

14:53:25.123456 IP your_machine.local.12345 > example.com.http: Flags [S], seq 123456789, win 65535, options [mss 1460,sackOK,TS val 123456789 ecr 0,nop,wscale 6], length 0
14:53:25.123789 IP example.com.http > your_machine.local.12345: Flags [S.], seq 987654321, ack 123456790, win 65535, options [mss 1460,sackOK,TS val 987654321 ecr 123456789,nop,wscale 6], length 0
14:53:25.124012 IP your_machine.local.12345 > example.com.http: Flags [.], ack 987654322, win 65535, options [TS val 123456790 ecr 987654321], length 0
14:53:25.124345 IP your_machine.local.12345 > example.com.http: Flags [P.], seq 123456790:123456850, ack 987654322, win 65535, options [TS val 123456790 ecr 987654321], length 60: HTTP: GET / HTTP/1.1
14:53:25.124678 IP example.com.http > your_machine.local.12345: Flags [.], ack 123456850, win 65535, options [TS val 987654322 ecr 123456790], length 0
14:53:25.125001 IP example.com.http > your_machine.local.12345: Flags [P.], seq 987654322:987654382, ack 123456850, win 65535, options [TS val 987654322 ecr 123456790], length 60: HTTP: HTTP/1.1 200 OK

14:54:00.234567 IP your_machine.local.54321 > example.com.https: Flags [S], seq 234567890, win 65535, options [mss 1460,sackOK,TS val 234567890 ecr 0,nop,wscale 6], length 0
14:54:00.234890 IP example.com.https > your_machine.local.54321: Flags [S.], seq 987654321, ack 234567891, win 65535, options [mss 1460,sackOK,TS val 987654321 ecr 234567890,nop,wscale 6], length 0
14:54:00.235012 IP your_machine.local.54321 > example.com.https: Flags [.], ack 987654322, win 65535, options [TS val 234567891 ecr 987654321], length 0
14:54:00.235345 IP your_machine.local.54321 > example.com.https: Flags [P.], seq 234567891:234567951, ack 987654322, win 65535, options [TS val 234567891 ecr 987654321], length 60: HTTPS
14:54:00.235678 IP example.com.https > your_machine.local.54321: Flags [.], ack 234567951, win 65535, options [TS val 987654322 ecr 234567891], length 0
14:54:00.236001 IP example.com.https > your_machine.local.54321: Flags [P.], seq 987654322:987654382, ack 234567951, win 65535, options [TS val 987654322 ecr 234567891], length 60: HTTPS
```
Таким образом, по флагам в поле Flags можно определить тип каждого пакета и понять последовательность установления соединения и передачи данных:
+ Флаг [S] обозначает SYN пакет, отправленный от клиента к серверу.
+ Флаг [S.] обозначает SYN-ACK пакет, отправленный от сервера к клиенту.
+ Флаг [.] обозначает ACK пакет, отправленный от клиента к серверу.
+ Флаг [P.] обозначает пакет с данными (PSH и ACK флаги). Здесь клиент отправляет HTTP-запрос (для сервера то же самое).

*Пример 2. Изучить обмен данными по протоколу UDP, проанализировав процесс преобразования доменного имени example.com общедоступным сервером DNS (т. е. «резолвером») с адресом 8.8.8.8:*
```console
[user@host]$ sudo tcpdump -nn -ttt 'udp and host 8.8.8.8 and port 53'
tcpdump: data link type PKTAP
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on pktap, link-type PKTAP (Apple DLT_PKTAP), capture size 262144 bytes
 00:00:00.000000 IP 192.168.0.6.49292 > 8.8.8.8.53: 24940+ [1au] A? example.com. (40)
 00:00:00.028381 IP 8.8.8.8.53 > 192.168.0.6.49292: 24940$ 1/0/1 A 93.184.216.34 (56)
```
*Примечание: обмен данными в примее 2 намного короче, чем в примере 1, так как нет «рукопожатия», используемого в протоколе TCP. В выводе мы видим только передачу данных.*
### Wireshark
Wireshark — анализатор сетевых данных, созданный на основе той же библиотеки, что и tcpdump, но с графическим интерфейсом пользователя
+ В отличие от ```tcpdump``` Wireshark кроме отображения пакетов TCP и UDP может автоматически определять сообщения протоколов прикладного уровня (например, HTTP)
+ Wireshark схожа с ```tcpdump``` и наличием фильтра пакетов. Логика составления выражений во многом та же, но синтаксис несколько отличается:
  + [Wireshark — подробное руководство по началу использования](https://habr.com/ru/articles/735866/),
  + [Wireshark фильтр по IP, по порту, по протоколу, по MAC](https://networkguru.ru/wireshark-filtr-po-ip-portu-protokolu-mac/),
  + [Как настроить фильтры для захвата трафика в WireShark? Примеры!](https://networkguru.ru/kak_nastroit_filtru_dlya_zahvata_trafika/)
#### Особенности захвата и анализа трафика QUIC с использованием TCPdump + Wireshark
Захват и анализ трафика QUIC с использованием TCPdump имеет свои особенности и ограничения. Вот ключевые моменты:
1. Захват трафика QUIC с помощью TCPdump:
```console
sudo tcpdump -i eth0 udp port 443 -w quic_traffic.pcap
```
2. Анализ трафика в Wireshark:
+ Откройте файл quic_traffic.pcap в Wireshark.
+ Если доступны ключи шифрования, импортируйте их в Wireshark для расшифровки трафика:
  + В меню Wireshark выберите Edit > Preferences.
  + Перейдите в раздел Protocols > TLS.
  + В поле (Pre)-Master-Secret log filename укажите путь к файлу с ключами.

