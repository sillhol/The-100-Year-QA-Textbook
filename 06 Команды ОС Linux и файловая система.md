# 06 Команды ОС Linux и файловая система
## Простая команда UNIX с аргументами выглядит следующим образом:
`команда [опции] [позиционные аргументы]`, (Квадратные скобки […] означают, что аргумент необязателен.)

<img src="resources/image.png" alt="синтаксис команды" width="70%"/>

- `команда` предназначена для выполнения одной операции. Например, `egrep` служит для поиска указанных последовательностей символов в файлах и директориях, также указанных с помощью аргументов. Другие команды могут, например, показывать сведения об ОС или содержимое директории
- `опции` указывают, как именно нужно выполнить эту `команду`. В показанном выше примере опция `-i` означает, что поиск должен быть нечувствительным к регистру букв; опция `-r` — поиск в директориях (не только в отдельных файлах); опция `-l` — выводить только названия файлов (без найденных строк файлов).
- `позиционные аргументы` определяют, какие именно объекты будут затронуты, например, подстроки, входные файлы или директории, и т.д.
- `опции` и `позиционные аргументы` вместе именуются **аргументами**, т.е. это все, что следует за названием команды.
- Порядок `опций` неважен. Например, последовательность `-l -a` эквивалентна `-a -l`. Это справедливо и для длинных опций.
- Если используются только короткие опции без значений, такими как `-l` и `-a`, то можете их соединить, упустив пробелы: `-la` или `-al`.
- `команда --help`: выводит встроенную справку для команды; эта опция работает почти для всех команд.
- `man команда`: выводит соответствующее команде подробное руководство, если оно установлено в системе.
- Не меняйте местами опции и параметры, указывающие месторасположение.
- Пробелы между названием команды, секцией опций и секцией с дальнейшими аргументами обязательны
- В `UNIX` всё регистрозависимо (названия файлов, команд, опций, имена пользователей)
## Файловая система ОС Linux и объекты
Путь каждого объекта начинается с `/`. Этот элемент называется «корнем» (`root`), а вся файловая система подобна дереву.
### Стандарт FHS
+ `/etc`	-	файлы конфигурации для большинства приложений и некоторых частей ОС
+ `/home`	-	используется для хранения домашних директорий пользователей, например `/home/ваше_имя_пользователя`
+ `/root`	-	домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС)
+ `/bin`	-	большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория `/bin` часто служит так называемой символьной ссылкой на директорию `/usr/bin`. Любая операция, затрагивающая `/bin/something` будет фактически выполняться на `/usr/bin/something`
+ `/boot`	-	загрузочные файлы (в том числе файлы загрузчика, ядро, `initrd`, `System.map`). Часто выносится на отдельный раздел
+ `/dev`	-	Основные файлы устройств (`/dev/null`, `/dev/sd буква` — жёсткий диск, `/dev/sd буква номер` (раздел диска), `/dev/sr номер` (CD-ROM), `/dev/eth номер` (сетевые интерфейсы Ethernet), `/dev/wlan номер` (сетевые интерфейсы) и др)
+ `/sbin`	-	похож на `/bin`, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root
+ `/tmp`	-	временные файлы ОС и приложений (аналог C:\Temp в ОС Windows)
+ `/var`	-	предназначена для хранения данных, которые часто изменяются: в `/var/cache` находятся временные файлы, которые используются для ускорения работы системы, файлы баз данных (если сервер БД установлен), в директории `/var/log` хранятся системные журналы и логи приложений, в `/var/spool` хранятся данные, ожидающие обработки, такие как задания на печать или электронная почта
+ `/usr` (`/usr/bin`, `/usr/lib`)	-	в настоящее время это главное место для приложений (исключая настройки, хранящиеся в `/etc`). Например: `/usr/bin` содержит исполняемые файлы, `/usr/lib` — разделяемые библиотеки и т. д.
### Абсолютный и относительный пути
+ Абсолютный путь начинается с '/' и включает все промежуточные директории, в которых расположен объект
+ Относительный путь к объекту строго зависит от текущей рабочей директории. Более того, он начинается не со знака '/', а с вашей текущей рабочей директории

Работу с объектами файловой системы можно ускорить с помощью полезных конструкций: '..', '.' (одна точка означает текущую директорию) и '~' (означает вашу домашнюю директорию).
### Основные команды для работы с файловой системой <a id="mainlinuxfscmd"></a>
+ `uname`	-	Выводит название ОС
  + `uname -a` ИЛИ `/bin/uname -a` (all)- Выводит данные о текущем ядре операционной системы и некоторых других системных характеристиках
  + `uname -r` (release)-  выводит только версию ядра операционной системы
+ `date`	-	используется для:
  + Отображения текущей даты и времени: `date` выводит `Пт 30 авг 18:11:01 EEST 2024`
  + Отображения даты и времени в формате UTC: `date -u` выводит `Пт 30 авг 15:11:01 UTC 2024`
  + Установки системной даты и времени (требуются права суперпользователя): `sudo date -s "2024-08-30 18:11:01"`. Формат даты и времени, который используется в команде `sudo date -s "2024-08-30 18:11:01"`, определяется стандартом `POSIX`: `YYYY-MM-DD HH:MM:SS`
  + Отображения даты и времени в заданном формате: `date +"%Y-%m-%d %H:%M:%S"` выводит `2024-08-30 18:11:01`
+ [`mount`](#mountlinux) в Linux используется для подключения файловых систем к определённым точкам монтирования в файловой системе
+ `sleep` используется для приостановки выполнения команд на заданное время, в том числе и в скриптах: `sleep 5` (на 5 секунд), `sleep 10s` (10 секунд), `sleep 2m` (2 минуты), `sleep 1h` (1 час), `sleep 1d` (1 день), `sleep 1h 30m` (1 час 30 минут)
+ `time command` выводит три основных показателя времени выполнения команды:
  + `real`: фактическое время, прошедшее с момента начала до завершения команды. Это включает в себя все время ожидания, например, время, когда процесс был приостановлен или ожидал ввода/вывода.
  + `user`: время, которое процессор потратил на выполнение пользовательского кода (вне ядра). Это время, затраченное на выполнение инструкций программы.
  + `sys`: время, которое процессор потратил на выполнение системного кода (внутри ядра). Это время, затраченное на выполнение системных вызовов, таких как операции ввода/вывода.
+ ```id``` - Выводит сведения о пользователе:
  + `id` отображает эффективную информацию о текущем пользователе. Вывод может быть таким: `uid=1000(vboxuser) gid=1000(vboxuser) groups=1000(vboxuser),27(sudo),100(users),995(vboxsf)`
  + `id username` отображает эффективную информацию о конкретном пользователе. Для `id root` вывод может быть таким: `uid=0(root) gid=0(root) groups=0(root)`.
  + Отображение только эффективный `UID` пользователя: `id -u` или для конкретного пользователя: `id -u username`
  + Отображение только эффективный `GID` пользователя: `id -g` или для конкретного пользователя: `id -g username`
  + Отображение всех эффективных групп, к которым принадлежит пользователь: `id -G` или для конкретного пользователя: `id -G username`
  + Отображение имен вместо числовых идентификаторов: `id -n`, например, `id -nu` покажет имя пользователя
  + Отображения реальных идентификаторов пользователя и группы, а не эффективных: `-r`. Например, `id -r -u username` покажет реальный идентификатор пользователя.
    + Реальный идентификатор пользователя (Real User ID, RUID): Это идентификатор пользователя, который запустил процесс. Он обычно остается постоянным на протяжении всего времени выполнения процесса и используется для определения владельца процесса.
    + Реальный идентификатор группы (Real Group ID, RGID): Это идентификатор группы, к которой принадлежит пользователь, запустивший процесс. Как и реальный идентификатор пользователя, он остается постоянным на протяжении всего времени выполнения процесса.
    + Эффективный идентификатор пользователя (Effective User ID, EUID): Эффективный UID может отличаться от реального UID, если с помощью `setuid` были изменены права доступа для выполнения определенных операций. Здесь `sudo chown root:root example` `sudo chmod u+s example` на исполняемый файл (`example`) был установлен бит `setuid` чтобы он выполнялся с правами владельца файла (`root`), а не с правами пользователя, который его запускает. Теперь если любой пользователь запустит команду `id` в процессе, запущенном файлом с `setuid`, то получит `EUID` (эффективный идентификатор пользователя) соответствующий `root` (`ID root`). Это позволяет выполнять критически важные операции, требующие повышенных прав доступа, без необходимости предоставлять пользователям постоянные права суперпользователя. Однако нужно быть осторожным с использованием `setuid`, так как это может создать уязвимости в безопасности.
    + Эффективный идентификатор группы (Effective Group ID, EGID): Это идентификатор группы, который используется системой для проверки прав доступа. Эффективный GID может отличаться от реального GID, если процесс был запущен с использованием `setgid`.
+ `rm [ПАРАМЕТР]… [ФАЙЛ]…`	-	используется для удаления файлов и директорий. Дополнительные опции:
  +	`-i, --interactive`: Запрашивать подтверждение перед удалением каждого файла.
  + `-f, --force`: Принудительно удалить файлы без запроса подтверждения. Игнорирует несуществующие файлы и не выводит сообщений об ошибках. При одновременном использовании с `-i` во избежание конфликта Linux дает `-f` более высокий приоритет
  +	`-v, --verbose`: Выводить подробную информацию о процессе удаления.
  +	`-r`:	рекурсивное удаление файла или директории:
    + `rm -r папка`: Команда будет рекурсивно удалять файлы и поддиректории. Если файлы или директории защищены от записи или установлены определенные ограничения, команда будет запрашивать подтверждение перед удалением каждого такого элемента. !!! `rm` по умолчанию не удаляет директории без рекурсивного флага `-r`
    + `rm -r -i папка`: Команда будет всегда запрашивать подтверждение перед удалением каждого файла или директории, независимо от их статуса (защищены от записи или нет).
    + `rm -r -f папка`: Команда будет принудительно и рекурсивно удалять файлы и поддиректории без запросов подтверждения, даже если они защищены от записи или установлены определенные ограничения.
+ `cd`	-	сменить текущую рабочую директорию на заданную: `cd /etc`
+ `touch ~/chown.me`	-	используется для обновления временных меток файла. Временные метки включают: 
  + время доступа (`atime`): когда файл был последним раз прочитан
  + время модификации (`mtime`): когда содержимое файла было последним раз изменено
  + время изменения (`ctime`): когда метаданные файла (например, права доступа или владелец) были последним раз изменены. 
  + если файл (здесь - `chown.me`) не существует, `touch` создает его. 
  + если файл уже существует, `touch` обновляет его временные метки `atime` и `mtime`, но не изменяет его содержимое
+ `pwd`	-	используется для вывода текущей рабочей директории
  + `pwd` покажет полный путь к текущей директории, например: `/home/user`
  + `pwd -P` : что если вы находитесь в каталоге, который является символической ссылкой, команда `pwd -P` покажет путь к реальному каталогу, на который указывает символическая ссылка
  + `pwd -L` : (по умолчанию). Это путь, который вы видите в командной строке, и он может отличаться от физического пути, если вы перешли в каталог через символическую ссылку.
+ `ls`	-	показывает информацию про заданный объект файловой системы (файл, директорию), а также про содержимое заданной директории
  +	`ls -l /путь/к/директории`	-	вывод содержимого указанной директории в длинном формате 
  +	`ls -l -d`	-	вывод информации о текущей директории (`ls -l -d .`) или прямо указанных директориях (`ls -l -d dir1 dir2`) в длинном формате, не перечисляя содержимое этих директорий 
  +	`ls -la`	-	вывод информации о содержимом директории в длинном формате, включая скрытые файлы (чьи имена начинаются с точки .)
  +	`ls –lih /путь/к/директории`	-	вывод информации о содержимом директории в длинном формате с дополнительной информацией:
	  +	`l`: длинный формат, включающий подробную информацию о каждом файле или директории.
	  +	`i`: отображение номера индекса (`inode`) каждого файла или директории.
	  +	`h`: форматирование размеров файлов в читаемом виде (человеческий формат), используя такие единицы измерения, как K, M, G и т.д
  + `ls -lF /путь/к/директории` -  опция `-F` при выводе результата выделяет исполняемые файлы, добавляя `*`
  + `ls -lL /путь/к/директории` -  опция `-L` при выводе результата заставляет `ls` отображать информацию о файлах или каталогах, на которые указывают символические ссылки, а не самих символических ссылок
+ `cat`	-	используется для отображения содержимого файлов, объединения файлов и вывода их содержимого на стандартный вывод (обычно это экран).
  + `cat {one,two,three}/one.txt`	-	используется для отображения содержимого файла one.txt из каждой из трех директорий: one, two и three.
+ `cp`	-	используется для копирования файлов и директорий
  + Копирование файла: `cp source_file destination_file`. Если файл `destination_file` уже существует, его содержимое будет заменено содержимым файла `source_file`. Если файл `destination_file` не существует, он будет создан с содержимым файла `source_file`
  + Копирование файла в другой каталог: `cp file.txt /path/to/directory/`. Если там такой файл уже есть, то молча перепишет его, если у пользователя, инициировавшего копирование, хватает прав, а если нет - то могут быть дополнительные запросы на подтверждение
  + Копирование каталога рекурсивно *вариант 1*: `cp -r source_directory /path/to/directory/`. В результате в каталоге `/path/to/directory/` появится каталог `source_directory` со всем содержимым
  + Копирование каталога рекурсивно *вариант 2*: `cp -r source_directory/* /path/to/directory/`. В результате в каталоге `/path/to/directory/` появится только содержимое каталога `source_directory`
  + Интерактивное копирование с подтверждением перезаписи: `cp -i file.txt /path/to/directory/`
  + Копирование с сохранением атрибутов файла (прав доступа, временных меток и других): `cp -p file.txt /path/to/directory/`
  + Копирование директории с сохранением атрибутов всех файлов и поддиректорий: `cp -pr source_directory /path/to/directory/`
  + Архивное копирование: включает в себя рекурсивное копирование и сохранение всех атрибутов (аналогично -p плюс дополнительные функции): `cp -a source_directory /path/to/directory/`
  + Копирование с подробным выводом: `cp -v file.txt /path/to/directory/`
  + Принудительное копирование без дополнительных запрос на подтверждения действий, переписывая целевой файл, если необходимо: `cp -f file.txt /path/to/directory/`
  + Копирование только если источник новее, чем целевой файл: `cp -u file.txt /path/to/directory/`
+ `mv`	-	используется для перемещения файлов и директорий или переименования файлов
  + `mv folderA/*.log folderB/`	-	перемещает все файлы с расширением .log из директории folderA в директорию folderB.
  + Переименование файла: `mv old_name.txt new_name.txt`
  + Перемещение каталога: `mv source_directory /path/to/destination/` (флаг рекурсивного перемещения как для команд `cp`, `rm`, - не нужен)
  + Переименование каталога `old_directory` в `new_directory`, если каталога `new_directory` не существует: `mv old_directory new_directory`. Если существует, то перенесет `old_directory` со всем содержимым в `new_directory`
  + Интерактивное перемещение с подтверждением перезаписи: `mv -i file.txt /path/to/destination/`
  + Принудительное перемещение, удаляя целевой файл (файл или директория, куда перемещается исходный файл или директория), если необходимо: `mv -f file.txt /path/to/destination/`
  + Перемещение с подробным выводом: `mv -v file.txt /path/to/destination/`
  + Перемещение нескольких файлов в каталог: `mv file1.txt file2.txt /path/to/destination/`
+ `stat`	-	используется для вывода информации о файле или файловой системе. Эта команда показывает различные атрибуты файла, такие как права доступа, время последнего доступа, изменения и модификации, а также номер `inode` и другие метаданные: 
  + Отображение информации о файле: `stat filename`

  ```console
    File: filename
    Size: 1024       Blocks: 8          IO Block: 4096   regular file
  Device: 803h/2051d Inode: 123456      Links: 1
  Access: (0644/-rw-r--r--)  Uid: ( 1000/ username)   Gid: ( 1000/ groupname)
  Access: 2024-11-10 21:41:00.000000000 +0000
  Modify: 2024-11-10 21:41:00.000000000 +0000
  Change: 2024-11-10 21:41:00.000000000 +0000
  Birth: -

  ```

  + Отображение информации о символической ссылке (команда покажет информацию о файле, на который указывает символическая ссылка. Здесь это `symlink`): `stat -L symlink`

  ```console
    File: symlink -> target_file
    Size: 10        Blocks: 0          IO Block: 4096   symbolic link
  Device: 803h/2051d Inode: 789012      Links: 1
  Access: (0777/lrwxrwxrwx)  Uid: ( 1000/ username)   Gid: ( 1000/  groupname)
  Access: 2024-11-10 21:41:00.000000000 +0000
  Modify: 2024-11-10 21:41:00.000000000 +0000
  Change: 2024-11-10 21:41:00.000000000 +0000
  Birth: -
  ```


  + Отображение информации в формате printf (команда выведет размер файла, права доступа, имя владельца и группы в одной строке): 
    + `stat --printf="%s %A %U %G\n" filename` выведет: `1024 -rw-r--r-- username groupname`
  + Отображение информации о файловой системе (команда покажет информацию о файловой системе, на которой находится файл): `stat -f filename`

  ```console
    File: "filename"
      ID: 100000000000 Namelen: 255     Type: ext4
  Block size: 4096       Fundamental block size: 4096
  Blocks: Total: 1000000   Free: 500000    Available: 480000
  Inodes: Total: 250000    Free: 200000
  ```
  + Отображение информации в кратком формате (команда выведет имя файла и его размер в байтах): 
    + `stat -c "%n: %s bytes" filename` выведет: `filename: 1024 bytes`
+ `mkdir`	-	используется для создания новых директорий
  + `mkdir directory_name`	-	создаст директорию с указанным именем 
  + `mkdir -p /path/to/new/directory`	-	создаст директорию /path/to/new/directory, создав все несуществующие родительские директории по пути. Флаг `-p` используется для создания родительских директорий, если они не существуют.
  + `mkdir -p /tmp/symlinks/{one,two}`	-	создает две директории в директории /tmp/symlinks: one и two. Флаг `-p` используется для создания родительских директорий, если они не существуют.
+ `tree`	-	используется для отображения древовидной структуры файлов и директорий, начиная с указанной директории
+ `find` - инструмент для поиска файлов и директорий в файловой системе на основе различных критериев: `find [путь] [условия] [действия]` <a id="findlnx"></a>
  + `путь`: Указывает начальную директорию, с которой начнется поиск (по умолчанию - текущая директория)
  + `условия`: Определяют критерии поиска (имя файла, размер, время изменения и т.д.)
  + `действия`: Указывают, какие действия должны быть выполнены для найденных файлов (удаление, вывод имени и т.д.).
  + Примеры использования:
    + Поиск файлов по имени `find /path/to/search -name "filename"`
    + Поиск файлов по шаблону `find /path/to/search -name "*.txt"` - Найти все файлы с расширением .txt в директории /path/to/search
    + Поиск файлов по размеру `find /path/to/search -size +1M` - Найти все файлы размером больше 1 мегабайта в директории /path/to/search
    + Поиск файлов по дате изменения `find /path/to/search -mtime -7` - Найти все файлы, измененные за последние 7 дней, в директории /path/to/search
    + Поиск и выполнение действия `find /path/to/search -name "*.log" -exec rm {} \;`
      + `-exec`: Указывает, что для **каждого** найденного файла должна быть выполнена определённая команда.
      + `rm`: Указывает команду для выполнения (в данном случае команда rm для удаления файлов).
      + `{}`: Специальный **плейсхолдер**, который будет заменён именем каждого найденного файла
      + `\;`: Обозначает конец команды `-exec`, ставить `\;` - **ОБЯЗАТЕЛЬНО**
    + Поиск файлов с определенными правами доступа
      + `find /path/to/search -perm 644` - Найти все файлы с правами доступа `644` в директории `/path/to/search`
      + `find directory -type f -perm -u=x -exec chmod g+x {} \;` - Найти в директории `directory` все файлы, которые может выполнить владелец-`user` и добавить им право быть выполненными от имени владельца-`group` 
        + `-perm -mode`: Найти файлы, у которых установлены все указанные права.
        + `-perm /mode`: Найти файлы, у которых установлены хотя бы одно из указанных прав.
        + `-perm +mode`: Это устаревший синтаксис, замененный на `/mode`.
      + `find directory -type f \( -perm -u=x -o -perm -g=x \) -exec chmod g+x {} \;` - поиск в директории `directory` только файлов (тип файла `f`), у которых установлен бит выполнения для владельца (`-perm -u=x`) или (`-o`: логический оператор ИЛИ) файлы, у которых установлен бит выполнения для группы (`-perm -g=x`). 
        + скобки `\(...\)` используются для группировки условий.
    + Полезные флаги и параметры:
      + `-type`: Указывает тип файла (например, `-type f` для обычных файлов, `-type d` для директорий, `-type l` для символических ссылок).
      + `-iname`: Игнорирует регистр при поиске имени файла.
      + `-maxdepth`: Ограничивает глубину рекурсивного поиска.
      + `-mindepth`: Указывает минимальную глубину поиска.
      + `-inum`: используется для поиска файлов по их `inode` номеру

## Символические ссылки (symlinks)
1. Символическая ссылка - это специальный тип файла, который указывает на другой файл или директорию. Она хранит путь к целевому файлу. У символической ссылки и исходного файла разные `inode`
2. Символические ссылки могут указывать как на файлы, так и на директории.
3. Символические ссылки могут указывать на файлы в других файловых системах или разделах.
4. Если исходный файл удален, символическая ссылка становится "битой", то есть ссылается на несуществующий файл.
5. Команда создания:
   1. `ln опции файл_источник файл_ссылки` - команда для создания ссылок на файлы:
      1. `ln -s source softlink`	-	создает символическую ссылку на файл или директорию с именем softlink, указывающую на исходный файл или директорию source.
         1. `-s`: Этот флаг указывает, что нужно создать символическую ссылку (**soft link**), а не жесткую ссылку (**hard link**).
         2. `source`: Это исходный файл или директория, на который будет указывать символическая ссылка.
         3. `softlink`: Это имя, которое вы хотите дать вашей символической ссылке.
      2. `ln -sf three/one.txt two/one.txt`	-	создает символическую ссылку на файл one.txt в директории three, и делает эту ссылку вместо уже существующего файла one.txt в директории two, если он существует. Вот что означают использованные опции
         1. `-s`: Создание символической ссылки.
         2. `-f`: Принудительное создание символической ссылки, игнорируя ошибки, если файл не существует или ссылка two/one.txt уже существует и нужно её перезаписать.
### Пример поиска  в системе *жёстких ссылок* заданного файла: 
`find / -inum $(stat -c %i /path/to/file)` Здесь:
  + `stat -c %i /path/to/file`: Эта часть команды выводит `inode` заданного файла. Параметр `-c %i` указывает `stat` вывести только значение `inode` файла.
  + `$(...)`: Это командная подстановка, которая позволяет использовать результат выполнения команды внутри другой команды. В данном случае, результатом будет значение `inode` файла.
  + `find / -inum <inode>`: Команда `find` ищет файлы по всей файловой системе (`/`) с указанным `inode` (`-inum <inode>`). Поскольку `<inode>` заменяется результатом команды `stat`, `find` ищет все файлы с тем же `inode`, что и у указанного файла.
## Жесткие ссылки (hard links)
1. Жесткая ссылка является дополнительной ссылкой на уже существующий файл, и обе ссылки указывают на один и тот же `inode`.
2. Жесткие ссылки могут быть созданы только для файлов, не для директорий.
3. Жесткие ссылки могут быть созданы только в рамках одной файловой системы.
4. Удаление исходного файла не повлияет на жесткую ссылку, потому что данные по-прежнему доступны через другую ссылку (из-за того, что `inode` один и тот же).
5. Команда создания: `ln target_file hardlink_name`



