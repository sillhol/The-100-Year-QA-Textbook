# 06 Команды ОС Linux и файловая система

## Простая команда UNIX с аргументами выглядит следующим образом:
команда [опции] [другие параметры], (Квадратные скобки […] означают, что аргумент необязателен.)

![сиснтаксис команды](resources/image.png)
- Каждая конкретная команда предназначена для выполнения только одной операции. Команда egrep служит для поиска указанных последовательностей символов в файлах и директориях, также указанных с помощью аргументов. Другие команды могут, например, показывать сведения об ОС или содержимое директории
- Опции указывают, как именно нужно выполнить эту операцию. В показанном выше примере опция -i означает, что поиск должен быть нечувствительным к регистру букв; опция -r — поиск в директориях (не только в отдельных файлах); опция -l — выводить только названия файлов (без найденных строк файлов).
- "Позиционные аргументы" определяют, какие именно объекты будут затронуты, например, подстроки, входные файлы или директории, и т.д.
- Опции и позиционные аргументы вместе именуются "аргументами", т.е. это все, что следует за названием команды.
- Порядок опций неважен. Например, последовательность -l -a эквивалентна -a -l. Это справедливо и для длинных опций.
- Если вы работаете только с короткими опциями без значений, такими как -l и -a, то можете их соединить, упустив пробелы: -la или -al.
- **название_команды** --help: выводит встроенную справку для команды; эта опция работает почти для всех команд.
- man **название_команды**: выводит соответствующее команде подробное руководство, если оно установлено в системе. Мы будем изучать команду man позже, в рамках практического раздела.
- Не меняйте местами опции и параметры, указывающие месторасположение.
- Пробелы между названием команды, секцией опций и секцией с дальнейшими аргументами обязательны
- В мире UNIX всё является чувствительным к регистру букв. Включая названия файлов, команд, опций и имена пользователей
## Файловая система ОС Linux и объекты
Путь каждого объекта начинается с '/'. Этот элемент называется «корнем» (root), а вся файловая система подобна дереву.
### Стандарт FHS
+ ```/etc```	-	файлы конфигурации для большинства приложений и некоторых частей ОС
+ ```/home```	-	используется для хранения домашних директорий пользователей, например /home/ваше_имя_пользователя
+ ```/root```	-	домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС)
+ ```/bin```	-	большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория ```/bin``` часто служит так называемой символьной ссылкой на директорию ```/usr/bin```. Любая операция, затрагивающая ```/bin/something``` будет фактически выполняться на ```/usr/bin/something```
+ ```/boot```	-	загрузочные файлы (в том числе файлы загрузчика, ядро, initrd, System.map). Часто выносится на отдельный раздел
+ ```/dev```	-	Основные файлы устройств (```/dev/null```, ```/dev/sd буква``` — жёсткий диск, ```/dev/sd буква номер``` (раздел диска), ```/dev/sr номер``` (CD-ROM), ```/dev/eth номер``` (сетевые интерфейсы Ethernet), ```/dev/wlan номер``` (сетевые интерфейсы) и др)
+ ```/sbin```	-	похож на /bin, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root
+ ```/tmp```	-	временные файлы ОС и приложений (аналог C:\Temp в ОС Windows)
+ ```/var```	-	содержит различные файлы с кэшем системы, файлы журналов и файлы баз данных (если сервер БД установлен). Директория ```/var/log``` хранит файлы журналов системы и большинства приложений
+ ```/usr``` (```/usr/bin```, ```/usr/lib```)	-	в настоящее время это главное место для приложений (исключая настройки, хранящиеся в ```/etc```). Например: /usr/bin содержит исполняемые файлы, /usr/lib — разделяемые библиотеки и т. д.
### Абсолютный и относительный пути
+ Абсолютный путь начинается с '/' и включает все промежуточные директории, в которых расположен объект
+ Относительный путь к объекту строго зависит от текущей рабочей директории. Более того, он начинается не со знака '/', а с вашей текущей рабочей директории

Работу с объектами файловой системы можно ускорить с помощью полезных конструкций: '..', '.' (одна точка означает текущую директорию) и '~' (означает вашу домашнюю директорию).
### Основные команды для работы с файловой системой
+ ```uname```	-	Выводит название ОС
	```uname -a``` ИЛИ ```/bin/uname -a``` - Выводит данные о текущем ядре операционной системы и некоторых других системных характеристиках
	```uname -r``` -  выводит только версию ядра операционной системы
+ ```date```	-	показывает текущие дату и время.
+ ```mount```
+ ```sleep 1000```
+ ```time command```
+ ```id``` - Выводит сведения о текущем пользователе. Пример результата:
	```uid=0(root) gid=0(root)```
+ ```rm [ПАРАМЕТР]… [ФАЙЛ]…```	-	используется для удаления файлов и директорий. Дополнительные опции:
  + ```-f, --force```: Принудительно удалить файлы без запроса подтверждения.
  +	```-i, --interactive```: Запрашивать подтверждение перед удалением каждого файла.
  +	```-v, --verbose```: Выводить подробную информацию о процессе удаления.
  +	```rm -f -r ФАЙЛ```	-	используется для принудительного и рекурсивного удаления файла или директории 
+ ```cd```	-	сменить текущую рабочую директорию на заданную:
  +	```cd /etc```
+ ```touch ~/chown.me```	-	используется для обновления временных меток файла. Если файл (здесь - chown.me) не существует, touch создает его. Если файл уже существует, touch обновляет его временную метку, но не изменяет его содержимое
+ ```pwd```	-	используется для вывода текущей рабочей директории
+ ```ls```	-	показывает содержимое текущей директории
  +	```ls -l /путь/к/директории```	-	вывод содержимого указанной директории в длинном формате 
  +	```ls -l -d```	-	вывод информации о текущей директории (```ls -l -d .```) или прямо указанных директориях (```ls -l -d dir1 dir2```) в длинном формате, не перечисляя содержимое этих директорий 
  +	```ls -la```	-	вывод информации о содержимом директории в длинном формате, включая скрытые файлы (те, чьи имена начинаются с точки .)
  +	```ls –lih /путь/к/директории```	-	вывод информации о содержимом директории в длинном формате с дополнительной информацией:
	  +	```l```: длинный формат, включающий подробную информацию о каждом файле или директории.
	  +	```i```: отображение номера индекса (inode) каждого файла или директории.
	  +	```h```: форматирование размеров файлов в читаемом виде (человеческий формат), используя такие единицы измерения, как K, M, G и т.д
  + ```ls -lF /путь/к/директории``` -  опция "-F" команды "ls" при выводе результата выделяет исполняемые файлы, добавляя "*"
  + ```ls -lL /путь/к/директории``` -  опция "-L" команды "ls" при выводе результата заставляет ls отображать информацию о файлах или каталогах, на которые указывают символические ссылки, а не самих символических ссылок
+ ```cat```	-	используется для отображения содержимого файлов, объединения файлов и вывода их содержимого на стандартный вывод (обычно это экран).
  + ```cat {one,two,three}/one.txt```	-	используется для отображения содержимого файла one.txt из каждой из трех директорий: one, two и three.
+ ```cp```	-	используется для копирования файлов и директорий
+ ```mv```	-	используется для перемещения файлов и директорий или переименования файлов
  + ```mv folderA/*.log folderB/```	-	перемещает все файлы с расширением .log из директории folderA в директорию folderB.
+ ```stat```	-	используется для вывода информации о файле или файловой системе. Эта команда показывает различные атрибуты файла, такие как права доступа, время последнего доступа, изменения и модификации, а также номер inode и другие метаданные
  + ```stat /tmp```
+ ```grep```	-	используется для поиска строк в текстовых файлах или стандартном вводе, которые соответствуют заданному шаблону. Поиск осуществляется либо имходя из Basic Regular Expressions (```grep "pattern" filename.txt```) либо Extended Regular Expressions (```grep -E "regex_pattern" filename.txt```):
  + ```grep "pattern" filename.txt``` -	найдет все строки в файле filename.txt, содержащие подстроку pattern.
  + ```grep -E "regex_pattern" filename.txt```	-	выполнит поиск в файле filename.txt, используя расширенные регулярные выражения
  + ```grep "pattern" file1.txt file2.txt```	-	выполнит поиск подстроки pattern в файлах file1.txt и file2.txt.
  + ```grep -r "pattern" directory/```	-	выполнит рекурсивный поиск подстроки pattern во всех файлах внутри указанной директории directory
+ ```mkdir```	-	используется для создания новых директорий (папок)
  + ```mkdir directory_name```	-	создаст директорию с указанным именем 
  + ```mkdir -p /path/to/new/directory```	-	создаст директорию /path/to/new/directory, создав все несуществующие родительские директории по пути. Флаг -p используется для создания родительских директорий, если они не существуют.
  + ```mkdir -p /tmp/symlinks/{one,two}```	-	создает две директории в директории /tmp/symlinks: one и two. Флаг -p используется для создания родительских директорий, если они не существуют.
+ ```tree```	-	используется для отображения древовидной структуры файлов и директорий, начиная с указанной директории
## Символические ссылки
+ ```ln опции файл_источник файл_ссылки``` - команда для создания ссылок на файлы: 
  + ```ln -s source softlink```	-	создает символическую ссылку на файл или директорию с именем softlink, указывающую на исходный файл или директорию source.
  + ```-s```: Этот флаг указывает, что нужно создать символическую ссылку (soft link), а не жесткую ссылку (hard link).
  + ```source```: Это исходный файл или директория, на который будет указывать символическая ссылка.
  + ```softlink```: Это имя, которое вы хотите дать вашей символической ссылке.
+ ```ln -srf three/one.txt two/one.txt```	-	создает символическую ссылку на файл one.txt в директории three, и делает эту ссылку вместо уже существующего файла one.txt в директории two, если он существует. Вот что означают использованные опции
  + ```-s```: Создание символической ссылки.
  + ```-r```: Создание символических ссылок с относительными путями, что особенно полезно при перемещении каталогов, чтобы ссылки продолжали указывать на правильные файлы.
  + ```-f```: Принудительное создание символической ссылки, игнорируя ошибки, если файл не существует или ссылка не удалась.

