# 08 Linux - пользователи, группы и права доступа к файлам в Linux
1. Процессы - это экземпляры программ, выполняющиеся в данный момент;
2. Сервисы - это сущности, служащие для упрощения управления системой (централизованного управления запуском, остановкой и перезапуском процессов, автоматического восстановления работы служб в случае сбоев, запуска процессов по требованию, автоматизации запуска задач по расписанию или автоматизации реакции на события (например, запуск служб при подключении устройства), управление зависимостями, мониторинг и логирование)
## Понятия пользователей и групп Linux
### Учетные записи ОС
+ **Стандартные учетные записи** (создаются для обычных пользователей):
	+  могут входить в систему
	+  могут выполнять команды
	+  могут читать некоторые файлы или директории
	+  не могут изменять любую часть ОС
	+  не могут изменять любую часть "общесистемных" приложений
	+  по умолчанию могут изменять данные только в своих домашних директориях и `/tmp`.
+ **Административная учетная запись**: ее имя - `root`, и она является единственным администратором ОС (не может быть двух `root`). 
  + Учетная запись `root` используется для прямого входа в систему очень редко; вместо этого администраторы временно повышают свои привилегии до `root` для обслуживания системы и других важных операций.
  + Административная учетная запись `root` может входить в систему и делать все с ОС и пользователями без каких-либо ограничений (в отличие от Windows)
+ **Служебные учетные записи**:
  + не должны использоваться пользователями;
  + не могут входить в систему;
  + используются для специальных целей ОС, службами и приложениями (запускаемые `root`). Например, при старте системы или вручную через команду `sudo systemctl start mysql`, системный менеджер служб (например, `systemd`) запускает от имени **служебной учетной записи** mysql службу MySQL. Это минимизирует возможные последствия в случае сбоя или взлома приложения. 
### Основные настройки учетной записи
#### ```/etc/passwd```
```/etc/passwd``` - это основной конфигурационный файл для учетных записей пользователей, который используется, когда:
+ Пользователь входит в систему по SSH, FTP и другим средствам/протоколам.
+ ОС или любая программа требует, чтобы имя пользователя было сопоставлено с числовым UID (см. ниже) или наоборот.

```egrep "${USER}" /etc/passwd``` - пример получения информации про свою учетную запись, где: 
+ ```${}``` - специальный синтаксис для обращения к переменным в командной оболочке, позволяющий обращаться к значению переменной по ее имени. Фигурные скобки используются для явного выделения границ имени переменной (это может быть полезно, когда имя переменной непосредственно прилегает к другим символам или тексту, чтобы избежать неоднозначности)
+ ```USER``` - это имя переменной. В случае переменной ```${USER}``` это стандартная переменная окружения, которая обычно содержит имя текущего пользователя.

Файл ```/etc/passwd``` в качестве разделителя полей использует ':' и содержит данные про:
+ имя пользователя (должно быть уникальным)
+ x - поле не используется, поэтому мы имеем здесь 'x' как заглушку
+ идентификатор пользователя, называемый "UID", должен быть уникальным. Пользователи в основном имеют UID >= 1000. Пользователь root всегда имеет UID 0. Учетные записи служб имеют UID от 1 до (в основном) 999. Никто, кроме root, не должен иметь UID 0.
+ идентификатор основной группы. Каждый пользователь должен быть членом хотя бы одной группы (не существует пользователей "без групп"). Если пользователей нужно включить в большее количество групп, это настраивается в ```/etc/group``` .
+ описание пользователя. Это поле может быть пустым или содержать что угодно, кроме ':'. Оно не играет никакой роли в ОС и механизмах входа в систему.
+ домашний каталог пользователя, куда он автоматически помещается после успешного входа в систему
+ программа, выполняемая при успешном входе в систему (например, ```/bin/bash```). Сервисные учетные записи не предназначены для входа в систему и работы в командной строке, поэтому у них здесь указаны специальные "псевдо" программы, такие как ```/bin/false``` или ```/sbin/nologin```
#### ```/etc/shadow```
+ Хеши паролей хранятся в файле ```/etc/shadow```, доступ к которому имеет только root. Эти особые разрешения ```/etc/shadow``` используются для того, чтобы избежать атак методом перебора.
+ файл ```/etc/shadow``` также содержит все настройки паролей учетных записей ОС, например, когда пароль должен быть изменен и т.д.
#### Заметки по безопасности/стабильности
+ Только root может изменять ```/etc/passwd``` - иначе хакеры могут повысить привилегии, создав "фальшивого рута" с UID 0.
+ Любой пользователь или приложение должны иметь доступ на чтение к файлу ```/etc/passwd``` - иначе ОС становится нестабильной.
+ доступ к файлу ```/etc/shadow``` имеет только root.
## Группы ОС
+ Группы включают несколько (0 или более) пользователей для упрощения управления пользователями и разделения привилегий
+ Каждый пользователь должен быть членом как минимум одной группы - она задается в ```/etc/passwd```, такая группа называется "основной" для конкретного пользователя
+ Каждый пользователь может быть включен в 0 или более дополнительных групп, называемых "вторичными группами" (secondary groups). Членство во вторичных группах настраивается в файле ```/etc/group```.
+ Нет никакой разницы (в плане привилегий) между членством в первичной и вторичной группах, например: если ваш пользователь входит в группу "qa" и группу "users", вы можете читать файлы, доступные как группам "qa", так и "users".
+ Группы полезны для назначения разрешений на доступ к файлам и других привилегий или ограничений, например:
	+ кто может читать/писать/исполнять файл
	+ кто может войти в систему через SSH
	+ кто и как может использовать инструменты "sudo" или "su"
	+ кто может читать журналы общесистемных служб с помощью инструмента "journalctl"
	+ сколько процессора/памяти/дискового пространства может быть израсходовано
+ Имена групп чувствительны к регистру.
+ В отличие от Windows, в UNIX нет группы "Администраторы".
+ В большинстве систем членство в группе "root" не дает многих привилегий, в отличие от статуса пользователя "root".
+ Могут существовать специальные группы с дополнительными привилегиями, это сильно зависит от настроек вашей ОС. Например, группы "sudo" или "wheel" могут иметь (а могут и не иметь) неограниченные права на выполнение любых команд от имени root через "sudo"
### Добавление в группу (Linux)
На Debian (и других дистрибутивах Linux) для добавления пользователя в группу обычно используется команда usermod:

```sudo usermod -aG имя_группы имя_пользователя```, где:
+ sudo: Это команда для выполнения следующей команды с правами суперпользователя (если ваш пользователь не имеет достаточных привилегий для выполнения этой операции);
+ usermod: Это команда для изменения параметров пользователя;
+ -aG: Это опция usermod, которая добавляет пользователя в указанную группу, не удаляя его из других групп, к которым он уже может принадлежать. -a означает "добавить", а -G указывает группу;
+ имя_группы: Это имя группы, в которую вы хотите добавить пользователя;
+ имя_пользователя: Это имя пользователя, который будет добавлен в указанную группу.
### Основные настройки групп: ```/etc/group```
```/etc/group``` - основной конфигурационный файл для групп UNIX и используется, когда:
+ ОС или какой-либо программе требуется преобразовать имя группы в числовой GID (см. ниже) или наоборот.
+ Пользователь пытается сделать что-то, что может быть ограничено или разрешено функциями управления группами (например, чтение файла)
+ [опционально, если службы входа настроены таким образом] Пользователь входит в систему (SSH, FTP, другие протоколы).
Файл ```/etc/group``` содержит Название группы, Идентификатор группы, называемый "GID" (должен быть уникальным), Список членов группы, разделенный запятыми (может быть пустым)

Членство в группе вычисляется как совокупность вхождения пользователя в файлах ```/etc/passwd``` и ```/etc/group```
### Как вывести информацию о своем пользователе и группе
+ ```whoami```	- Получить имя текущего пользователя
+ ```id```		- Получить расширенную информацию о текущем пользователя и его членстве в группах
    + ```id -u```	- Показать только UID текущего пользователя и ничего больше
    + ```id -G``` - Показать только GID или только имена групп текущего пользователя
+ ```groups```	- получить имена групп
## Повышение привилегий
### "su": Переключить пользователя
Команда ```su``` используется для запуска оболочки от имени другого пользователя (по умолчанию root) после предоставления пароля пользователя. Соответственно, все, что выполняется в этой оболочке, будет выполняться с привилегиями целевого пользователя. Чтобы вернуться к предыдущему пользователю, выполните команду "exit".

Эта команда часто используется системными администраторами, которые входят в систему как обычные пользователи, а затем переключаются на учетную запись root. Она может использоваться во время развертывания или настройки тестовых сред; но помните, что для этого случая требуется знание пароля root, например:
1. ```su - sutest``` - Запустить оболочку от имени пользователя "sutest"
   + Опция - (или -l) указывает su использовать логин-сессии, что означает:
     + смену на домашний каталог целевого пользователя и использование его окружения - переключается в домашний каталог целевого пользователя. В примере — /home/**sutest**
     + Переменные окружения (HOME, USER, LOGNAME, SHELL, PATH и другие) устанавливаются так, как если бы целевой пользователь выполнил вход в систему
     + Переменная PATH обновляется, чтобы включать пути, специфичные для целевого пользователя, что обеспечивает доступ ко всем необходимым системным утилитам
     + Загружаются и выполняются файлы конфигурации оболочки целевого пользователя, такие как ```.profile```, ```.bash_profile```, ```.bashrc``` и другие, если они существуют
2. ```su - -c "id -u; whoami"``` - выполнение команды (или нескольких команд) от имени root, без запуска полнофункционального сеанса оболочки root:
   + Команда su используется для смены пользователя. По умолчанию она переключает на пользователя root.
   + Опция - (или -l) указывает su использовать логин-сессии (здесь - root)
   + Опция -c указывает su выполнить команду, заключенную в кавычки, вместо запуска интерактивной оболочки. (в примере команда ```id -u``` выводит числовой идентификатор (UID) текущего пользователя, а команда ```whoami``` выводит имя текущего пользователя.
  
**Примечания**
+ Пользователь "root" может переключаться на любого другого без ввода пароля цели.
+ Лучше использовать "su -" вместо "su", так как ключ "-" загружает все окружение оболочки целевого пользователя.
### "sudo": Substitute User Do
Инструмент ```sudo``` используется для запуска команды от имени другого пользователя (по умолчанию root) после предоставления пароля (собственного пароля пользователя, а не того, от имени которого вызывают команду). ```sudo``` предназначен для того, чтобы позволить определенным пользователям выполнять определенные команды (и только их, ничего больше!) от имени другого, часто привилегированного, пользователя

```sudo```: 
+ ```sudo -l``` -  Чтобы проверить возможности пользователя
+ ```sudo [-u username] command args``` - чтобы запустить команду
**Примечания**
+ Только пользователь "root" может устанавливать или изменять чьи-либо разрешения sudo - т.е., будучи обычным пользователем, вы можете только перечислить свои собственные настройки sudo (```sudo -l```) и выполнять разрешенные команды в соответствии с настройками
+ Некоторые привилегированные пользователи (например, члены групп "wheel" или "sudo") могут выполнять любые команды от имени root, в выводе "sudo -l" это отображается как (ALL) ALL
+ чтобы предоставить пользователю возмоможность применять sudo администратор (root) добавляет соответствующие записи в файл ```/etc/sudoers```. Для минимизации риска "поломать" файл ```/etc/sudoers``` лучше делать это с помощью редактора ```visudo```, который вызывается: ```sudo visudo```
### sudo VS su: Основные различия
|  | su | sudo |
|----------|----------|----------|
| Основная функциональность  | Предоставление оболочки входа в систему с привилегиями целевого пользователя, по умолчанию root | Выполнение одной команды от имени целевого пользователя, по умолчанию root |
| Основная идея | Работа в полнофункциональной оболочке как root или любой другой пользователь ОС | Делегирование некоторых административных полномочий обычным пользователям |
| Какой пароль вводить | Пароль целевого пользователя | Ваш собственный пароль |
| Необходимые настройки | Возможно, вас нужно будет включить в специальную группу для запуска "su" (если это установлено вашим системным администратором). | Точные команды и даже их аргументы могут быть разрешены в явном виде |
| Настройки безопасности по умолчанию | Любой может выполнить команду "su", требуется только пароль целевого пользователя | Только члены специфической для дистрибутива группы ("wheel" в RHEL-системах, например CentOS, "sudo" в Debian, например Ubuntu) могут использовать sudo. |
## Разрешения на доступ к файлам
### Анатомия вывода "ls"
![Анатомия вывода "ls"](resources/linux_permissions.png)
+ Выше результат команды ```ls -l testfile```, где:
	+ '-' для типичных файлов
	+ 'd' для каталогов
	+ 'l' для символических ссылок
	+ 9 следующих символов, ("rw-r--r--") - это разрешения доступа к файлам UNIX
	+ "Размер файла" имеет смысл только для типичных файлов, ни для каталогов, ни для симлинков.
### Анатомия разрешений на доступ к файлам
![Анатомия разрешений на доступ к файлам](resources/perm.jpg)

Как проверяются и применяются разрешения доступа:
+ Во-первых: является ли пользователь владельцем данного объекта? Если да - проверить, разрешают ли разрешения владельца объекта эту операцию.
+ Если пользователь не является владельцем объекта - является ли он членом группы? Если да - проверить, разрешают ли групповые разрешения объекта эту операцию.
+ Если пользователь не входит в группу - проверить, разрешают ли разрешения других на эту операцию.
### Смысл и формат записи прав доступа
Разрешения доступа к файлам (r, w, x) имеют разные значения для файлов и директорий
| Бит | Значение для файлов | Значение для директорий |
|:-------------|:---------------:|--------------:|
| r - read (чтение)       |Файл может быть прочитан, например, с помощью cat, less, head, других инструментов.        | Список содержимого каталога может быть прочитан: ```ls имя_каталога``` для отображения содержимого каталога, но при этом не будет возможности просматривать содержимое самих файлов или заходить в подкаталоги, если у вас  не установлен бит x        |
| w - write (запись)       | Содержимое файла может быть изменено. Но сам файл не может быть удален - см. 'w' для каталогов.        | Любой элемент этого каталога может быть создан или удален. То есть, даже если вы не являетесь владельцем файла в этом каталоге, вы можете удалить его, установив 'w' для каталога. Но без также установленного бита "x" можно будет добавлять новые файлы в каталог, удалять существующие файлы и переименовывать их только если вы уже находитесь в каталоге (для добавления - обязательно) или имеете прямой путь к файлу (удаление файлов или подкаталогов и переименование файлов или подкаталогов, т.к. команды rm и mv используют полный путь и не требует перехода внутрь каталога).       |
| x - execute (выполнение)       | Файл может быть выполнен. Фактически исполняемые файлы: двоичные файлы и скрипты        | Самый важный бит для каталогов. Вы можете войти в этот каталог (например, с помощью "cd") и получить доступ (чтение, запись, выполнение) ко всему его содержимому, если это разрешено их правами доступа. Если у вас нет 'x' для каталога, вы НЕ можете переходить в подкаталоги, создавать/удалять объекты (файлы, каталоги), читать информацию об объекте (разрешения, владелец, ...)       |
### Команды для изменения разрешений доступа к файлам
+ ```chown [OPTIONS] USER[:GROUP] FILE(s)```: для установки нового владельца и/или группы для объекта
	+ изменить только владельца объекта - может быть выполнена только пользователем root
	+ изменить только группу объекта - может быть выполнена обычным пользователем, но этот пользователь должен быть членом новой группы (иначе требуются привилегии root)
	+ изменить владельца и группу объекта сразу - только для root
	+ ```chown operator:bin ~/chown.me``` - для объекта ~/chown.me устанавливается собственник operator, группа bin. Команда выполняется от имени root
	+ ```chown :users ~/chown.me``` - для объекта ~/chown.me устанавливается группа users. Команда выполняется от члена группы "users"
	+ ```chown -R :users ~``` - используется для изменения группы всех файлов и директорий на users в вашем домашнем каталоге рекурсивно
+ ```chgrp [OPTIONS] GROUP FILE..```: для изменения группы объекта (только если вы являетесь членом новой группы)
    + ```chgrp users ~/chown.me``` - аналогична ```chown :users ~/chown.me```
    + ```chgrp -R users ~``` - поддерживает рекурсивный режим "-R"
+ ```chmod``` (ИЗМЕНИТЬ РЕЖИМ): позволяет установить новые разрешения доступа к файлу. Она позволяет установить точные разрешения сразу на определенный объект - для этого лучше использовать восьмеричную форму и добавить или отозвать права доступа к определенному объекту - это удобнее делать в символьном виде
  + символьный вид: ```chmod [OPTIONS] [ugoa…][-+=]perms…[,…] FILE...```
    + Первый набор флагов ([ugoa...]), флаги пользователей, определяет, для каких классов пользователей изменяются права доступа к файлу.
      + ```u``` - Владелец файла.
      + ```g``` - Пользователи, входящие в группу.
      + ```o``` - Все остальные пользователи.
      + ```a``` - Все пользователи, идентично ugo, например:
        + ```chmod u=rwx,g+w,o-r ~/chmod.me.file``` - Разрешает владельцу делать что угодно с файлом, добавляет права на запись группе и отбирает права на чтение у прочих (others)
        + ```chmod -R go-rwx ~/chmod.me.dir``` - отнимаем все права у группы и прочих (others) рекурсивно для всей директории
    + Второй набор флагов ([-+=]), флаги операций, определяет, будут ли разрешения удалены, добавлены или установлены:
      + '-' Удаляет указанные разрешения.
      + '+' Добавляет указанные разрешения.
      + '=' Изменяет текущие разрешения на указанные. Если после символа = разрешения не указаны, все разрешения указанного класса пользователей будут удалены.
    + Разрешения (perms...) могут быть явно заданы с помощью нуля или одной или нескольких из следующих букв: r, w, x, X, s и t. При копировании разрешений из одного класса пользователей в другой используйте одну букву из набора u, g и o. При установке разрешений для нескольких классов пользователей ([,...]) используйте запятые (без пробелов) для разделения символьных режимов.
  + восьмеричная форма: ```chmod [OPTIONS] NUMBER FILE...```, например:
    + ```chmod 751 ~/chmod.me.dir``` - Установливает "rwxr-x--x", т.е. 751, на указанную директорию
    
## Особые случаи: символические ссылки (symbolic links), sticky bit, SUID, SGID
### Символические ссылки
Символические ссылки всегда имеют разрешения 777, но это ничего не значит, поскольку фактические разрешения доступа такие же, как у целевого объекта:
```console
lrwxrwxrwx. 1 root root 7 янв 1 21:12 /bin -> /usr/bin
dr-xr-xr-x. 2 root root 36864 фев 19 13:31 /usr/bin
```
В примере символическая ссылка /bin ссылается на /usr/bin:
+ Ее содержимое не может быть изменено, она может быть только пересоздана.
+ Только владелец директории (у нас владелец директории '/' это "root") может пересоздать ее.
+ Разрешения доступа к символической ссылке не влияют на разрешения доступа к целевому объекту (в соответствии с  замыслом).
### Sticky bit
Может использоваться для директорий наряду с "обычными" битами доступа rwx. Если он установлен, только владельцы могут удалять свои объекты, независимо от других разрешений  (например, 777 для ```/tmp```). Sticky bit отображается как 't' в конце "слова" разрешения доступа: "drwxrwxrwt".

**sticky bit** имеет числовое значение 1

**sticky bit** очень важен для ```/tmp```, так как благодаря разрешениям 777 каждый может создавать и удалять там что угодно. **Sticky bit** предотвращает анархию, не позволяя удалять чужие данные

**sticky bit** может быть установлен в символьной или восьмеричной форме:
+ chmod +t /some/dir
+ chmod 1xyz /some/dir
### Биты SUID и SGID
Бит SUID (Set User ID) может использоваться для исполняемых файлов. Если он установлен, этот файл всегда будет выполняться от имени владельца. Бит SUID отображается как 's' вместо 'x' в блоке разрешений владельца:
```console
# SUID binaries
[st00@c7-sandbox ~]$ ls -l /bin/passwd /bin/chsh /bin/sudo
-rws--x--x. 1 root root  23880 Feb  2  2021 /bin/chsh
-rwsr-xr-x. 1 root root  27856 Apr  1  2020 /bin/passwd
---s--x--x. 1 root root 151424 Oct 14  2021 /bin/sudo
```
Это полезно, если этот исполняемый файл а) часто используется и б) должен делать что-то с определенными правами пользователя. Например:
+ Исполняемый файл ```/bin/passwd``` предназначен для того, чтобы позволить пользователям изменять свой пароль. Поэтому он должен модифицировать файл ```/etc/shadow```, что требует привилегий root.
+ Исполняемый файл ```/bin/chsh``` предназначен для изменения оболочки входа в систему. Поэтому он модифицирует файл ```/etc/passwd```, который также разрешен только для root.
+ Исполняемый файл ```/bin/sudo``` предназначен для повышения привилегий до "root", поэтому он обязательно должен иметь возможность запускать что-либо от имени root.

Бит SUID имеет восьмеричное значение 4

```console
# SUID bit
chmod u+s /path/to/file
chmod 4xyz /path/to/file
```
### Бит SGID (Set Group ID) 
Бит SGID (Set Group ID) также может быть использован для исполняемых файлов. Если он установлен, этот файл всегда будет выполняться от имени группы владельцев. Бит SGID отображается как 's' вместо 'x' в блоке групповых разрешений, как показано выше для бинарного файла "wall". В отличие от SUID, бит SGID не используется широко:
```console
# SGID binary
[st00@c7-sandbox ~]$ ls -lF /bin/wall
-r-xr-sr-x. 1 root tty 15344 Jun 10  2014 /bin/wall*
```
Бит SGID имеет восьмеричное значение 2

```console
# SGID bit
chmod g+s /path/to/file
chmod 2xyz /path/to/file
```

