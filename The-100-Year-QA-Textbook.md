# 06 Команды ОС Linux и файловая система
## Простая команда UNIX с аргументами выглядит следующим образом:
`команда [опции] [позиционные аргументы]`, (Квадратные скобки […] означают, что аргумент необязателен.)

<img src="resources/image.png" alt="синтаксис команды" width="70%"/>

- `команда` предназначена для выполнения одной операции. Например, `egrep` служит для поиска указанных последовательностей символов в файлах и директориях, также указанных с помощью аргументов. Другие команды могут, например, показывать сведения об ОС или содержимое директории
- `опции` указывают, как именно нужно выполнить эту `команду`. В показанном выше примере опция `-i` означает, что поиск должен быть нечувствительным к регистру букв; опция `-r` — поиск в директориях (не только в отдельных файлах); опция `-l` — выводить только названия файлов (без найденных строк файлов).
- `позиционные аргументы` определяют, какие именно объекты будут затронуты, например, подстроки, входные файлы или директории, и т.д.
- `опции` и `позиционные аргументы` вместе именуются **аргументами**, т.е. это все, что следует за названием команды.
- Порядок `опций` неважен. Например, последовательность `-l -a` эквивалентна `-a -l`. Это справедливо и для длинных опций.
- Если используются только короткие опции без значений, такими как `-l` и `-a`, то можете их соединить, упустив пробелы: `-la` или `-al`.
- `команда --help`: выводит встроенную справку для команды; эта опция работает почти для всех команд.
- `man команда`: выводит соответствующее команде подробное руководство, если оно установлено в системе.
- Не меняйте местами опции и параметры, указывающие месторасположение.
- Пробелы между названием команды, секцией опций и секцией с дальнейшими аргументами обязательны
- В `UNIX` всё регистрозависимо (названия файлов, команд, опций, имена пользователей)
## Файловая система ОС Linux и объекты
Путь каждого объекта начинается с `/`. Этот элемент называется «корнем» (`root`), а вся файловая система подобна дереву.
### Стандарт FHS
+ `/etc`	-	файлы конфигурации для большинства приложений и некоторых частей ОС
+ `/home`	-	используется для хранения домашних директорий пользователей, например `/home/ваше_имя_пользователя`
+ `/root`	-	домашняя директория пользователя root (это единственный пользователь-администратор во всех UNIX-подобных ОС)
+ `/bin`	-	большинство исполняемых файлов (например, программ) хранится здесь. В современных версиях Linux директория `/bin` часто служит так называемой символьной ссылкой на директорию `/usr/bin`. Любая операция, затрагивающая `/bin/something` будет фактически выполняться на `/usr/bin/something`
+ `/boot`	-	загрузочные файлы (в том числе файлы загрузчика, ядро, `initrd`, `System.map`). Часто выносится на отдельный раздел
+ `/dev`	-	Основные файлы устройств (`/dev/null`, `/dev/sd буква` — жёсткий диск, `/dev/sd буква номер` (раздел диска), `/dev/sr номер` (CD-ROM), `/dev/eth номер` (сетевые интерфейсы Ethernet), `/dev/wlan номер` (сетевые интерфейсы) и др)
+ `/sbin`	-	похож на `/bin`, но хранит специальные исполняемые файлы, служащие для конфигурации системы и обычно запускаемые только пользователем root
+ `/tmp`	-	временные файлы ОС и приложений (аналог C:\Temp в ОС Windows)
+ `/var`	-	предназначена для хранения данных, которые часто изменяются: в `/var/cache` находятся временные файлы, которые используются для ускорения работы системы, файлы баз данных (если сервер БД установлен), в директории `/var/log` хранятся системные журналы и логи приложений, в `/var/spool` хранятся данные, ожидающие обработки, такие как задания на печать или электронная почта
+ `/usr` (`/usr/bin`, `/usr/lib`)	-	в настоящее время это главное место для приложений (исключая настройки, хранящиеся в `/etc`). Например: `/usr/bin` содержит исполняемые файлы, `/usr/lib` — разделяемые библиотеки и т. д.
### Абсолютный и относительный пути
+ Абсолютный путь начинается с '/' и включает все промежуточные директории, в которых расположен объект
+ Относительный путь к объекту строго зависит от текущей рабочей директории. Более того, он начинается не со знака '/', а с вашей текущей рабочей директории

Работу с объектами файловой системы можно ускорить с помощью полезных конструкций: '..', '.' (одна точка означает текущую директорию) и '~' (означает вашу домашнюю директорию).
### Основные команды для работы с файловой системой <a id="mainlinuxfscmd"></a>
+ `uname`	-	Выводит название ОС
  + `uname -a` ИЛИ `/bin/uname -a` (all)- Выводит данные о текущем ядре операционной системы и некоторых других системных характеристиках
  + `uname -r` (release)-  выводит только версию ядра операционной системы
+ `date`	-	используется для:
  + Отображения текущей даты и времени: `date` выводит `Пт 30 авг 18:11:01 EEST 2024`
  + Отображения даты и времени в формате UTC: `date -u` выводит `Пт 30 авг 15:11:01 UTC 2024`
  + Установки системной даты и времени (требуются права суперпользователя): `sudo date -s "2024-08-30 18:11:01"`. Формат даты и времени, который используется в команде `sudo date -s "2024-08-30 18:11:01"`, определяется стандартом `POSIX`: `YYYY-MM-DD HH:MM:SS`
  + Отображения даты и времени в заданном формате: `date +"%Y-%m-%d %H:%M:%S"` выводит `2024-08-30 18:11:01`
+ [`mount`](#mountlinux) в Linux используется для подключения файловых систем к определённым точкам монтирования в файловой системе
+ `sleep` используется для приостановки выполнения команд на заданное время, в том числе и в скриптах: `sleep 5` (на 5 секунд), `sleep 10s` (10 секунд), `sleep 2m` (2 минуты), `sleep 1h` (1 час), `sleep 1d` (1 день), `sleep 1h 30m` (1 час 30 минут)
+ `time command` выводит три основных показателя времени выполнения команды:
  + `real`: фактическое время, прошедшее с момента начала до завершения команды. Это включает в себя все время ожидания, например, время, когда процесс был приостановлен или ожидал ввода/вывода.
  + `user`: время, которое процессор потратил на выполнение пользовательского кода (вне ядра). Это время, затраченное на выполнение инструкций программы.
  + `sys`: время, которое процессор потратил на выполнение системного кода (внутри ядра). Это время, затраченное на выполнение системных вызовов, таких как операции ввода/вывода.
+ ```id``` - Выводит сведения о пользователе:
  + `id` отображает эффективную информацию о текущем пользователе. Вывод может быть таким: `uid=1000(vboxuser) gid=1000(vboxuser) groups=1000(vboxuser),27(sudo),100(users),995(vboxsf)`
  + `id username` отображает эффективную информацию о конкретном пользователе. Для `id root` вывод может быть таким: `uid=0(root) gid=0(root) groups=0(root)`.
  + Отображение только эффективный `UID` пользователя: `id -u` или для конкретного пользователя: `id -u username`
  + Отображение только эффективный `GID` пользователя: `id -g` или для конкретного пользователя: `id -g username`
  + Отображение всех эффективных групп, к которым принадлежит пользователь: `id -G` или для конкретного пользователя: `id -G username`
  + Отображение имен вместо числовых идентификаторов: `id -n`, например, `id -nu` покажет имя пользователя
  + Отображения реальных идентификаторов пользователя и группы, а не эффективных: `-r`. Например, `id -r -u username` покажет реальный идентификатор пользователя.
    + Реальный идентификатор пользователя (Real User ID, RUID): Это идентификатор пользователя, который запустил процесс. Он обычно остается постоянным на протяжении всего времени выполнения процесса и используется для определения владельца процесса.
    + Реальный идентификатор группы (Real Group ID, RGID): Это идентификатор группы, к которой принадлежит пользователь, запустивший процесс. Как и реальный идентификатор пользователя, он остается постоянным на протяжении всего времени выполнения процесса.
    + Эффективный идентификатор пользователя (Effective User ID, EUID): Эффективный UID может отличаться от реального UID, если с помощью `setuid` были изменены права доступа для выполнения определенных операций. Здесь `sudo chown root:root example` `sudo chmod u+s example` на исполняемый файл (`example`) был установлен бит `setuid` чтобы он выполнялся с правами владельца файла (`root`), а не с правами пользователя, который его запускает. Это позволяет выполнять критически важные операции, требующие повышенных прав доступа, без необходимости предоставлять пользователям постоянные права суперпользователя. Однако нужно быть осторожным с использованием `setuid`, так как это может создать уязвимости в безопасности.
    + Эффективный идентификатор группы (Effective Group ID, EGID): Это идентификатор группы, который используется системой для проверки прав доступа. Эффективный GID может отличаться от реального GID, если процесс был запущен с использованием `setgid`.
+ `rm [ПАРАМЕТР]… [ФАЙЛ]…`	-	используется для удаления файлов и директорий. Дополнительные опции:
  +	`-i, --interactive`: Запрашивать подтверждение перед удалением каждого файла.
  + `-f, --force`: Принудительно удалить файлы без запроса подтверждения. Игнорирует несуществующие файлы и не выводит сообщений об ошибках. При одновременном использовании с `-i` во избежание конфликта Linux дает `-f` более высокий приоритет
  +	`-v, --verbose`: Выводить подробную информацию о процессе удаления.
  +	`-r`:	рекурсивное удаление файла или директории:
    + `rm -r папка`: Команда будет рекурсивно удалять файлы и поддиректории. Если файлы или директории защищены от записи или установлены определенные ограничения, команда будет запрашивать подтверждение перед удалением каждого такого элемента. !!! `rm` по умолчанию не удаляет директории без рекурсивного флага `-r`
    + `rm -r -i папка`: Команда будет всегда запрашивать подтверждение перед удалением каждого файла или директории, независимо от их статуса (защищены от записи или нет).
    + `rm -r -f папка`: Команда будет принудительно и рекурсивно удалять файлы и поддиректории без запросов подтверждения, даже если они защищены от записи или установлены определенные ограничения.
+ `cd`	-	сменить текущую рабочую директорию на заданную: `cd /etc`
+ `touch ~/chown.me`	-	используется для обновления временных меток файла. Временные метки включают: 
  + время доступа (`atime`): когда файл был последним раз прочитан
  + время модификации (`mtime`): когда содержимое файла было последним раз изменено
  + время изменения (`ctime`): когда метаданные файла (например, права доступа или владелец) были последним раз изменены. 
  + если файл (здесь - `chown.me`) не существует, `touch` создает его. 
  + если файл уже существует, `touch` обновляет его временные метки `atime` и `mtime`, но не изменяет его содержимое
+ `pwd`	-	используется для вывода текущей рабочей директории
  + `pwd` покажет полный путь к текущей директории, например: `/home/user`
  + `pwd -P` : что если вы находитесь в каталоге, который является символической ссылкой, команда `pwd -P` покажет путь к реальному каталогу, на который указывает символическая ссылка
  + `pwd -L` : (по умолчанию). Это путь, который вы видите в командной строке, и он может отличаться от физического пути, если вы перешли в каталог через символическую ссылку.
+ `ls`	-	показывает информацию про заданный объект файловой системы (файл, директорию), а также про содержимое заданной директории
  +	`ls -l /путь/к/директории`	-	вывод содержимого указанной директории в длинном формате 
  +	`ls -l -d`	-	вывод информации о текущей директории (`ls -l -d .`) или прямо указанных директориях (`ls -l -d dir1 dir2`) в длинном формате, не перечисляя содержимое этих директорий 
  +	`ls -la`	-	вывод информации о содержимом директории в длинном формате, включая скрытые файлы (чьи имена начинаются с точки .)
  +	`ls –lih /путь/к/директории`	-	вывод информации о содержимом директории в длинном формате с дополнительной информацией:
	  +	`l`: длинный формат, включающий подробную информацию о каждом файле или директории.
	  +	`i`: отображение номера индекса (`inode`) каждого файла или директории.
	  +	`h`: форматирование размеров файлов в читаемом виде (человеческий формат), используя такие единицы измерения, как K, M, G и т.д
  + `ls -lF /путь/к/директории` -  опция `-F` при выводе результата выделяет исполняемые файлы, добавляя `*`
  + `ls -lL /путь/к/директории` -  опция `-L` при выводе результата заставляет `ls` отображать информацию о файлах или каталогах, на которые указывают символические ссылки, а не самих символических ссылок
+ `cat`	-	используется для отображения содержимого файлов, объединения файлов и вывода их содержимого на стандартный вывод (обычно это экран).
  + `cat {one,two,three}/one.txt`	-	используется для отображения содержимого файла one.txt из каждой из трех директорий: one, two и three.
+ `cp`	-	используется для копирования файлов и директорий
  + Копирование файла: `cp source_file destination_file`. Если файл `destination_file` уже существует, его содержимое будет заменено содержимым файла `source_file`. Если файл `destination_file` не существует, он будет создан с содержимым файла `source_file`
  + Копирование файла в другой каталог: `cp file.txt /path/to/directory/`. Если там такой файл уже есть, то молча перепишет его, если у пользователя, инициировавшего копирование, хватает прав, а если нет - то могут быть дополнительные запросы на подтверждение
  + Копирование каталога рекурсивно *вариант 1*: `cp -r source_directory /path/to/directory/`. В результате в каталоге `/path/to/directory/` появится каталог `source_directory` со всем содержимым
  + Копирование каталога рекурсивно *вариант 2*: `cp -r source_directory/* /path/to/directory/`. В результате в каталоге `/path/to/directory/` появится только содержимое каталога `source_directory`
  + Интерактивное копирование с подтверждением перезаписи: `cp -i file.txt /path/to/directory/`
  + Копирование с сохранением атрибутов файла (прав доступа, временных меток и других): `cp -p file.txt /path/to/directory/`
  + Копирование директории с сохранением атрибутов всех файлов и поддиректорий: `cp -pr source_directory /path/to/directory/`
  + Архивное копирование: включает в себя рекурсивное копирование и сохранение всех атрибутов (аналогично -p плюс дополнительные функции): `cp -a source_directory /path/to/directory/`
  + Копирование с подробным выводом: `cp -v file.txt /path/to/directory/`
  + Принудительное копирование без дополнительных запрос на подтверждения действий, переписывая целевой файл, если необходимо: `cp -f file.txt /path/to/directory/`
  + Копирование только если источник новее, чем целевой файл: `cp -u file.txt /path/to/directory/`
+ `mv`	-	используется для перемещения файлов и директорий или переименования файлов
  + `mv folderA/*.log folderB/`	-	перемещает все файлы с расширением .log из директории folderA в директорию folderB.
  + Переименование файла: `mv old_name.txt new_name.txt`
  + Перемещение каталога: `mv source_directory /path/to/destination/` (флаг рекурсивного перемещения как для команд `cp`, `rm`, - не нужен)
  + Переименование каталога `old_directory` в `new_directory`, если каталога `new_directory` не существует: `mv old_directory new_directory`. Если существует, то перенесет `old_directory` со всем содержимым в `new_directory`
  + Интерактивное перемещение с подтверждением перезаписи: `mv -i file.txt /path/to/destination/`
  + Принудительное перемещение, удаляя целевой файл (файл или директория, куда перемещается исходный файл или директория), если необходимо: `mv -f file.txt /path/to/destination/`
  + Перемещение с подробным выводом: `mv -v file.txt /path/to/destination/`
  + Перемещение нескольких файлов в каталог: `mv file1.txt file2.txt /path/to/destination/`
+ `stat`	-	используется для вывода информации о файле или файловой системе. Эта команда показывает различные атрибуты файла, такие как права доступа, время последнего доступа, изменения и модификации, а также номер `inode` и другие метаданные: 
  + Отображение информации о файле: `stat filename`

  ```console
    File: filename
    Size: 1024       Blocks: 8          IO Block: 4096   regular file
  Device: 803h/2051d Inode: 123456      Links: 1
  Access: (0644/-rw-r--r--)  Uid: ( 1000/ username)   Gid: ( 1000/ groupname)
  Access: 2024-11-10 21:41:00.000000000 +0000
  Modify: 2024-11-10 21:41:00.000000000 +0000
  Change: 2024-11-10 21:41:00.000000000 +0000
  Birth: -

  ```

  + Отображение информации о символической ссылке (команда покажет информацию о файле, на который указывает символическая ссылка. Здесь это `symlink`): `stat -L symlink`

  ```console
    File: symlink -> target_file
    Size: 10        Blocks: 0          IO Block: 4096   symbolic link
  Device: 803h/2051d Inode: 789012      Links: 1
  Access: (0777/lrwxrwxrwx)  Uid: ( 1000/ username)   Gid: ( 1000/  groupname)
  Access: 2024-11-10 21:41:00.000000000 +0000
  Modify: 2024-11-10 21:41:00.000000000 +0000
  Change: 2024-11-10 21:41:00.000000000 +0000
  Birth: -
  ```


  + Отображение информации в формате printf (команда выведет размер файла, права доступа, имя владельца и группы в одной строке): 
    + `stat --printf="%s %A %U %G\n" filename` выведет: `1024 -rw-r--r-- username groupname`
  + Отображение информации о файловой системе (команда покажет информацию о файловой системе, на которой находится файл): `stat -f filename`

  ```console
    File: "filename"
      ID: 100000000000 Namelen: 255     Type: ext4
  Block size: 4096       Fundamental block size: 4096
  Blocks: Total: 1000000   Free: 500000    Available: 480000
  Inodes: Total: 250000    Free: 200000
  ```
  + Отображение информации в кратком формате (команда выведет имя файла и его размер в байтах): 
    + `stat -c "%n: %s bytes" filename` выведет: `filename: 1024 bytes`
+ `mkdir`	-	используется для создания новых директорий
  + `mkdir directory_name`	-	создаст директорию с указанным именем 
  + `mkdir -p /path/to/new/directory`	-	создаст директорию /path/to/new/directory, создав все несуществующие родительские директории по пути. Флаг `-p` используется для создания родительских директорий, если они не существуют.
  + `mkdir -p /tmp/symlinks/{one,two}`	-	создает две директории в директории /tmp/symlinks: one и two. Флаг `-p` используется для создания родительских директорий, если они не существуют.
+ `tree`	-	используется для отображения древовидной структуры файлов и директорий, начиная с указанной директории
+ `find` - инструмент для поиска файлов и директорий в файловой системе на основе различных критериев: `find [путь] [условия] [действия]`
  + `путь`: Указывает начальную директорию, с которой начнется поиск (по умолчанию - текущая директория)
  + `условия`: Определяют критерии поиска (имя файла, размер, время изменения и т.д.)
  + `действия`: Указывают, какие действия должны быть выполнены для найденных файлов (удаление, вывод имени и т.д.).
  + Примеры использования:
    + Поиск файлов по имени `find /path/to/search -name "filename"`
    + Поиск файлов по шаблону `find /path/to/search -name "*.txt"` - Найти все файлы с расширением .txt в директории /path/to/search
    + Поиск файлов по размеру `find /path/to/search -size +1M` - Найти все файлы размером больше 1 мегабайта в директории /path/to/search
    + Поиск файлов по дате изменения `find /path/to/search -mtime -7` - Найти все файлы, измененные за последние 7 дней, в директории /path/to/search
    + Поиск и выполнение действия `find /path/to/search -name "*.log" -exec rm {} \;`
      + `-exec`: Указывает, что для **каждого** найденного файла должна быть выполнена определённая команда.
      + `rm`: Указывает команду для выполнения (в данном случае команда rm для удаления файлов).
      + `{}`: Специальный **плейсхолдер**, который будет заменён именем каждого найденного файла
      + `\;`: Обозначает конец команды `-exec`, ставить `\;` - **ОБЯЗАТЕЛЬНО**
    + Поиск файлов с определенными правами доступа `find /path/to/search -perm 644` - Найти все файлы с правами доступа 644 в директории /path/to/search
    + Полезные флаги и параметры:
      + `-type`: Указывает тип файла (например, `-type f` для обычных файлов, `-type d` для директорий, `-type l` для символических ссылок).
      + `-iname`: Игнорирует регистр при поиске имени файла.
      + `-maxdepth`: Ограничивает глубину рекурсивного поиска.
      + `-mindepth`: Указывает минимальную глубину поиска.
      + `-inum`: используется для поиска файлов по их `inode` номеру





## Символические ссылки (symlinks)
1. Символическая ссылка - это специальный тип файла, который указывает на другой файл или директорию. Она хранит путь к целевому файлу. У символической ссылки и исходного файла разные `inode`
2. Символические ссылки могут указывать как на файлы, так и на директории.
3. Символические ссылки могут указывать на файлы в других файловых системах или разделах.
4. Если исходный файл удален, символическая ссылка становится "битой", то есть ссылается на несуществующий файл.
5. Команда создания:
   1. `ln опции файл_источник файл_ссылки` - команда для создания ссылок на файлы:
      1. `ln -s source softlink`	-	создает символическую ссылку на файл или директорию с именем softlink, указывающую на исходный файл или директорию source.
         1. `-s`: Этот флаг указывает, что нужно создать символическую ссылку (**soft link**), а не жесткую ссылку (**hard link**).
         2. `source`: Это исходный файл или директория, на который будет указывать символическая ссылка.
         3. `softlink`: Это имя, которое вы хотите дать вашей символической ссылке.
      2. `ln -sf three/one.txt two/one.txt`	-	создает символическую ссылку на файл one.txt в директории three, и делает эту ссылку вместо уже существующего файла one.txt в директории two, если он существует. Вот что означают использованные опции
         1. `-s`: Создание символической ссылки.
         2. `-f`: Принудительное создание символической ссылки, игнорируя ошибки, если файл не существует или ссылка two/one.txt уже существует и нужно её перезаписать.
### Пример поиска  в системе *жёстких ссылок* заданного файла: 
`find / -inum $(stat -c %i /path/to/file)` Здесь:
  + `stat -c %i /path/to/file`: Эта часть команды выводит `inode` заданного файла. Параметр `-c %i` указывает `stat` вывести только значение `inode` файла.
  + `$(...)`: Это командная подстановка, которая позволяет использовать результат выполнения команды внутри другой команды. В данном случае, результатом будет значение `inode` файла.
  + `find / -inum <inode>`: Команда `find` ищет файлы по всей файловой системе (`/`) с указанным `inode` (`-inum <inode>`). Поскольку `<inode>` заменяется результатом команды `stat`, `find` ищет все файлы с тем же `inode`, что и у указанного файла.
## Жесткие ссылки (hard links)
1. Жесткая ссылка является дополнительной ссылкой на уже существующий файл, и обе ссылки указывают на один и тот же `inode`.
2. Жесткие ссылки могут быть созданы только для файлов, не для директорий.
3. Жесткие ссылки могут быть созданы только в рамках одной файловой системы.
4. Удаление исходного файла не повлияет на жесткую ссылку, потому что данные по-прежнему доступны через другую ссылку (из-за того, что `inode` один и тот же).
5. Команда создания: `ln target_file hardlink_name`



# 07 Обработка текста в Linux
## Типы и расширения файлов в Linux
В Linux расширения файлов не так широко используются, особенно для текстовых файлов или исполняемых файлов, потому что при работе в командной строке нельзя дважды щелкнуть по файлу, чтобы открыть его. Вместо этого вам нужно вручную указать, какая программа должна быть использована для работы с этим файлом, например: `ls -l /etc/passwd`

Но расширения могут использоваться в различных случаях, например, для вашего собственного удобства - если вы создаете эти файлы для дальнейшего использования, а также приняты стандарты расширений:

+ Файлы журналов часто имеют расширение ".log".
+ Настройки приложений часто хранятся в файлах ".conf" или ".cnf". 
+ Если это требуется логикой программы, например, PHP-скрипты для динамического веб-контента должны иметь расширение ".php".
+ Если эти файлы создаются и открываются средствами графического интерфейса, например, ".odt" для OpenOffice.
## Формат текстовых файлов UNIX
+ Строки текстовых файлов UNIX заканчиваются символом `\n` (он не отображается на терминале, но все же существует), который также называется LF, его ASCII-код - 10 (0xA в шестнадцатеричной системе).
+ Строки текстовых файлов Windows заканчиваются символами `\r\n`, символ `\r` также называется CR, его ASCII код - 13 (0xD в шестнадцатеричной системе).
+ `file` - команда, которая определяет формат указанных файлов. Она анализирует содержимое файла и выводит информацию о его типе (текстовый файл, исполняемый файл, архив и т.д.) Команда использует так называемые “магические числа” (специальные сигнатуры в файлах) для определения типа:
  ```console
  feodor@unixdell:/tmp$ file passwd*
  passwd: 	ASCII text
  passwd.win: ASCII text, with CRLF line terminators
  ```
+ `dos2unix` и `unix2dos` - утилиты для преобразования в командной строке Linux формат текстовых файлов соответственно из dos в unix unix в dos
## Обработка текста в Linux
### Команды для работы с текстом, как файлами, так и потоками
Ниже перечислены основные команды для работы с текстом, как файлами, так и потоками. Термин "поток" (stream) в программировании означает поток (последовательность) данных
+ `cat`: в Linux используется для чтения, объединения и записи содержимого файлов. `cat` не работает с директориями
  + `cat file1 file2` - объединяет нескольких файлов и выводит результат в терминал
  + `cat file1.txt file2.txt > combined.txt` - содержимое файлов file1.txt и file2.txt будет объединено и записано в файл combined.txt
  + `cat -n filename.tx`t - выведет содержимое файла с нумерацией строк
  + `cat -v filename.txt` - показывает невидимые символы, такие как табуляции и окончания строк
+ `less`: печатает содержимое файла на терминале с использованием страниц и прокрутки. Также позволяет осуществлять строковый поиск в открытых файлах с помощью горячих клавиш. Полезна для чтения больших файлов (логов)
+ `grep`	-	используется для поиска строк в текстовых файлах или стандартном вводе, которые соответствуют заданному шаблону. Поиск осуществляется либо исходя из Basic Regular Expressions (`grep "pattern" file.txt`) либо Extended Regular Expressions (`grep -E "regex_pattern" file.txt` то же, что и `egrep "regex_pattern" file.txt`). Обычно (без опции `-l` или `-h`) выводит имя файла и строку текста, удовлетворяющего условию поиска:
  + `-i`: сделать поиск нечувствительным к регистру символов
  + `-v`: вывести все строки, не соответствующие шаблону
  + `grep "pattern" filename.txt` -	найдет все строки в файле filename.txt, содержащие подстроку pattern.
  + `grep -E "regex_pattern" filename.txt`	-	выполнит поиск в файле filename.txt, используя расширенные регулярные выражения
  + `grep "pattern" file1.txt file2.txt`	-	выполнит поиск подстроки pattern в файлах file1.txt и file2.txt.
  + `grep -r "pattern" directory/`	-	выполнит рекурсивный поиск подстроки pattern во всех файлах внутри указанной директории `directory` и подкаталогах (без `-r` в подкаталогах искать не будет)
  + `grep "pattern" directory/*`	-	выполнит поиск (нерекурсивный) подстроки pattern во всех файлах внутри указанной директории `directory`
  + `grep -rl "pattern" directory/` - выполнит рекурсивный поиск подстроки pattern во всех файлах внутри указанной директории directory, но из-за опции `-l` выводит только имена найденных файлов
  + `grep -rh "pattern" directory/` - выполнит рекурсивный поиск подстроки pattern во всех файлах внутри указанной директории directory, но из-за опции `-h` выводит только найденные строки без имени файла
+ `head`: выводит на терминал первые N строк из файла (`head -n 5 input_file`)
+ `tail`: 
  + `tail -n 5 input_file` - выводит на терминал последние N строк из файла
  + `tail -f input_file` - позволяет видеть изменения файла в режиме реального времени, когда программа добавляет новые строки в этот файл; 
+ `wc`: подсчитывает количество: 
  + `-l`: Подсчитывает количество строк: `wc -l input_file`
  + `-w`: Подсчитывает количество слов: `wc -w input_file`
  + `-m`: Подсчитывает количество символов: `wc -m input_file`
  + `-c`: Подсчитывает количество байтов: `wc -c input_file`
  + `-L`: Подсчитывает длину самой длинной строки: `wc -L input_file`
+ `sort`: используется для сортировки строк текстовых файлов или стандартного ввода в алфавитном или числовом порядке. Она выводит отсортированные строки на стандартный вывод: `sort /etc/passwd`
  + `ls -l | sort` - отсортирует строки вывода команды `ls -l` (содержимое текущего каталога) в алфавитном порядке (в качестве входных данных используется поток стандартного ввода)
  + `sort -t ":" -k 3 -n /etc/passwd` - выводит на экран содержимое файла `/etc/passwd`, отсортированное по третьему полю  (UID - идентификатор пользователя) в числовом порядке:
    + `-t ":"`: Указывает, что разделителем полей является двоеточие (:). В файле /etc/passwd поля разделены двоеточиями.
    + `-k 3`: Указывает, что сортировка должна производиться по третьему полю. В файле /etc/passwd третье поле — это UID.
    + `-n`: Указывает, что сортировка должна быть числовой.
+ `uniq`: может удалять дублирующиеся строки, печатать только уникальные строки и показывать только дублирующиеся строки. Часто применяется совместно с "pipe". Строки должны быть предварительно отсортированы иначе `uniq` не сможет корректно удалить все повторяющиеся строки:
  + `-c`: Выводит количество повторений каждой строки.
  + `-d`: Выводит только строки, которые повторяются.
  + `-u`: Выводит только уникальные строки, которые не повторяются.
### Перенаправления вывода
#### Стандартные потоки вывода (stdout) и ошибок (stderr)
+ `stdout` - когда программа печатает что-то полезное во время своего выполнения, это направляется в специальный поток вывода под названием `stdout` (стандартный вывод). По умолчанию `stdout` подключен к терминалу, поэтому вы видите результаты на экране. *Можно изменить стандартный поток вывода таким образом, чтобы он всегда выводил, например, в файл, перенаправив стандартный вывод в файл в начале сессии оболочки. Один из способов - добавить команду перенаправления в файл инициализации оболочки, например, добавив в `.bashrc` или `.bash_profile`, в зависимости от используемой оболочки соответствующую строку:*
  + `exec > /path/to/output_file 2>&1` Здесь дополнительно с помощью `2>&1` перенаправляется в файл и стандартный поток ошибок `stderr` 
+ `stderr` - когда что-то идет не так, программа печатает свои ошибки в специальный поток под названием `stderr` (стандартные ошибки). По умолчанию он подключен к тому же терминалу, поэтому эти ошибки отображаются так же, как и `stdout`.
#### stdout
+ `some_program > output_file_rewrite`
+ `some_program >> output_file_append`

В обоих случаях выше `stdout` программы будет записан в указанный файл, а не в терминал но:
+ `>` перезапишет файл
+ `>>` добавит `stdout` программы в конец содержимого существующего файла

Оба метода создают выходной файл, если он не существовал ранее.

**!!! Внимание:** Второй частый случай использования `cat` - объединение файлов. Чтобы "склеить" содержимое файлов, вы можете выполнить следующее: `cat file1 file2 ... fileN > resulting_file`

#### stderr
Чтобы сохранить сообщения об ошибках отдельно от "полезного" вывода:
+ `some_command 2> output_file_rewrite`
+ `some_program 2>> output_file_append`

Важные замечания о перенаправлении `stderr`:
+ Не забудьте указать '2', если вы работаете с stderr
+ Пробелы между '2' и `>` (или `>>`) не допускаются
#### Объединение stdout и stderr
`some_program > output_file 2>&1`, здесь:
+ `stdout` выполнения команды `some_program` записывается в `output_file`
+ `stderr` перенаправляется в `stdout` (который на предыдущем шаге уже был перенаправлен в `output_file`)

`egrep root /etc/passwd /no/such/file> /tmp/new.out 2>/tmp/new.errs`, здесь:
+ файл `/tmp/new.errs` будет содержать 1 строку с текстом ошибки, 
+ файл `/tmp/new.out` будет содержать строки с найденным результатом,
+ в терминале ничего не выводится
#### /dev/null
Если нужно игнорировать ошибки (`stderr`) или `stdout` (показывать только один поток), то используют специальное псевдоустройство `/dev/null`:
+ `some_program 2>/dev/null` - здесь игнорируются ошибки выполнения команды
### Пайпы и стандартный поток ввода (stdin)
#### Пайпы
Пайпы (Pipes) предназначены для перенаправления `stdout` одной программы в `stdin` другой, например:

`cat /etc/passwd /etc/group | egrep user | head -n 2`

![pipes](resources/pipes-illustration.png)

#### stdin
Наряду с потоками `stdout` и `stderr`, каждая программа в мире UNIX имеет так называемый поток `stdin`, используемый для получения входных данных как поток, а не как входной файл. При этом программы в большинстве случаев не могут это делать одновременно. В следующем примере команды имеют одинаковый эффект:

+ `egrep user /etc/group`
+ `cat /etc/group | egrep user`
  + здесь `cat` печатает входной файл в `stdout`, который затем с помощью пайпа через `|` передается `egrep` в виде потока `stdin`, в котором `egrep` ищет заданный шаблон.
+ `egrep user < /etc/group`
  + здесь `<` означает "получить данные `stdin` из этого файла", это НЕ то же самое, что "получить это как входной файл", т.е. здесь `egrep` заполняет свой `stdin` из файла, указанного после `<`, и ищет шаблон в потоке входных данных.

*Примечание*: нельзя заполнять `stdin` команды через `pipe` и `<` одновременно. В этом случае на вход будет принят только файл, а `stdout` предыдущей команды будет проигнорирован. Так в примере `cmd1 | cmd2 < /some/file` cmd2 примет данные только от /some/file, проигнорировав `stdout` cmd1.

Пайпы работают только с `stdout`, поэтому если что-либо было выведено на `stderr`, и `stderr` не был обработан отдельно, вы также увидите сообщения `stderr` среди обработанных строк. Схематично это показано на рисунке ниже:
![pipes](resources/X-пайпы.png)

Для работы с `stderr` через пайпы можно использовать конструкцию ```some_command 2>&1 | next_command ``` (она объединяет `stdout` и `stderr` для "next_command"): 
![pipes](resources/X-пайпы2.png)

Если нужен только `stderr` (`stdout` полностью игнорируется) то можно использовать конструкцию:

`some_command 2> >(next_command) > /dev/null`, где:

+ `> /dev/null` : перенаправляет `stdout` команды some_command в `/dev/null` (т.е. игнорируется `stdout` команды some_command);
+ `2> >(next_command)`: перенаправляет стандартный поток ошибок (`stderr`) через **временный именованный канал** (конструкция `>(next_command)`) в стандартный ввод (`stdin`) команды next_command .

  ***Примечание***

  1. Когда используется выражение `>(next_command)`, оболочка (`shell`) создаёт временный именованный канал, существующий только на время выполнения команды и не отображаемый в файловой системе как обычный файл в отличие от случая, когда именованный канал создается с помощью команды `mkfifo`:
     1. `mkfifo ~/my_pipe` - создаст именованный канал `my_pipe` и файл `my_pipe` в домашнем каталоге
  2. `rm ~/my_pipe` - удалит именованный канал, созданный с помощью `mkfifo ~/my_pipe`


# 08 Linux - пользователи, группы и права доступа к файлам в Linux
## Понятия пользователей и групп Linux
### Учетные записи ОС
+ **Стандартные учетные записи** (создаются для обычных пользователей):
	+  могут входить в систему
	+  могут выполнять команды
	+  могут читать некоторые файлы или директории
	+  не могут изменять любую часть ОС
	+  не могут изменять любую часть "общесистемных" приложений
	+  по умолчанию могут изменять данные только в своих домашних директориях и `/tmp`.
+ **Административная учетная запись**: ее имя - `root`, и она является единственным администратором ОС (не может быть двух `root`). 
  + Учетная запись `root` используется для прямого входа в систему очень редко; вместо этого администраторы временно повышают свои привилегии до `root` для обслуживания системы и других важных операций.
  + Административная учетная запись `root` может входить в систему и делать все с ОС и пользователями без каких-либо ограничений (в отличие от Windows)
  + Часто принадлежат к административным группам, таким как `wheel`, `sudo`, или `adm`.
+ **Служебные учетные записи**:
  + принадлежат к группам, связанным с конкретными службами или приложениями (`mysql`, `ftp`...) и используются операционной системой, службами и приложениями (запускаемые с правами `root` или ограниченными правами). Например, при старте системы или вручную через команду `sudo systemctl start mysql`, системный менеджер служб (например, `systemd`) запускает от имени **служебной учетной записи** mysql службу MySQL. Это минимизирует возможные последствия в случае сбоя или взлома приложения. 
  + не должны использоваться пользователями;
  + не могут входить в систему. Так, при создании служебного пользователя можно указать оболочку, которая не позволяет входить в систему, например, команда `useradd` с параметром `-s` (`sudo useradd -s /sbin/nologin service_user`) создаст пользователя service_user, который при попытке входа в систему увидит сообщение о том, что вход запрещен;
#### Основные настройки учетной записи
##### `/etc/passwd`
`/etc/passwd` - это основной конфигурационный файл для учетных записей пользователей, который используется, когда:
+ Пользователь входит в систему (по `SSH`, `FTP` и другим средствам/протоколам).
+ ОС или любая программа требует, чтобы имя пользователя было сопоставлено с числовым UID (см. ниже) или наоборот.

*Пример получения информации про свою учетную запись*
```egrep "${USER}" /etc/passwd```, где: 
+ ```${}``` - специальный синтаксис для обращения к переменным в командной оболочке, позволяющий обращаться к значению переменной по ее имени. Фигурные скобки используются для явного выделения границ имени переменной (это может быть полезно, когда имя переменной непосредственно прилегает к другим символам или тексту, чтобы избежать неоднозначности)
+ ```USER``` - это имя переменной. В случае переменной ```${USER}``` это стандартная переменная окружения, которая обычно содержит имя текущего пользователя.

Файл ```/etc/passwd``` в качестве разделителя полей используется `:` и содержит данные про:
+ имя пользователя (должно быть уникальным)
+ x - поле не используется, поэтому мы имеем здесь 'x' как заглушку
+ идентификатор пользователя, называемый "UID", должен быть уникальным. Стандартные учетные записи в основном имеют UID >= 1000. Административная учетная запись `root` всегда имеет UID 0. Служебные учетные записи имеют UID от 1 до (в основном) 999. Никто, кроме `root`, не должен иметь UID 0 
  + **ВНИМАНИЕ!!!** система Linux технически не препятствует созданию неуникальных UID. Это означает, что администратор или пользователь с достаточными привилегиями может создать несколько учетных записей с одним и тем же UID. Однако это крайне не рекомендуется из-за потенциальных проблем с безопасностью и управляемостью.
+ идентификатор основной группы. Каждый пользователь должен быть членом хотя бы одной группы (не существует пользователей "без групп"). Если пользователей нужно включить в большее количество групп, это настраивается в файле ```/etc/group``` .
+ описание пользователя. Это поле может быть пустым или содержать что угодно, кроме `:`. Оно не играет никакой роли в ОС и механизмах входа в систему.
+ домашний каталог пользователя, куда он автоматически помещается после успешного входа в систему
+ программа, выполняемая при успешном входе в систему (например, ```/bin/bash```). Сервисные учетные записи не предназначены для входа в систему и работы в командной строке, поэтому у них здесь указаны специальные "псевдо" программы, такие как ```/bin/false``` или ```/sbin/nologin```
##### ```/etc/shadow```
+ Хеши паролей хранятся в файле ```/etc/shadow```, доступ к которому имеет только `root`. Эти особые разрешения ```/etc/shadow``` используются для того, чтобы избежать атак методом перебора.
+ файл ```/etc/shadow``` также содержит все настройки паролей учетных записей ОС, например, когда пароль должен быть изменен и т.д.
#### Заметки по безопасности/стабильности
+ Только `root` может изменять ```/etc/passwd``` - иначе хакеры могут повысить привилегии, создав "фальшивого рута" с UID 0.
+ Любой пользователь или приложение должны иметь доступ на чтение к файлу ```/etc/passwd``` - иначе ОС становится нестабильной.
+ Только `root` имеет доступ к файлу `/etc/shadow`.
### Группы ОС
+ Группы служат для упрощения управления пользователями и разделения привилегий:
  + кто может читать/писать/исполнять файл
  + кто может войти в систему через SSH
  + кто и как может использовать инструменты `sudo` или `su`
  + кто может читать журналы общесистемных служб с помощью инструмента `journalctl`
  + сколько процессора/памяти/дискового пространства может быть израсходовано
+ Группы включают 0 или более пользователей
+ Каждый пользователь должен быть членом как минимум одной группы (задается в ```/etc/passwd``` и называется "основной")
+ Каждый пользователь может быть включен в 0 или более дополнительных групп (задается в ```/etc/group``` и называется "вторичные группы" (secondary groups)).
+ Нет никакой разницы (в плане привилегий) между членством в первичной и вторичной группах, например: если ваш пользователь входит в группу "qa" и группу "users", вы можете читать файлы, доступные как группам "qa", так и "users".
+ Имена групп чувствительны к регистру.
+ В отличие от Windows, в UNIX нет группы "Администраторы".
+ В большинстве систем членство в группе `root` не дает многих привилегий, в отличие от статуса пользователя `root`.
+ Могут существовать специальные группы с дополнительными привилегиями, это сильно зависит от настроек вашей ОС. Например, группы `sudo` или `wheel` могут иметь (а могут и не иметь) неограниченные права на выполнение любых команд от имени `root` через `sudo`
#### Создание /изменение групп
##### Создание обычной группы:
`sudo groupadd mygroup` - создание группы с именем `mygroup`.
##### Создание группы с заданным GID:
`sudo groupadd -g 1001 mygroup` - создание группы `mygroup` с GID 1001.
##### Создание системной группы:
`sudo groupadd -r mysystemgroup` - системные группы обычно используются для специальных системных операций, таких как резервное копирование, обслуживание или предоставление доступа к оборудованию. Эти группы обычно имеют низкие GID (Group ID) и создаются для управления доступом к определённым системным ресурсам и службам.
##### Изменение имени группы:
`sudo groupmod -n newgroupname oldgroupname` - изменение имени группы с oldgroupname на newgroupname.
##### Изменение GID группы:
`sudo groupmod -g 2000 mygroup` - изменение GID группы mygroup на 2000.
#### Основные настройки групп: ```/etc/group```
```/etc/group``` - основной конфигурационный файл для групп UNIX и используется, когда:
+ ОС или какой-либо программе требуется преобразовать имя группы в числовой GID (см. ниже) или наоборот.
+ Пользователь пытается сделать что-то, что может быть ограничено или разрешено функциями управления группами (например, чтение файла)
+ [опционально, если службы входа настроены таким образом] Пользователь входит в систему (SSH, FTP, другие протоколы) и службы (SSH, FTP...) могут проверять, имеет ли пользователь необходимые права доступа, основываясь на его групповой принадлежности.

Файл `/etc/group` содержит:
+ Название группы,
+ Идентификатор группы, называемый "GID" (должен быть уникальным),
+ Список членов группы, разделенный запятыми (может быть пустым)

Членство в группе вычисляется как совокупность вхождения пользователя в файлах ```/etc/passwd``` и ```/etc/group```
### Получение информацию о пользователе и группе
+ ```whoami```	- покажет имя **эффективного** пользователя, а не реального. Это означает, что если вы используете `sudo` для выполнения команды `whoami`, она отобразит `root`, так как команда выполняется с привилегиями суперпользователя. Она полезна для проверки, под каким пользователем вы в данный момент работаете, особенно если вы переключались между пользователями с помощью `su` или `sudo`
+ ```id```		- [Получить расширенную информацию о реальном (не эффективном) пользователе и его членстве в группах](#mainlinuxfscmd)
+ ```groups```	- получить имена групп текущего пользователя
  + `groups username` - вывод групп конкретного пользователя
### Добавление/изменение учетных записей в группе
+ `useradd` используется для создания новых учетных записей (создает все необходимые файлы и каталоги для нового пользователя, добавляет записи в файлы `/etc/passwd`, `/etc/shadow` и `/etc/group`);
+ `usermod` применяется для изменения уже существующих (изменяет параметры уже существующих учетных записей).
#### `useradd`
`sudo useradd -ОПЦИИ ПАРАМЕТРЫ`, где:
+ `-m` : Создает домашний каталог для нового пользователя. Должен применяться одновременно с `-d` `sudo useradd -m -d /new/dir username`(без `-d`, каталог будет создан по умолчанию в `/home/username`).
+ `-d` : Указывает домашний каталог для нового пользователя (если без опции `-m`, то к этому моменту каталог должен уже существовать).
+ `-s` : Указывает оболочку для нового пользователя.
+ `-g` : Указывает основную группу для нового пользователя (можно задавать как GID, так и имя группы).
+ `-G` : Указывает дополнительные группы для нового пользователя.
+ `-u` : Указывает UID для нового пользователя.
#### `usermod`
```sudo usermod -ОПЦИИ ПАРАМЕТРЫ```, где:
+ `-l` или `--login NEW_LOGIN`: Изменяет имя пользователя `sudo usermod -l newjohn john`.
+ `-d` или `--home HOME_DIR`: Изменяет домашний каталог пользователя `sudo usermod -d /new/home/john -m john`.
+ `-m` или `--move-home`: Перемещает содержимое домашнего каталога в новое место (используется с -d).
+ `-g` или `--gid GROUP`: Изменяет основную группу пользователя `sudo usermod -g developers john`.
+ `-G` или `--groups GROUPS`: Задает дополнительные группы для пользователя `sudo usermod -aG sudo,adm john` (без `-a` заменит старые дополнительные группы на новые).
+ `-a` или `--append`: Добавляет пользователя в дополнительные группы (не используется отдельно от `-G`).
+ `-s` или `--shell SHELL`: Изменяет командную оболочку пользователя `sudo usermod -s /bin/zsh john`.
+ `-u` или `--uid UID`: Изменяет UID пользователя `sudo usermod -u 2001 john`.
+ `-L` или `--lock`: Блокирует учетную запись пользователя `sudo usermod -L john`.
+ `-U` или `--unlock`: Разблокирует учетную запись пользователя.
## Повышение привилегий
### `su`: Переключить пользователя
Команда `su` запускает оболочку от имени целевого пользователя (по умолчанию `root`) после предоставления пароля целевого пользователя. Соответственно, все, что выполняется в этой оболочке, будет выполняться с привилегиями целевого пользователя. Чтобы вернуться к предыдущему пользователю, выполните команду `exit`.

Часто используется системными администраторами, которые входят в систему как обычные пользователи, а затем переключаются на учетную запись `root`. Но помните, что для этого случая требуется знание пароля `root`.
1. `su - sutest` - запустит оболочку от имени пользователя `sutest`. Опция `-` (или `-l`) указывает `su` использовать логин-сессии (здесь - созданную сессию пользователя `sutest`), что означает:
   1. Смену на домашний каталог целевого пользователя и использование его окружения - переключается в домашний каталог целевого пользователя (в примере — `/home/sutest`)
   2. Переменные окружения (`HOME`, `USER`, `LOGNAME`, `SHELL`, `PATH` и другие) устанавливаются так, как если бы вход в систему выполнил целевой пользователь (в примере — `sutest`)
   3. Переменная `PATH` обновляется, чтобы включать пути, специфичные для целевого пользователя (в примере — `sutest`), что обеспечивает доступ ко всем необходимым системным утилитам
   4. Загружаются и выполняются файлы конфигурации оболочки целевого пользователя (в примере — `sutest`), такие как `.profile`, `.bash_profile`, `.bashrc` и другие, если они существуют
2. `su - -c "id -u; whoami"` - выполнение команды (или нескольких, разделенных точкой с запятой команд) от имени root, без запуска полнофункционального сеанса оболочки `root`:
   1. Команда `su` используется для смены пользователя. По умолчанию она переключает на пользователя `root`.
   2. Опция `-` (или `-l`) указывает `su` использовать логин-сессии (здесь - `root`)
   3. Опция `-c` указывает `su` выполнить команду, заключенную в кавычки, вместо запуска интерактивной оболочки (в примере команда `id -u` выводит числовой идентификатор (UID) текущего пользователя, а команда `whoami` выводит имя текущего пользователя.
  
**Примечания**
+ команда `su -` - переключит на `root`
+ Пользователь `root` может переключаться на любого другого без ввода пароля цели.
+ Лучше использовать `su -` вместо `su`, так как ключ `-` загружает все окружение оболочки целевого пользователя.
### `sudo`: Substitute User Do
Инструмент `sudo` используется для запуска команды от имени другого пользователя (по умолчанию `root`) после предоставления собственного пароля пользователя, а не того, от имени которого вызывают команду. `sudo` предназначен для того, чтобы позволить определенным пользователям выполнять определенные команды (и только их, ничего больше!) от имени другого, часто привилегированного, пользователя 
+ `sudo -l` -  Чтобы проверить возможности пользователя, заданные в файле `/etc/sudoers`
+ `sudo [-u username] command args` - чтобы запустить команду
  + `sudo usermod -aG sudo username` - добавляет пользователя `username` в группу `sudo`

**Примечания**
+ Только пользователь `root` может устанавливать или изменять чьи-либо разрешения `sudo` - обычный пользователь может только перечислить свои собственные настройки sudo (`sudo -l`) и выполнять разрешенные команды в соответствии с настройками
+ Некоторые привилегированные пользователи (например, члены групп `wheel` или `sudo`) могут выполнять любые команды от имени `root`. В файле `/etc/sudoers` это может отображаться как `root ALL=(ALL:ALL) ALL` *(пользователь `root` на любом хосте от имени любого пользователя в составе любой группы может выполнять любые команды)* или `%sudo ALL=(ALL) ALL` *(учетные записи из группы `sudo` на любом хосте от имени любого пользователя могут выполнять любые команды, при условии, что учетная запись пользователя входит в группу `sudo` на данных хостах)*
+ Чтобы предоставить пользователю возможность применять `sudo` администратор (`root`) добавляет соответствующие записи в файл `/etc/sudoers`. Для минимизации риска "поломать" файл `/etc/sudoers` лучше делать это с помощью редактора `visudo`, который вызывается: `sudo visudo`
### `sudo` VS `su`: Основные различия
|  | `su` | `sudo` |
|----------|----------|----------|
| Основная функциональность  | Предоставление оболочки входа в систему с привилегиями целевого пользователя, по умолчанию `root` | Выполнение одной команды от имени целевого пользователя, по умолчанию `root` |
| Основная идея | Работа в полнофункциональной оболочке как `root` или любой другой пользователь ОС | Делегирование некоторых административных полномочий обычным пользователям |
| Какой пароль вводить | Пароль целевого пользователя | Ваш собственный пароль |
| Необходимые настройки | Возможно, вас нужно будет включить в специальную группу для запуска `su` (если это установлено вашим системным администратором). | Точные команды и даже их аргументы могут быть разрешены в явном виде в файле `/etc/sudoers`|
| Настройки безопасности по умолчанию | Любой может выполнить команду `su`, требуется только пароль целевого пользователя | Только члены специфической для дистрибутива группы (`wheel` в RHEL-системах, например CentOS, `sudo` в Debian, например Ubuntu) могут использовать `sudo`. |
## Разрешения на доступ к файлам
### Анатомия вывода `ls`
![Анатомия вывода "ls"](resources/linux_permissions.png)
+ Выше результат команды `ls -l testfile`, где:
	+ `-` для типичных файлов
	+ `d` для каталогов
	+ `l` для символических ссылок
	+ 9 следующих символов, (`rw-r--r--`) - это разрешения доступа к файлам UNIX
	+ "Размер файла" имеет смысл только для типичных файлов, ни для каталогов, ни для симлинков.
### Анатомия разрешений на доступ к файлам
![Анатомия разрешений на доступ к файлам](resources/perm.jpg)

Как проверяются и применяются разрешения доступа:
+ Во-первых: является ли пользователь владельцем данного объекта? Если да - проверить, разрешают ли разрешения владельца объекта эту операцию.
+ Если пользователь не является владельцем объекта - является ли он членом группы? Если да - проверить, разрешают ли групповые разрешения объекта эту операцию.
+ Если пользователь не входит в группу - проверить, разрешают ли разрешения других на эту операцию.
### Смысл и формат записи прав доступа
Разрешения доступа к файлам (r, w, x) имеют разные значения для файлов и директорий
| Бит | Значение для файлов | Значение для директорий |
|:-------------|:---------------:|--------------:|
| `r` - read (чтение)       |Файл может быть прочитан, например, с помощью `cat`, `less`, `head`, других инструментов.        | Список содержимого каталога может быть прочитан: `ls имя_каталога` для отображения содержимого каталога, но при этом не будет возможности просматривать содержимое самих файлов или заходить в подкаталоги, если у вас  не установлен бит `x`        |
| `w` - write (запись)       | Содержимое файла может быть изменено. Но сам файл не может быть удален - см. `w` для каталогов.        | Любой элемент этого каталога может быть создан или удален. То есть, даже если вы не являетесь владельцем файла в этом каталоге, вы можете удалить его, установив `w` для каталога. Но без также установленного бита `x` можно будет добавлять новые файлы в каталог, удалять существующие файлы и переименовывать их только если вы уже находитесь в каталоге, т.к. при обращении к файлу система сначала проверяет право `x` у всех директорий, стоящих в пути этого файла, и только затем права на сам файл. Если хотя бы у одной директории право `x` отсутствует, доступ к этой директории и всему ее содержимому для Вас запрещается.       |
| `x` - execute (выполнение)       | Файл может быть выполнен. Фактически исполняемые файлы: двоичные файлы и скрипты        | Доступ к файлам и подкаталогам: с битом `x` можно: переходить в каталог с помощью команды `cd`; просматривать атрибуты файлов (например, права доступа, размер) с помощью команды `ls -l`; открывать, читать, записывать и выполнять файлы в каталоге, если у вас есть соответствующие права на сами файлы|
### Команды для изменения разрешений доступа к файлам
#### `chown`
`chown [OPTIONS] USER[:GROUP] FILE(s)`: для установки нового владельца и/или группы для объекта
+ изменить только владельца объекта - может быть выполнена только пользователем `root`
	+ `chown operator:bin ~/chown.me` - для объекта `~/chown.me` устанавливается собственник `operator`, группа `bin`. Команда выполняется от имени `root`
+ изменить только группу объекта - может быть выполнена обычным пользователем, но этот пользователь должен быть членом новой группы (иначе требуются привилегии `root`)
  + `chown :users ~/chown.me` - для объекта `~/chown.me` устанавливается группа `users`. Команда выполняется от члена группы `users`
+ изменить владельца и группу объекта сразу - только для `root`

`[OPTIONS]`:
+ `-c`, `--changes`: Показывает изменения только в случае их наличия.
+ `-f`, `--silent`, `--quiet`: Подавляет большинство сообщений об ошибках.
+ `-v`, `--verbose`: Выводит диагностическое сообщение для каждого обработанного файла.
+ `-R`, `--recursive`: Рекурсивно изменяет владельца и/или группу для всех файлов и директорий внутри указанной директории.
  + `chown -R :users ~` - используется для изменения группы всех файлов и директорий на `users` в вашем домашнем каталоге рекурсивно
+ `--preserve-root`: Предотвращает рекурсивное изменение владельца и группы для корневого каталога / (полезно для предотвращения случайных изменений в корневом каталоге).
+ `--no-preserve-root`: Позволяет рекурсивно изменять владельца и группу для всех файлов и директорий, включая корневой каталог (по умолчанию, эта опция включена).
+ `--reference=etalone_file`: Использует владельца и группу файла `etalone_file` для изменения владельца и группы целевого файла.
  + `chown --reference=/path/to/reference/file /path/to/target/file` - целевой файл `/path/to/target/file` получит того же владельца и группу, что и эталонный файл `/path/to/reference/file`
+ `--dereference`: Влияет на целевой файл символической ссылки, а не на саму символическую ссылку. То есть, если вы используете `chown` на символическую ссылку, будет изменен владелец целевого файла, на который указывает ссылка (по умолчанию, эта опция включена).
  + `chown --dereference newuser:newgroup /path/to/symlink` - Этот пример изменит владельца целевого файла, на который указывает символическая ссылка `/path/to/symlink`
+ `-h`, `--no-dereference`: Изменяет владельца самой символической ссылки, а не целевого файла. *Это полезно только на системах, которые поддерживают изменение владельца символических ссылок.*
  + `chown -h newuser:newgroup /path/to/symlink` - Этот пример изменит владельца самой символической ссылки `/path/to/symlink`, а не целевого файла
#### `chgrp`
`chgrp [OPTIONS] GROUP FILE..`: для изменения группы объекта (только если вы являетесь членом новой группы)
+ `chgrp users ~/chown.me` - аналогична `chown :users ~/chown.me`
+ `chgrp -R users ~` - поддерживает рекурсивный режим `-R`

Значения `[OPTIONS]` аналогичны приведенным выше для `chown` 
#### `chmod` 
`chmod` позволяет как установить новые точные разрешения сразу на определенный объект - для этого лучше использовать восьмеричную форму, так и добавить или отозвать определенные права доступа к объекту - это удобнее делать в символьном виде
 + символьный вид: `chmod [OPTIONS] [ugoa…][-+=]perms…[,…] FILE...`
   + [OPTIONS] - аналогичны опциям chown, кроме:
     + `-X`: Только для директорий и исполняемых файлов. Устанавливает бит выполнения, если файл уже имеет бит выполнения для кого-либо из пользователей. Это полезно при рекурсивном изменении прав доступа, чтобы не делать исполняемыми все файлы, а только те, которые уже были исполняемыми. Но следует отметить, что параметр `-X` добавляет право выполнения всем категориям пользователей (владельцу, группе и другим), если хотя бы одна из этих категорий уже имеет это право. Он не может быть использован для добавления права выполнения только для конкретной группы пользователей. Но если вам нужно добавить право выполнения только для конкретной группы, например, "user" и только тем файлам, которые уже исполняемые (т.е. для одного из классов: "group" или "other" установлен бит "x"), то использование команды `find` с `chmod` будет наиболее подходящим решением: `find directory -type f -perm -u=x -exec chmod g+x {} \;`
   + Первый набор флагов `([ugoa...])`, флаги пользователей, определяет, для каких классов пользователей изменяются права доступа к файлу.
     + `u` - Владелец файла.
     + `g` - Пользователи, входящие в группу.
     + `o` - Все остальные пользователи.
     + `a` - Все пользователи, идентично `ugo`, например:
       + `chmod u=rwx,g+w,o-r ~/chmod.me.file` - Разрешает владельцу делать что угодно с файлом, добавляет права на запись группе и отбирает права на чтение у прочих (`others`) 
       + `chmod -R go-rwx ~/chmod.me.dir` - отнимаем все права у группы и прочих (`others`) рекурсивно для всей директории
   + Второй набор флагов `([-+=])`, флаги операций, определяет, будут ли разрешения удалены, добавлены или установлены:
     + `-` Удаляет указанные разрешения.
     + `+` Добавляет указанные разрешения.
     + `=` Изменяет текущие разрешения на указанные. Если после символа `=` разрешения не указаны, все разрешения указанного класса пользователей будут удалены.
  + Разрешения `(perms...)` могут быть явно заданы с помощью нуля или одной или нескольких из следующих букв: `r`, `w`, `x`, `X`, `s` и `t`. 
    + При копировании разрешений из одного класса пользователей в другой используйте одну букву из набора `u`, `g` и `o` - `chmod g=u file.txt`. 
    + При установке разрешений для нескольких классов пользователей `([,...])` используйте запятые (без пробелов) для разделения символьных режимов - `chmod u+rwx,g+rx,o+r file.txt`.
+ восьмеричная форма: `chmod [OPTIONS] NUMBER FILE...`, например:
  + `chmod 751 ~/chmod.me.dir` - Устанавливает `rwxr-x--x`, т.е. `751`, на указанную директорию
## Особые случаи: символические ссылки (symbolic links), sticky bit, SUID, SGID
### Символические ссылки
Символические ссылки всегда имеют разрешения `777`, но это ничего не значит, поскольку фактические разрешения доступа такие же, как у целевого объекта:
```console
lrwxrwxrwx. 1 root root 7 янв 1 21:12 /bin -> /usr/bin
dr-xr-xr-x. 2 root root 36864 фев 19 13:31 /usr/bin
```
В примере символическая ссылка `/bin` ссылается на `/usr/bin`:
+ содержимое символической ссылки не может быть изменено, она может быть только пересоздана.
+ для пересоздания символической ссылки требуется наличие прав на запись в директорию, где эта ссылка находится.
+ разрешения доступа к символической ссылке не влияют на разрешения доступа к целевому объекту (в соответствии с  замыслом).
### Sticky bit
Sticky bit может использоваться для директорий наряду с "обычными" битами доступа `rwx`. Если он установлен, только владельцы могут удалять свои объекты, независимо от других разрешений. Sticky bit отображается как `t` в конце "слова" разрешения доступа: `drwxrwxrwt`.

**sticky bit** имеет числовое значение 1

**sticky bit** очень важен для `/tmp`, так как благодаря разрешениям `777` без установленного **sticky bit** каждый мог бы создавать и удалять там что угодно, но **Sticky bit** не позволяя удалять чужие данные

**sticky bit** может быть установлен в символьной или восьмеричной форме:
+ `chmod +t /some/dir`
+ `chmod 1xyz /some/dir`
### Биты `SUID` и `SGID`
Бит `SUID` (Set User ID) может использоваться для исполняемых файлов. Если он установлен, этот файл всегда будет выполняться от имени владельца. Бит `SUID` отображается как `s` вместо `x` в блоке разрешений владельца:
```console
# SUID binaries
[st00@c7-sandbox ~]$ ls -l /bin/passwd /bin/chsh /bin/sudo
-rws--x--x. 1 root root  23880 Feb  2  2021 /bin/chsh
-rwsr-xr-x. 1 root root  27856 Apr  1  2020 /bin/passwd
---s--x--x. 1 root root 151424 Oct 14  2021 /bin/sudo
```
Это полезно, если этот исполняемый файл а) часто используется и б) должен делать что-то с определенными правами пользователя. Например:
+ Исполняемый файл `/bin/passwd` предназначен для того, чтобы позволить пользователям изменять свой пароль. Поэтому он должен модифицировать файл `/etc/shadow`, что требует привилегий `root`.
+ Исполняемый файл `/bin/chsh` предназначен для изменения оболочки входа в систему. Поэтому он модифицирует файл `/etc/passwd`, который также разрешен только для `root`.
+ Исполняемый файл `/bin/sudo` предназначен для повышения привилегий до `root`, поэтому он обязательно должен иметь возможность запускать что-либо от имени `root`.

Бит `SUID` имеет восьмеричное значение 4

```console
# SUID bit
chmod u+s /path/to/file
chmod 4xyz /path/to/file
```
### Бит `SGID` (Set Group ID) 
Бит `SGID` (Set Group ID) также может быть использован для исполняемых файлов. Если он установлен, этот файл всегда будет выполняться от имени группы владельцев. Бит `SGID` отображается как `s` вместо `x` в блоке групповых разрешений, как показано ниже для бинарного файла `wall`. В отличие от `SUID`, бит `SGID` не используется широко:
```console
# SGID binary
[st00@c7-sandbox ~]$ ls -lF /bin/wall
-r-xr-sr-x. 1 root tty 15344 Jun 10  2014 /bin/wall*
```
Бит `SGID` имеет восьмеричное значение 2

```console
# SGID bit
chmod g+s /path/to/file
chmod 2xyz /path/to/file
```

# 09 Linux — исполняемые файлы, процессы и службы
## Исполняемые файлы в Linux
### Команды
При выполнении команд в терминале Linux, на самом деле выполняются:

+ Исполняемые файлы - файлы с установленным битом "x":
  + Двоичные исполняемые файлы, например, написанные на C/C++. Примеры: cat, less, grep. Они аналогичны файлам ".exe" в Windows
  + Скрипты, например, скрипты (сценарии) оболочки, Python и т.д. Примеры: egrep, yum (похожи на ".bat" или ".ps" в Windows).
  + Библиотеки - это двоичные файлы, подобные исполняемым файлам, но очень редко запускаемые напрямую.
  + Все вышеперечисленные исполняемые файлы, представленные в виде символических ссылок на "обычные" файлы с установленным битом "x", что широко распространено в UNIX-подобных системах.
+ Псевдонимы (алиасы) - синонимы команды (или другого псевдонима), выполняемой с определенными опциями или без них, например, псевдоним "ll" часто определяет команду "ls -l".
+ Встроенные команды оболочки. Примеры: cd, alias. При их выполнении не вызывается никакая внешняя команда, вместо этого их выполняет сама командная оболочка

Для выполнения команд пользователя и отображения их вывода используются специальные оболочки входа в систему, такие как **bash**, **zsh** и так далее
### Исполняемые файлы
#### PATH
PATH - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов. Она может быть отображена командой "echo":

```console
localhost:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```
#### Переменные оболочки
Вывод списка переменных оболочки осуществляется командой `env`
#### which
`which` - это команда для показа расположения исполняемого файла в каталогах PATH:
```console
localhost:~# which uname
/bin/uname
```
+ Любой исполняемый файл можно запустить, указав путь к нему.
+ Исполняемый файл, если он находится в директории в списке PATH, может быть запущен путем указания имени файла; путь к файлу указывать не нужно.
+ Поиск в директориях, перечисленных в PATH, выполняется последовательно. Таким образом, если файлы с одинаковым именем существуют в нескольких каталогах PATH, для выполнения будет взят файл из первой директории в переменной PATH.
+ Чтобы запустить исполняемый файл, не находящийся ни в одной из директорий в PATH, необходимо вместо имени файла указать его путь - относительный или абсолютный.
#### Управление задачами, запущенными в терминале
##### Запуск процесса в фоновом режиме
Запустить процесс в фоновом режиме можно, добавив символ `&` в конец команды. Это позволяет вашей командной строке быть доступной для ввода новых команд, пока фоновый процесс выполняет `команду &`, например `gedit &`
##### Приостановка задачи (`Ctrl+Z`)
Когда вы выполняете команду в терминале, она обычно работает в переднем плане (foreground). Если вы хотите временно приостановить выполнение этой команды, вы можете использовать сочетание клавиш `Ctrl+Z`. Это переместит задачу в состояние приостановки (stopped).
##### Перевод задачи в фоновый режим (`bg`)
`bg %ID_задачи` - Возобновляет выполнение приостановленной задачи в фоновом режиме. Если не указать ID задачи, будет использована последняя приостановленная задача. `bg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
##### Возвращение задачи в передний план (`fg`)
`fg %ID_задачи` - Возобновляет выполнение задачи в переднем плане. Если не указать ID задачи, будет использована последняя приостановленная или фоновая задача. `fg` работает только с задачами, которые были запущены из текущего терминала и отображаются в списке командой `jobs`
##### Завершение задачи (`Ctrl+C`)
`Ctrl+C`: Прерывает и завершает текущую задачу в переднем плане
##### Просмотр списка задач (jobs)
`jobs` - Отображает список всех задач в текущем терминале, их статус и ID
##### "Убийство" задачи (`kill`)
`kill %ID_задачи` - Отправляет сигнал `SIGTERM` для завершения указанной задачи. Если задача не завершится, можно использовать сигнал `SIGKILL` для принудительного завершения. *В отличие от команд `fg` и `bg` команда `kill` может завершить любой процесс, если у вас есть его PID (идентификатор процесса)*
##### Символ `%` 
Символ `%` используется для ссылки на задачи, управляемые оболочкой (shell). Он применяется с командами `fg` (`fg %ID_задачи`), `bg` (`bg %ID_задачи`) и `kill` (`kill %ID_задачи`) для указания конкретной задачи по её номеру
#### Встроенные команды и псевдонимы оболочки
Некоторые команды не являются исполняемыми файлами; вместо этого они выступают в качестве так называемых "псевдонимов" и "встроенных модулей оболочки".
##### Встроенная команда (built-in commands)
**Встроенные команды** — это команды, которые являются частью самой оболочки (например, `Bash`) и не существуют как отдельные исполняемые файлы на диске. Они выполняются непосредственно оболочкой:
+ что делает их выполнение быстрее
+ позволяет им иметь доступ к внутренним структурам оболочки, что невозможно для внешних команд.

Когда вы вводите команду в терминале, оболочка сначала проверяет, является ли эта команда встроенной. Если да, она выполняет её напрямую. Если нет, она ищет соответствующий исполняемый файл на диске и запускает его.

*Примеры встроенных команд*: `cd`: изменяет текущий каталог, `pwd`: показывает текущий каталог
##### Псевдонимы оболочки
**"Алиас" (псевдоним)** - это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments". Часто система Linux настроена так, что некоторые псевдонимы для всех пользователей доступны сразу же, например, `ll` (`ls -l`), `la` (`ls -a`).

Команда `alias` - это встроенная команда оболочки, которая возвращает просмотр список зарегистрированных в системе псевдонимов (по умолчанию какие-либо псевдонимы могут отсутствовать).

**Создание псевдонима** 

`alias имя_псевдонима='команда'`
+ Определить псевдоним, поместить его в постоянный файл конфигурации оболочки (в файлах ~/.bashrc и(или) ~/.bash_profile):
  + `echo "alias lf='ls -lF'" >> ~/.bashrc`
  + `bash` - запустить новый экземпляр оболочки (`bash`) для применения обновленной конфигурации
+ Проверка, что псевдоним добавлен - вызвать команду `alias`
+ Определить псевдоним «на ходу» (будет действовать до завершения текущего сеанса оболочки):
  + `localhost:~# alias rm='echo You are trying to execute "rm" with the following arguments: '` - теперь "оригинальную" команду `rm` можно вызвать по абсолютному пути, в таком случае выполнится именно она, а не ее псевдоним: `/bin/rm -f ~/file.to.remove`

**Отмена псевдонима**

Для отмены псевдонима вызвать встроенную команду оболочки `unalias имя_псевдонима` (из файла `~/.bashrc`, если он был туда добавлен, нужно вручную удалить соответствующую строку. Если этого не сделать то после новой сессии bash псевдоним будет снова доступен)
## Процессы и сигналы
### Процессы и демоны
#### Процессы
**Процесс** операционной системы (ОС) — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Если программа заканчивает свою работу, то процесс также прекращает своё существование.

Каждый процесс имеет несколько следующих основных атрибутов:
+ `PID` - идентификатор процесса. Уникален для каждого выполняющегося процесса. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми `PID`.
+ `PPID` — родительский идентификатор (`PID`). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, `PPID` - это `PID` родительского процесса. «Главный» системный процесс называется `init` или `systemd` и обладает `PID` = 1, `PPID` = 0. Он создаётся ядром операционной системы при её загрузке.
+ Пользователь и группа, запустившие программу.
+ Название.
+ Аргументы командной строки (но могут быть переданы процессу не только при запуске из терминала, но и при запуске из скриптов, других программ или системных служб).
+ Управляющий терминал. Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме. 
  + Например, командный интерпретатор `bash`, который обычно запускается при входе пользователя в систему, определённо взаимодействует с терминалом и пользователями, и поэтому у него есть управляющий терминал. 
  + Командная оболочка выполняет команды пользователей, поэтому она (например, `bash`) является родительским процессом всех процессов, запущенных с помощью командной строки
  + В графе "Управляющий терминал" у процесса, который был запущен из графической оболочки (например, OpenOffice), будет указано `?` или "неопределённо", т.к. графический интерфейс инициализирует процесс напрямую и управляющий терминал не наследует
  + Псевдотерминалы: когда открывают новый терминал в графической среде (например, GNOME Terminal или xterm), создается новый псевдотерминал, такой как `pts/0`
#### Демоны
**Демоны** — это особый вид процессов, работающих в фоновом режиме и не взаимодействующий с пользователями посредством терминала. Например, процессы сетевых серверных приложений, отвечающие за обработку входящих запросов по сети, обычно являются демонами. Процесс не обязательно должен быть запущен процессом с PID 1 (обычно это `init` или `systemd`), чтобы стать демоном. Однако, когда процесс становится демоном, он часто отсоединяется от своего родительского процесса и его родительским процессом становится процесс с PID 1 (`init` или `systemd`). Это происходит в процессе “демонизации”, который включает несколько шагов:
1. Форк процесса: Процесс создает копию самого себя.
2. Завершение родительского процесса: Оригинальный процесс завершает свою работу, и дочерний процесс продолжает выполнение.
3. Смена родительского процесса: Дочерний процесс становится “сиротой” и его родительским процессом становится процесс с `PID` 1 (`init` или `systemd`).
4. Отсоединение от управляющего терминала: Процесс отсоединяется от терминала, чтобы не зависеть от него.
5. Смена текущей рабочей директории: Обычно демоны меняют текущую рабочую директорию на корневую (`/`), чтобы избежать блокировки файловых систем.
6. Закрытие файловых дескрипторов: Процесс закрывает все открытые файловые дескрипторы.

Таким образом, «настоящий» процесс-демон обладает следующими свойствами:
+ `PPID` = 1
+ Управляющий терминал отсутствует (в отличие от команды, запущенной из терминала в фоновом режиме с помощью выражения `имя_команды &`, у демона в столбце `TTY` в выводе команды `ps` стоит `?`)
+ В большинстве случаев текущей рабочей директорией демона является `/`.
### Как искать процессы и просматривать их списки
Ниже приводятся некоторые из инструментов и способов получения информации обо всех или конкретных запущенных процессах:
+ `ps` — основной инструмент для отображения списка запущенных процессов
+ `top` - инструмент для отслеживания запущенных процессов в реальном времени, аналог диспетчера задач Windows и мониторинга системы macOS
+ `pgrep` - инструмент для поиска процессов по их названию или аргументам
+ `pstree` - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений
+ В псевдо-каталоге `/proc/PID` содержится много подробных сведений о процессе с идентификатором PID. Очень полезен в некоторых случаях
#### Команда `ps`
Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. Самые полезные ее опции следующие:
+ `-e` для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.
+ `-f` для вывода расширенных сведений о каждом процессе. **По умолчанию** отображается только `PID`(Идентификатор процесса), `TTY` (Терминал, связанный с процессом), `TIME` (Общее время использования процессора процессом), `CMD` (Имя команды, запустившая процесс).
  + `ps -ef` вернет следующий набор полей:
    + `UID`: имя пользователя, запустившего процесс
    + `PID`: идентификатор процесса
    + `PPID`: идентификатор родительского процесса
    + `STIME`: время запуска процесса
    + `TTY` или `TT`: управляющий терминал. Знак «?» показывается для процессов, не связанных с терминалом (таких как демоны)
    + `TIME`: суммарное процессорное время выполнения
    + `CMD`: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано. Если название процесса показано в квадратных скобках, значит, этот процесс является частью ядра ОС.
+ `-u username` для отображения процессов, запущенных пользователем c данным именем (`username`).
+ `-p PID` - для вывода сведений об процессе с данным `PID`
+ `-o` список полей для вывода определённых сведений о процессах (`ps -o pid,ppid,cmd,%cpu,%mem`):
  + `pid`: идентификатор процесса
  + `ppid`: идентификатор родительского процесса
  + `uid`: идентификатор пользователя
  + `user`: имя пользователя
  + `gid`: идентификатор группы
  + `group`: имя группы
  + `comm`: имя команды
  + `cmd`: имя команды с аргументами
  + `etime`: время, прошедшее с момента запуска процесса
  + `time`: общее процессорное время, использованное процессом
  + `stime`: время старта процесса в формате `HH:MM` (часы и минуты)
  + `%cpu` или `c`: процент использования процессора
  + `%mem`: процент использования памяти
  + `vsz`: размер виртуальной памяти
  + `rss`: размер резидентной памяти
  + `sid`: идентификатор сессии. *Сессия в контексте операционных систем — это набор процессов, которые были запущены в рамках одной сессии пользователя (временном промежутке, начиная с момента аутентификации и заканчивая выходом из системы). Каждая сессия имеет уникальный идентификатор сессии (`SID`). Сессия может включать процессы, запущенные в разных терминалах. Например, если вы открыли несколько терминалов в одной графической сессии, все процессы в этих терминалах будут принадлежать одной сессии.*
  + `tty`: терминал, связанный с процессом. *Терминал может включать процессы, принадлежащие разным сессиям. Например, если вы используете виртуальные терминалы (TTY), или в терминале запускаете процессы от разных пользователей, то они могут принадлежать разным сессиям.*
  + `stat`: состояние процесса. Варианты вывода:
    + `R`: Running (процесс выполняется)
    + `S`: Sleeping (процесс ожидает события)
    + `D`: Uninterruptible sleep (процесс ожидает события, не может быть прерван)
    + `T`: Stopped (процесс временно приостановлен). Процесс может быть остановлен пользователем с помощью сигналов `SIGSTOP` или `SIGTSTP` (например, при нажатии `Ctrl+Z` в терминале) - `kill -SIGSTOP <pid>`.
    + `Z`: Zombie (процесс завершен, но его запись еще не удалена). Процесс становится зомби, когда он завершает выполнение, но его родительский процесс еще не вызвал `wait()` для получения статуса завершения. Зомби-процессы не используют системные ресурсы (кроме записи в таблице процессов), но их наличие может указывать на проблемы с родительским процессом.
    + `X`: Dead (процесс завершен и его запись в таблице процессов удалена)
    + `W`: Paging (процесс ожидает записи или чтения страниц памяти)
    + Дополнительные символы при выводе `stat` могут включать:
      + `<`: Высокий приоритет
      + `N`: Низкий приоритет
      + `L`: Заблокирован в памяти
      + `s`: Лидер сессии — это процесс, который первым создает сессию. Его `PID` становится идентификатором сессии (`SID`). Все процессы, созданные в этой сессии, будут иметь тот же `SID`.
      + `l`: Многопоточный (использует CLONE_THREAD)
      + `+`: Процесс находится в группе процессов переднего плана
+ `--forest` служит для отображения процессов в виде дерева (аналогично команде pstree). Отображает родительские процессы и их дочерние процессы, наглядно показывая связи между ними.
#### Команда pgrep
Помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep". По умолчанию команда `pgrep` выводит идентификаторы процессов (`PID`), которые соответствуют заданным критериям поиска. Ниже приведены ее основные параметры:
+ `-c`, `--count`: Выводит количество процессов, соответствующих критериям поиска.
+ `-d`, `--delimiter <delimiter>`: Устанавливает значение, используемое для разделения идентификаторов процессов в выводе (по умолчанию - новая строка). `pgrep -d, ssh` - найдет все процессы с именем `ssh` и выведет их `PID`, разделенные запятыми
+ `-f`, `--full <condition>`: Ищет процессы по полному командному строковому имени.
+ `-g`, `--pgroup <pgrp>`: Ищет процессы в указанных группах процессов. Группа процессов — это набор процессов, которые имеют один и тот же идентификатор группы процессов (`PGID`). *Группа процессов имеет уникальный идентификатор группы процессов (`PGID`), который совпадает с идентификатором процесса (`PID`) лидера группы. Лидер группы процессов: Это процесс, который первым создает группу процессов. Его `PID` становится `PGID` для всей группы. Группы процессов позволяют управлять несколькими процессами одновременно. Например, можно отправить сигнал всем процессам в группе.*
+ `-G`, `--group <gid>`: Ищет процессы, принадлежащие указанным группам пользователей (group `IDs`).
+ `-i`, `--ignore-case`: Игнорирует регистр при поиске.
+ `-l`, `--list-name`: Выводит имя процесса вместе с его `PID`.
+ `-a`, `--list-full`: Выводит полную командную строку вместе с `PID`.
+ `-n`, `--newest`: Ищет только самые недавно запущенные процессы.
+ `-o`, `--oldest`: Ищет только самые старые процессы.
+ `-O`, `--older <secs>`: Ищет процессы, запущенные более указанного количества секунд назад.
+ `-P`, `--parent <ppid>`: Ищет процессы, у которых указанный `PID` является родительским.
+ `-s`, `--session <sid>`: Ищет процессы в указанных сессиях.
+ `-t`, `--terminal <term>`: Ищет процессы, запущенные в указанных терминалах. *Терминал может включать процессы, принадлежащие разным сессиям. Например, если вы используете виртуальные терминалы (TTY), каждый терминал может иметь свои процессы, принадлежащие разным сессиям.*
+ `-u`, `--euid <euid>`: Ищет процессы, запущенные пользователями с указанным эффективным идентификатором пользователя (`EUID`). Эффективный `UID` используется системой для определения прав доступа процесса. Это может быть полезно, когда процесс выполняется с правами другого пользователя (например, через `sudo`). `pgrep -u root` - Этот пример найдет все процессы, запущенные с правами пользователя `root`.
+ `-U`, `--uid <uid>`: Ищет процессы, запущенные указанными пользователями. Ищет процессы, запущенные пользователями с указанным реальным идентификатором пользователя (`UID`). Реальный `UID` — это идентификатор пользователя, который изначально запустил процесс. `pgrep -U root` - Этот пример найдет все процессы, изначально запущенные пользователем root.
+ `-v`, `--inverse`: Ищет процессы, не соответствующие указанным критериям.
+ `-x`, `--exact`: Ищет процессы, имя которых точно совпадает с указанным шаблоном.
#### Псевдо-директория `/proc`
+ `/proc` - виртуальная файловая система, содержащая множество сведений о работающих процессах. В реальности на диске нет файлов, расположенных в директории `/proc`. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории `/proc`.
+ Все команды, относящиеся к процессам, такие как `ps`, `pstree`, `pgrep`, берут информацию из директории `/proc`.
+ Можно получить информацию о ваших процессах напрямую из директории `/proc`

Поскольку `/proc` представляется как обычная директория, к ней применимы почти все известные команды, предназначенные для работы с директориями. Например, `ls` для вывода списка содержимого, `egrep -r` для рекурсивного поиска последовательности символов и т.д.:
+ Чтобы определить точный путь к исполняемому файлу конкретного процесса, который обычно не отображается в выводе команды `ps`:
```console
ls -l /proc/айди_процесса/exe
lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/айди_процесса/exe -> /path/to/executable/file
```

+ Чтобы выяснить текущую рабочую директорию конкретного процесса:
```console
ls -l /proc/айди_процесса/cwd
lrwxrwxrwx 1 user user 0 Jun 11 13:45 /proc/1234/cwd -> /path/to/current/directory
```
#### Отслеживание процессов и команда top
Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу (похожа на диспетчер задач Windows)

Команда top полезна для:
+ Поиска процессов, которые больше других потребляют ресурсы процессора и памяти.
+ Определение текущей загрузки системы.
### Сигналы
**Сигнал** — это короткое сообщение, которое можно отправить процессу
+ `kill [-ЧТО] PID` - отправляет сигнал ЧТО (например, `TERM`, `KILL`, `STOP` и т. д.) процессу с идентификатором PID
  + `kill -KILL PID` или `kill -9 PID`
+ `killall [-ЧТО] [другие опции] название_процесса` - отправляет один и тот же сигнал нескольким процессам с одинаковым названием, более подробно синтксис функции:
  + `killall [-Z, --context шаблон] [-e, --exact] [-g, --process-group] [-i, --interactive] [-n, --ns PID] [-o, --older-than ВРЕМЯ] [-q, --quiet] [-r, --regexp] [-s, --signal СИГНАЛ, -СИГНАЛ] [-u, --user пользователь] [-v, --verbose] [-w, --wait] [-y, --younger-than ВРЕМЯ] [-I, --ignore-case] [-V, --version] [--] название_процесса … :`
    + `-e, --exact` - Требовать полного совпадения для очень длинных имён. Если имя команды длиннее чем 15 символов, то полное имя может быть недоступно (т. е., часть затёрлась). В этом случае, killall завершит все процессы, совпадающие по первым 15 символам. С параметром -e такие элементы не обрабатываются. killall выводит сообщение для каждого необработанного элемента, если вместе с -e дополнительно указан параметр -v.
    + `-I, --ignore-case` - Игнорировать регистр символов в именах процессов.
    + `-g, --process-group` - Завершить группу процесса, в которую входит процесс. На всю группу посылается только один сигнал завершения, даже если в группе найдено несколько процессов.
    + `-i, --interactive` - Запрашивать подтверждение перед завершением процессов.
    + `-l, --list` - Показать все известные имена сигналов.
    + `-n, --ns` - Искать процессы в том же пространстве имён PID что и у PID. По умолчанию поиск выполняется по всем пространствам имён.
    + `-o, --older-than` - Искать процессы, старее (запущенные до) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + `-q, --quiet` - Не сообщать, если ни одного процесса не завершено.
    + `-r, --regexp` - Рассматривать шаблон имени процесса как расширенное регулярное выражение POSIX согласно regex(3).
    + `-s, --signal, -СИГНАЛ` - Посылать указанный СИГНАЛ, а не SIGTERM.
    + `-u, --user` - Завершить процессы, принадлежащие указанному пользователю. Имена команд необязательны.
    + `-v, --verbose` - Уведомлять об успешной отправке сигнала.
    + `-V, --version` - Показать информацию о версии.
    + `-w, --wait` - Ожидать завершения процессов. killall проверяет раз в секунду существование завершаемых процессов и прекращает работу только если никого не осталось.Заметим, что killall может ждать вечно, если сигнал был проигнорирован, никак не повлиял или если процесс остался в состоянии зомби.
    + `-y, --younger-than` - Искать процессы, новее (запущенные после) заданного времени. Время задаётся в виде числа с плавающей точки и идентификатора. Идентификаторами могут быть s,m,h,d,w,M,y (секунды, минуты, часы, дни, недели, месяцы и года, соответственно).
    + `-Z, --context` - Задать контекст безопасности: завершать только процессы с контекстом безопасности, который совпадает с заданным шаблоном расширенного регулярного выражения. В командной строке должен указываться раньше остальных параметров. Имена команд необязательны.
 + `pkill [-ЧТО][другие опции] название_процесса` - отправляет один и тот же сигнал нескольким процессам, названия которых отвечают некоторому условию. Похожа на команду `pgrep`. , более подробно синтксис функции:
   + `pkill [-signal] [-fvx] [-n|-o] [-P ppid,...] [-g pgrp,...][-s sid,...] [-u euid,...] [-U uid,...] [-G gid,...][-t term,...] [pattern]`
     + `-f` - Обычно шаблон сопоставляется только с именем процесса. Если задано значение -f, используется полная командная строка
     + `-g pgrp,...` - Искать процессы только в перечисленных идентификаторах групп процессов. Группа процессов 0 переводится в собственную группу процессов pgrep или pkill.
     + `-G gid,...` - Искать только те процессы, реальный идентификатор группы которых указан в списке. Может использоваться как числовое, так и символическое значение.
     + `-n` - Выберите только самый новый (недавно запущенный) из совпадающих процессов.
     + `-o` - Выберите только самый старый (запущенный совсем недавно) из соответствующих процессов.
     + `-P ppid,...` - Совпадают только те процессы, идентификатор родительского процесса которых указан в списке.
     + `-s sid,...` - Искать только те процессы, идентификатор сеанса которых указан в списке. Идентификатор сеанса 0 транслируется в собственный идентификатор сеанса pgrep или pkill.
     + `-t term,...` - Искать только те процессы, управляющий терминал которых указан в списке. Имя терминала должно быть указано без префикса "/dev/".
     + `-u euid,...` - Искать только те процессы, чей эффективный идентификатор пользователя указан в списке. Может использоваться как числовое, так и символическое значение.
     + `-U uid,...` - Искать только те процессы, в списке которых указан реальный идентификатор пользователя. Может использоваться как числовое, так и символическое значение.
     + `-v` - Искать обратное соответствию.
     + `-x` - Искать только те процессы, имя которых (или командная строка, если указано -f) точно соответствует шаблону.
     + `-signal` - Определяет сигнал, посылаемый каждому сопоставленному процессу. Можно использовать как числовое, так и символическое имя сигнала.
#### Полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:
+ `TERM (15)`, `terminate` — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
+ `KILL (9)`, `kill` — уничтожить: безусловное завершение работы процесса, не может быть проигнорирован процессом
+ `INT (2)`, `interrupt` — прервать посредством терминала: отправляется, когда пользователь нажимает клавиши `Ctrl+C`. По умолчанию `SIGINT` завершает процесс, но процесс может перехватить сигнал и выполнить какую-либо очистку, альтернативное действие перед завершением или проигнорировать
+ `TSTP (20)`, `terminal (TTY) stop` — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши `Ctrl+Z`. Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.
+ `STOP (19)`, `stop` — приостанавливает работу процесса аналогично `TSTP`, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал `KILL`, не может быть проигноирован процессом.
+ `CONT (18)`, continue — продолжить: отправляется, когда пользователь выполняет команду `fg` или `bg` с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала `STOP`, можно возобновить сигналом `CONT`.
## Службы (services) Linux
 **Служба Linux** - "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС. **Служба Linux**, построена вокруг программы и отвечает на вопрос "КАК именно следует управлять этой программой":
+ Должна ли она запускаться во время загрузки системы?
+ Как запустить ее вручную при необходимости?
+ Какие опции предоставляются программе при запуске?
+ Как отслеживать ее состояние?
+ Как аккуратно завершить ее работу?
+ Нужно ли перезапускать ее в случае нештатного завершения?
+ Какие другие службы должны быть запущены перед запуском этой конкретной?
### Systemd
+ Systemd — это комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами (принята как замена системы инициализации SysV init).
+ Systemd оперирует следующими объектами, называемыми "юнитами":
  + Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
  + Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
  + сокеты, таймеры и др.
### Службы в контексте systemd
+ Службы, добавленные к systemd вместе с их настройками (известными также как **юнит-файлы**), находятся в директории `/etc/systemd/system` и ее вложенных директориях. Обычно **юнит-файлы представляют собой символьные ссылки** на «настоящие» файлы, расположенные в директории `/usr/lib/systemd/system`.
### Структура Unit-файла сервиса
```console
[Unit]
Description=Краткое описание сервиса
Documentation=URL-документации
Requires=другие_юниты_требуемые_для_запуска
Wants=другие_юниты_желательные_для_запуска
After=юниты_которые_должны_запуститься_перед_этим
Before=юниты_которые_должны_запуститься_после_этого
Conflicts=юниты_которые_конфликтуют_с_этим
ConditionPathExists=/путь/к/файлу (условие для запуска)

[Service]
Type=simple (или другие типы: forking, oneshot, dbus, notify, idle)
ExecStart=/путь/к/исполняемому_файлу (основная команда для запуска сервиса)
ExecStartPre=/путь/к/исполняемому_файлу_предварительно (команда, выполняемая перед запуском основного процесса)
ExecStartPost=/путь/к/исполняемому_файлу_после (команда, выполняемая после запуска основного процесса)
ExecStop=/путь/к/исполняемому_файлу_для_остановки (команда для остановки сервиса)
ExecReload=/путь/к/исполняемому_файлу_для_перезагрузки (команда для перезагрузки сервиса)
Restart=always (политика перезапуска: no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, или always)
RestartSec=5 (время ожидания перед перезапуском)
User=имя_пользователя (пользователь, от имени которого запускается сервис)
Group=имя_группы (группа, от имени которой запускается сервис)
WorkingDirectory=/путь/к/рабочему_каталогу (рабочий каталог для процесса)

[Install]
WantedBy=multi-user.target (указывает таргеты, в которые включен этот юнит)
RequiredBy= (другие юниты, которые зависят от этого юнита)
Also= (другие юниты, которые должны быть включены вместе с этим)
Alias= (другие имена для этого юнита)
`
+ Раздел [Unit] содержит общую информацию о юните и его зависимостях
+ Раздел [Service] используется для определения параметров и команд, необходимых для запуска, остановки и перезапуска сервисов.
+ Раздел [Install] определяет параметры, связанные с установкой и включением юнита.
#### Вывод списка активных служб (units) в системе, управляемой systemd
`systemctl list-units --type=service` показывает только те службы, которые в данный момент активны (запущены или в других состояниях активности)
`console
$ systemctl list-units --type=service
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
apparmor.service                    loaded active exited  Load AppArmor profiles
...
```
где 
+ `UNIT`: Название службы.
+ `LOAD`: показывает статус загрузки конфигурационного файла сервиса. Возможные значения:
  + `loaded`: Конфигурационный файл сервиса загружен и разобран успешно.
  + `not-found`: Конфигурационный файл сервиса не найден.
  + `error`: Произошла ошибка при загрузке конфигурационного файла.
  + `masked`: Сервис замаскирован, что предотвращает его случайный запуск
+ `ACTIVE`: показывает общий статус активности сервиса. Возможные значения:
  + `active`: Сервис запущен и работает нормально.
  + `reloading`: Сервис в процессе перезагрузки конфигурации.
  + `inactive`: Сервис не запущен.
  + `failed`: Сервис завершился с ошибкой.
  + `activating`: Сервис находится в процессе запуска.
  + `deactivating`: Сервис находится в процессе остановки.
+ `SUB`: показывает более детальную информацию о состоянии сервиса, дополняя статус в столбце ACTIVE. Возможные значения различаются в зависимости от типа сервиса, но некоторые примеры включают:
  + `running`: Сервис запущен и работает (соответствует active в ACTIVE).
  + `exited`: Сервис завершил работу (может быть нормальное завершение, соответствует inactive в ACTIVE).
  + `dead`: Сервис не работает и не запускается (соответствует inactive в ACTIVE).
  + `auto-restart`: Сервис настроен на автоматический перезапуск (обычно временный статус).
  + `failed`: Сервис завершился с ошибкой (соответствует failed в ACTIVE).
+ `DESCRIPTION`: Описание службы.
#### Вывод списка активных служб (units) в системе, которые находятся в состоянии "running"
```console
$ systemctl list-units --type=service --state=running
UNIT                                LOAD   ACTIVE SUB     DESCRIPTION
accounts-daemon.service             loaded active running Accounts Service
avahi-daemon.service                loaded active running Avahi mDNS/DNS-SD Stack
...
```
#### Вывод всех файлов units (сервисов) вместе с их состоянием включения
`systemctl list-unit-files` отображает все доступные на системе файлы unit (сервисы), вне зависимости от их текущего состояния активности
```console
$ systemctl list-unit-files --type=service
UNIT FILE                                   STATE   
accounts-daemon.service                     enabled 
apparmor.service                            enabled 
apt-daily-upgrade.service                   enabled 
dbus-org.bluez.service                      alias   
dbus.service                                static  
debug-shell.service                         disabled
grub-common.service                         masked  
...
```
##### Группа состояний настройки запуска служб
+ `enabled`: Служба настроена на автоматический запуск при загрузке системы.
+ `disabled`: Служба не настроена на автоматический запуск при загрузке системы.
+ `static`: в unit-файле службы отсутствует секция [Install], что делает их неспособными к автоматическому запуску. Они могут быть запущены вручную или как зависимости других служб.
+ `masked`: Служба замаскирована это значит, что она заблокирована для запуска и не может быть запущена ни вручную, ни автоматически, пока не будет размаскирована. Замаскированная служба фактически отключена и недоступна для выполнения. `systemctl mask|unmask example.service`
+ `alias`: Служба является псевдонимом другой службы.

Чтобы увидеть только включенные службы, выполните:
`systemctl list-unit-files --type=service --state=enabled` - вернёт список всех unit-файлов для сервисов (.service), которые включены (enabled) в системе. Включенные сервисы автоматически запускаются при загрузке системы или при активации соответствующего таргета.
#### Проверка текущего состояния службы (по названию)
`systemctl status название_службы`
#### Проверка текущего состояния службы (по процессу)
`systemctl status PID_процесса`
#### Запуск/остановка/перезапуск службы
```console
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
Для выполнения необходимы права root
#### Включение и отключение автоматического запуска службы на этапе загрузки ОС
`systemctl enable|disable [--now] название_службы` - включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы).

Для выполнения необходимы права root
#### Узнать настройки автоматического запуска конкретной службы
`systemctl is-enabled название_службы`
## Отличие сервисов (служб) от приложений
| | Серверные приложения | Службы systemd |
|-------------|-------------|-------------|
| Основное назначение    | Обработка запросов пользователей и выполнение действий в рамках прикладной логики (например, сервер MySQL сохраняет данные и обрабатывает запросы на языке SQL)    | Упрощение управления приложениями (запуск, останов, перезапуск, проверка состояния и т. д.)    |
| Управление приложениями    | Для каждого серверного приложения (если он запущено само по себе, а не как служба) предусмотрен свой способ управления. Даже простые операции (проверка, запуск, перезапуск, останов) разных приложений имеют свои особенности    |Приложения, "обернутые" в сервис, управляются одним и тем же способом — посредством команды systemctl и её опций.    |
| Конфигурация | Хранится в файле конфигурации, специфичном для приложения (например, /etc/my.cnf). Содержит главные параметры приложения, такие как прослушиваемые порты, степень подробности журналирования, настройки проверки подлинности пользователей и многие другие | Хранится в юнит-файлах с общим форматом (например, /usr/lib/systemd/system/mysqld.service). Содержит условия запуска, требуемые права пользователя, внешние зависимости от других служб, действия при запуске и останове, путь к исполняемому файлу и аргументы. Не описывает конфигурацию самого приложения! |
| Журналирование (логирование)    | Полностью зависит от конкретного приложения. Настройки журналирования (например, степень подробности и формат) очень гибкие и задаются в файле(ах) конфигурации приложений. Журналы чаще всего представляют собой текстовые файлы (например, /var/log/mysqld.log)    | Файлы журналов служб systemd: обычно содержат меньше информации по сравнению с файлами журналов приложений (записываются только основные события); хранятся в едином двоичном формате; доступ к ним можно получить с помощью команды journalctl    |
## Юнит-файлы сервисов по сравнению с файлами конфигурации приложений
|  | Файл конфигурации приложения java-auth | Юнит-файл сервиса java-auth.st00 |
|-------------|-------------|-------------|
| Местоположение файлов конфигурации    | Полностью зависит от самого приложения. В нашем примере далее показан файл /apps/java/auth/st00/application.properties. Конфигурации основных серверных приложений (например, SSH server) часто содержатся в директории/etc    | Обычно где-то в директории /usr/lib/systemd/system (сами конфигурации) и (или) /etc/systemd/system (обычно символьные ссылки на файлы конфигурации). Показанный далее юнит-файл взят из /etc/systemd/system/multi-user.target.wants/java-auth.st00.service    |
| Основное назначение    | Содержит специфичные для приложения настройки, такие как используемые сервером порты, адрес и тип базы данных для подключения, учётная запись и пароль базы данных. Формат файла и набор параметров полностью зависит от каждого приложения. В нашем примере используется очень простое учебное приложение. Реальное серверное приложение может предусматривать огромные файлы конфигурации с тысячами строк.    | Содержит стартовые условия запуска, требуемые права пользователя (см. переменные User и Group далее), внешние зависимости от других служб (см. After), действия при запуске и останове (см. ExecStop), путь к исполняемому файлу (см. ExecStart) и аргументы. Не описывает конфигурацию самого приложения! Формат един для всех служб системы.    |
| Содержимое файла    | server.port=7000<br> debug=false<br> spring.jpa.hibernate.ddl-auto=updates<br> spring.datasource. url=jdbc:mysql://192.168.40.150:3306/auth_st00<br> spring.datasource.username=dbst00<br> spring.datasource.password=your_password_here    | [Unit]<br>Description=Java auth service for Roles app, per user<br> After=network.target<br><br>[Service]<br>SuccessExitStatus=143<br> User=st00<br> Group=qa<br> Type=simple<br> ExecStart=/apps/java/auth/st00/java-start-auth.sh<br> ExecStop=/bin/kill -15 $MAINPID<br> TimeoutSec=60<br><br>[Install]<br> WantedBy=multi-user.target    |
## Journalctl: вывод журналов служб systemd
`journalctl` — это инструмент для управления журналами служб systemd. 

Для выполнения этой команды необходимы права `root` или включение в группу `systemd-journal`.

### Просмотр всех записанных в журнал событий для службы (по имени)
`journalctl -u service_name` (`journalctl  -e -u service_name` - то же, но с переходом к последним строкам журнала)
### Отслеживание событий службы в реальном времени и вывод их на терминал
`journalctl -f -u service_name` - наподобие команды `tail -f` 
### Просмотр событий от нескольких служб одновременно
`journalctl -u service_name_1 -u service_name_2 ...` - Эту функцию можно сочетать с другими опциями, например -f

# 10 Linux - окружение, архивы, файловые системы
## Информация о системе. Что и как собирать
При создании отчёта о дефекте важно предоставить информацию об окружении, в котором дефект был найден. Наиболее востребованная и запрашиваемая информация следующая:
+ Версия ядра операционной системы (ОС).
+ Название и версия дистрибутива Linux.
+ Имя компьютера, IP-адрес(а) и другие настройки сети (об этом поговорим в секциях, посвящённых сетям).
+ (В некоторых случаях.) Запущенные процессы и службы — это мы подробно обсудили в предыдущей секции.
+ (В некоторых случаях.) Сведения об аппаратном обеспечении: центральном процессоре (ЦП), памяти и жёстких дисках.
+ (В некоторых случаях.) Подключённые файловые системы, их полный и свободный объём.
### Операционная система и дистрибутив Linux
#### Ядро (Linux Kernel):
##### Определение
Ядро — это центральный компонент операционной системы, который управляет аппаратными ресурсами компьютера и предоставляет основные услуги для других частей системы.
##### Функция
Ядро управляет процессами, памятью, файловыми системами, аппаратными устройствами (через драйверы) и обеспечивает коммуникацию между программным обеспечением и аппаратным обеспечением.
##### Примеры версий ядра
5.4.0, 4.19.0, 3.10.0.
##### Состав
Содержит модули для управления памятью, процессами, файловыми системами, сетевыми стеками, драйверами устройств и прочими низкоуровневыми функциями.
#### Архитектура (Hardware Architecture):
##### Определение
Архитектура — это дизайн и структура аппаратного обеспечения, на котором работает операционная система.
##### Примеры
x86 (32-битная архитектура), x86_64 (64-битная архитектура, также известная как AMD64), ARM, ARM64.
##### Функция
Определяет, каким образом процессор и другие компоненты компьютера взаимодействуют и обрабатывают инструкции.
##### Состав
Описывает процессорные регистры, команды, размер адресного пространства, способ взаимодействия с памятью и периферийными устройствами.
#### Дистрибутив (дистрибутивная версия):
##### Определение
Дистрибутив Linux — это комплект программного обеспечения, основанный на ядре Linux и включающий в себя различные дополнительные компоненты, такие как системные библиотеки, приложения, утилиты и средства управления пакетами.
##### Примеры
Ubuntu, Fedora, Debian, Arch Linux.
##### Функция
Дистрибутивы обеспечивают удобную установку и использование операционной системы, предоставляют предварительно настроенные и готовые к использованию системы, а также регулярно выпускают обновления и исправления.
##### Состав
Включает ядро Linux, системные утилиты, графические интерфейсы, менеджеры пакетов (например, apt для Debian/Ubuntu, dnf для Fedora), и другие приложения.
#### Методы получить информацию про дистрибутив и ядро
+ ```uname``` - Узнать название ОС
+ ```uname -r``` - Узнать версию ядра ОС
+ ```uname -a``` - Узнать больше сведений о компьютере, включая имя узла
+ ```cat /etc/os-release``` - Узнать версию дистрибутива Linux
+ ```cat /etc/debian_version``` - Узнать точную версию дистрибутива Linux (например, 11.2)
+ ```hostnamectl``` -  Узнать информацию о системе, включая операционную систему, ядро и архитектуру (используется в системах, работающих с systemd):
```console
$ hostnamectl
   Static hostname: myhostname
         Icon name: computer-laptop
           Chassis: laptop
  Operating System: Ubuntu 20.04.2 LTS
            Kernel: Linux 5.4.0-73-generic
      Architecture: x86-64
```
### Сведения об аппаратном обеспечении и производительности
#### CPU (процессоры)
Один физический процессор, который содержит четыре ядра с двумя потоками в каждом, будет виден операционной системе как восемь отдельных процессоров, способных одновременно обрабатывать восемь вычислительных задач

**Ядро** — это по большей части независимый вычислительный блок внутри процессора, способный выполнять программы самостоятельно, без взаимодействия с другими ядрами. Поэтому каждое ядро операционная система воспринимает как отдельный процессор

**Потоки**: для многопоточных ядер возможно одновременное выполнение более одного процесса на ядро. Это не означает, что одно многопоточное ядро имеет такую же производительность, как два однопоточных; на самом деле, этот показатель можно приблизительно оценить как 1,5

**Тактовая частота процессора**: чем больше значение частоты в МГц, тем быстрее выполняются инструкции процессора, что приводит к повышению производительности
1. Команда ```lscpu```. Предоставляет следующую информацию:
  + **Architecture (архитектура)**: в большинстве современных устройств это x86_64, но могут встречаться и другие. Например: процессор с архитектурой ARM не может выполнять программы, написанные для x86_64.
  + CPU(s) (процессор): суммарное количество потоков = количество ЦП × кол-во ядер на разъём × кол-во потоков на ядро.
  + **On-line CPU(s) list** (список процессоров, отображаемый в реальном времени): какие ядра доступны в текущий момент; в большинстве случаев доступны все ядра. Номера процессоров начинаются с 0.
  + **Thread(s) per core**: (потоков на ядро): как говорилось выше, существуют однопоточные и многопоточные процессоры. Эти сведения указываются в этом поле.
  + **Core(s) per socket**: (ядер на разъём): количество ядер у каждого процессора.
  + **Socket(s)**: (разъёмы): количество процессоров (не ядер), установленных на компьютере. Для бытовых устройств, таких как настольные персональные компьютеры, ноутбуки и т. д., этот параметр почти всегда равен 1. Для мощных серверов этот параметр, как правило, превышает 1.
  + **Vendor ID, Model name** (идентификатор производителя, название модели): описывает модель процессора.
  + **CPU MHz**: (частота процессора в МГц): частота, которая может динамически варьироваться, как видно на снимке экрана, показанного выше
2. Команда ```cat /proc/cpuinfo``` - выводит ту же информацию, но сведения для каждого ядра ЦП приводятся отдельно. Поэтому объём данных в этом файле намного больше, они представлены в менее ясной форме и не содержат ничего нового по сравнению с выводом команды lscpu.
3. Команда ```top``` в Linux в Linux предоставляет информацию о текущих процессах и использовании системных ресурсов в реальном времени.  Пример вывода команды top: ```%Cpu(s):  2.3 us,  1.5 sy,  0.0 ni, 95.7 id,  0.3 wa,  0.0 hi,  0.2 si,  0.0 st```
+ Поля ```us```, ```sy```, ```ni``` в верхней части вывода команды top отображают процентное использование процессора различными типами задач (постоянно высокие значения полей ``us``, ```sy```, ```ni``` означают, что компьютер находится под высокой нагрузкой):
  + ```us (user)```: Процент времени, в течение которого процессор занят выполнением задач в пользовательском пространстве (user space). Это время включает выполнение приложений и команд, запущенных пользователем, за исключением задач с изменённым приоритетом.
  + ```sy (system)```: Процент времени, в течение которого процессор занят выполнением задач в системном пространстве (kernel space). Это время включает выполнение системных вызовов, работы с драйверами и другими задачами ядра.
  + ```ni (nice)```: Процент времени, в течение которого процессор занят выполнением задач с изменённым приоритетом (nice value). Это пользовательские процессы, которым было присвоено определённое значение приоритета (nice value), влияющее на их приоритет выполнения.
+ Поле ```wa (wait)``` отображает процент времени, в течение которого процессор не выполняет никаких задач, так как он ждет, пока операции ввода-вывода (I/O wait), например, ожидание данных от жесткого диска, сетевых устройств и других периферийных устройств, будут завершены
+ Для сохранения вывода команды top в файл, включая значения ```%Cpu(s)```, можно использовать перенаправление вывода команды в файл: ```top -b -n 1 | grep -E '^%Cpu' > cpu_usage.txt```, где
  + ```top -b -n 1```: Запускает команду ```top``` в пакетном режиме (```-b```), который выводит результаты в текстовом формате, а также останавливает команду после выполнения одного цикла. Параметр ```-n 1``` указывает, что ```top``` должен выполнить только один цикл и завершиться.
  + ```grep -E '^%Cpu'```: Фильтрует вывод ```top```, оставляя только строки, начинающиеся с ```%Cpu```. Параметр ```-E``` позволяет использовать расширенные регулярные выражения.
  + ```> cpu_usage.txt```: Перенаправляет вывод отфильтрованной команды в файл cpu_usage.txt.
#### Оперативная память
В современных операционных системах используется два типа памяти:
+ RAM (ОЗУ, оперативное запоминающее устройство): это «настоящая» память.
+ Swap (память подкачки): память на диске, обычно используемая для выгрузки на диск неактивных приложений, когда ОЗУ заполнено. Она намного медленнее по сравнению с ОЗУ, поэтому если память подкачки активно используется, то работа компьютера будет также значительно замедленна.
1. Команда```free``` - используется для вывода информации (по умолчанию - на экран терминала) об использовании оперативной памяти (RAM) и области подкачки (swap). Она предоставляет общее количество доступной, используемой, свободной памяти и размер подкачки. Поля вывода ```free```:
  + ```total```: Общее количество памяти в системе.
  + ```used```: Количество использованной памяти.
  + ```free```: Количество доступной свободной памяти для новых процессов.
  + ```shared```: Количество памяти, которая используется для совместного использования между процессами.
  + ```buff/cache```: Количество памяти, используемой в качестве кэша и буферов.
  + ```available```: Оценка доступной памяти для новых процессов, учитывая кэш и буферы (которые можно очистить).
  + пример ```free -m``` - команда возвращает объём памяти в МБ (по умолчанию - в килобайтах)
#### Другие параметры: lsblk, lsusb, lspci 
##### lsblk
Используется для вывода информации о блочных устройствах, таких как жесткие диски и разделы, на вашей системе. Она предоставляет структурированный список блочных устройств, их разделов и связанных с ними меток

Пример вывода ```lsblk```:

```console
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda           8:0    0 931.5G  0 disk 
├─sda1        8:1    0   512M  0 part /boot/efi
├─sda2        8:2    0   244M  0 part /boot
└─sda3        8:3    0 930.8G  0 part 
  └─ubuntu--vg-root
            252:0    0 917.8G  0 lvm  /
sr0          11:0    1  1024M  0 rom  
```
*Поля вывода lsblk*:
+ NAME: Имя устройства.
+ MAJ:MIN: Мажорный и минорный номера устройства.
+ RM: Съемное устройство (1) или нет (0).
+ SIZE: Общий размер устройства.
+ RO: Флаг "только для чтения" (1) или нет (0).
+ TYPE: Тип устройства (disk, part, rom и т. д.).
+ MOUNTPOINT: Точка монтирования для раздела или устройства. !!! Эту информацию можно также получить с помощью команд ```mount``` и ```df```

*Какие устройства отображаются lsblk*:
+ ```sda```, ``sdb``, ...: Жесткие диски.
+ ```sda1```, ```sda2```, ...: Разделы на жестком диске.
+ ```sr0```, ```sr1```, ...: CD/DVD-ROM устройства.
+ ```mmcblk0```, ```nvme0n1```, ...: Другие блочные устройства:
  + ```mmcblkX```: MMC/SD устройства: Например, SD-карты или eMMC-накопители.
  + ```nvme0nX```: NVMe устройства: SSD, подключенные через интерфейс NVMe

*Полезные флаги команды lsblk:*
+ ```-f```: Выводит подробную информацию о файловой системе.
+ ```-m```: Отображает информацию в мегабайтах, гигабайтах и т. д.
+ ```-p```: Показывает устройства в виде полных путей к устройствам.
+ ```-o```: Позволяет выбрать, какие поля должны быть отображены в выводе, например ```lsblk -o NAME,TYPE,TRAN``` в поле TRAN вернет тип интерфейса, через который подключено устройство (например, sata, usb, nvme и т.д.)
##### lsusb
Используется для вывода списка всех периферийных устройств, обычно подключаемых к порту USB компьютера, и информации о них.

Пример вывода ```lsusb```:

```console
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 004: ID 046d:c534 Logitech, Inc. Unifying Receiver
Bus 001 Device 003: ID 045e:07fd Microsoft Corp. Nano Transceiver 1.1
Bus 001 Device 002: ID 2109:0813 VIA Labs, Inc. USB2.0 Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```
##### lspci
Используется для вывода списка всех устройств, подключенных к шине PCI (Peripheral Component Interconnect) в вашем компьютере, и информации о них (сетевые интерфейсы, контроллеры Wi-Fi, видеокарты и т.д.)

Пример вывода ```lspci```

```console
00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6/7th Gen Core Processor Host Bridge/DRAM Registers (rev 02)
00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor PCIe Controller (x16) (rev 02)
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 630 (rev 04)
00:04.0 Signal processing controller: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem (rev 02)
```
##### /etc/network/interfaces
Файл ```/etc/network/interfaces``` обычно используется для настройки сетевых интерфейсов в системах на базе Debian и Ubuntu Linux, а также в других дистрибутивах, использующих инструменты настройки сети, основанные на ifupdown
+ ```sudo nano /etc/network/interfaces```
## Файловые системы
+ Каждая файловая система ОС Linux подключена к определённому месту главного «дерева» иерархии файлов и директорий.
+ Действие по подключению файловой системы к надлежащему месту дерева называется монтированием (mounting)
+ Специальное место называется точкой монтирования (mounting point). Точка монтирования — это существующая директория
### mount
С помощью команды ```mount``` можно посмотреть, как физические (и виртуальные) устройства подключены к своим точкам монтирования:
```console
[st00@c7-sandbox ~]$ mount | egrep -v tmpfs | egrep /dev 
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
/dev/mapper/rootvg-rootlv on / type ext4 (rw,relatime,seclabel,data=ordered)
mqueue on /dev/mqueue type mqueue (rw,relatime,seclabel)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,seclabel)
/dev/sda1 on /boot type ext4 (rw,relatime,seclabel,data=ordered)
/dev/mapper/rootvg-tmplv on /tmp type ext2 (rw,relatime,seclabel)
/dev/mapper/rootvg-homelv on /home type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)
```
**Третье «слово»** каждой строки содержит соответствующую точку подключения, например /, /boot, /tmp, /home. !!! Информацию про точку монтирования можно также получить с помощью команд ```lsblk``` и ```df```
#### Основные концепции LVM
LVM (Logical Volume Manager) — это система управления логическими томами в Linux, которая позволяет гибко управлять дисковым пространством. LVM включает и управляет:
1. Physical Volumes (PV): Это физические устройства, такие как разделы жестких дисков или целые диски, которые инициализированы для использования с LVM. Пример:
   + ```/dev/sda4, /dev/sdb1```.
2. Volume Groups (VG): Это группы томов, которые объединяют несколько физических томов (PV) в единое адресное пространство. Пример:
   + ```ubuntu-vg```.
3. Logical Volumes (LV): Это тома, которые создаются внутри группы томов (VG). Логические тома могут использовать пространство, предоставляемое всеми физическими томами в группе томов. Пример:
   + ```root```, ```home```, ```swap```.

*Пример использования LVM при подготовке и монтировании логического тома*
1. Инициализация физических томов: создаются физические тома из разделов или дисков:
```console
pvcreate /dev/sda4
pvcreate /dev/sdb1
```
2. Создание группы томов: создается группа томов, используя физические тома:
```console
vgcreate ubuntu-vg /dev/sda4 /dev/sdb1
```
3. Создание логических томов: после создания группы томов (в примере - ubuntu-vg) создаются логические тома внутри этой группы:
```console
lvcreate -L 20G -n root ubuntu-vg
lvcreate -L 10G -n home ubuntu-vg
lvcreate -L 2G -n swap ubuntu-vg
```
В этом примере создаются логические тома:
+ root размером 20 ГБ
+ home размером 10 ГБ
+ swap размером 2 ГБ
4. Форматирование логических томов: после создания логических томов их форматируют в нужные файловые системы:
```console
mkfs.ext4 /dev/ubuntu-vg/root
mkfs.ext4 /dev/ubuntu-vg/home
mkswap /dev/ubuntu-vg/swap
```
5. Монтирование логических томов: создают точки монтирования и монтируют логические тома:
```console
mkdir /mnt/root
mkdir /mnt/home
mount /dev/ubuntu-vg/root /mnt/root
mount /dev/ubuntu-vg/home /mnt/home
```
6. Расширение группы томов и логических томов
Если позже добавляется новый физический том (например, /dev/sdc1), можно расширить группу томов:
```console
pvcreate /dev/sdc1
vgextend ubuntu-vg /dev/sdc1
```
После расширения группы томов, можно расширить существующие логические тома:
```console
lvextend -L +10G /dev/ubuntu-vg/root
```
И расширить файловую систему, чтобы она использовала новое пространство:
```console
resize2fs /dev/ubuntu-vg/root
```
*(Примечание: команда для расширения файловой системы зависит от типа используемой файловой системы. Например, для ext4 используется resize2fs, для xfs — xfs_growfs.)*

7. Итог
Логические тома создаются внутри группы томов (VG) и могут использовать пространство, предоставляемое всеми физическими томами (PV) в этой группе. Логические тома позволяют гибко управлять разделами и легко изменять их размеры, добавляя или удаляя физические тома в группе томов. *Внимание, в примере выше не показан процесс настройки автоматического монтирования логического тома*
### df
Если в вашей системе закончилось свободное дисковое пространство и получено сообщение «No space left on device», то нужно запустить команду ```df -h [fileName]```. Без ```fileName``` - для всей системы, а с ```fileName``` - для отображения информации о файловой системе, в которой находится указанный файл или директория:
```console
[st00@c7-sandbox ~]$ df -m | egrep -v tmpfs
Filesystem                1M-blocks  Used Available Use% Mounted on
/dev/mapper/rootvg-rootlv     22047  9515     11493  46% /
/dev/sda1                       488   246       207  55% /boot
/dev/mapper/rootvg-tmplv       4032    58      3770   2% /tmp
/dev/mapper/rootvg-homelv     25071  4409     19535  19% /home
```
опции:
+ ```-m``` - для использования мегабайтов (по умолчанию - kB)
+ ```-h``` (для удобного для человека формата вывода)

!!! Информацию про точку монтирования можно также получить с помощью команд lsblk и df

+ столбец ```Mounted on``` содержит информацию про точки монтирования (каталоги), к которым примонтированы файловые системы (см. столбец ```Filesystem```) в виде логических томов (```/dev/mapper/rootvg-rootlv```, ```/dev/mapper/rootvg-tmplv```, ```/dev/mapper/rootvg-homelv```) и разделов (```/dev/sda1```). В случае LVM, эти логические тома отображаются через пути в ```/dev/mapper```, что указывает на использование механизма ```device-mapper``` для управления томами. 
#### inode
Сообщение об ошибке «No space left on device» может быть показано, даже когда в файловой системе ещё много свободного места:
```console
[st00@c7-backend shared]$ touch /mnt/testfs/shared/new.empty.file
touch: cannot touch '/mnt/testfs/shared/new.empty.file': No space left on device

[st00@c7-backend shared]$ df -h /mnt/testfs/shared
Filesystem      Size  Used Avail Use% Mounted on
/dev/loop0       93M  2.5M   84M   3% /mnt/testfs
```
Здесь причина в **inode** (index node) - отдельный дескриптор для каждого файла и директории в файловой системе, в котором хранятся настройки прав доступа, указан владелец-пользователь и группа-владелец и другая служебная информация, называемая метаданными и метаинформацией. Для каждого дескриптора требуется немного дискового пространства, поэтому в файловой системе может быть только ограниченное количество дескрипторов, устанавливаемое в момент создания файловой системы. Когда индексные дескрипторы заканчиваются, в файловой системе уже больше нельзя создавать новые объекты, и поэтому выводится сообщение об ошибке «No space left on device».

```df -i [fileName]``` - отображает дескрипторы inode, вместо дискового пространства. Без ```fileName``` - для всей системы, а с ```fileName``` - для отображения информации о файловой системе, в которой находится указанный файл или директория:
```console
[st00@c7-backend shared]$ df -i /mnt/testfs
Filesystem     Inodes IUsed IFree IUse% Mounted on
/dev/loop0      25688 25688     0  100% /mnt/testfs
```
### du
+ ```du -s -m|-h``` - подсчитывает размер текущей директори
+ ``` du -s dir1 dir2 dirN``` - подсчитывает размер директорий dir1 dir2 dirN

**!!!** Этот инструмент может посчитать размер только тех каталогов, для которых у вас есть права на чтение и выполнение, остальные будут проигнорированы с выводом сообщения об ошибке «Permission denied»
## Архивы и сжатие
### gzip и bzip2
+ ```gzip``` устанавливается везде, ```bzip2``` является опциональным и может отсутствовать.
+ Они могут сжимать и распаковывать ТОЛЬКО отдельные файлы (НЕ каталоги).
+ Они могут читать ввод из ```stdin```, т.е. действовать по принципу ```что-то ... | gzip -9c > /some/where```.
+ Входные файлы удаляются по умолчанию, если не указана опция ```-c```.
+ ```bzip2``` сжимает лучше, чем ```gzip```, но работает дольше.
+ Оба инструмента однопоточны, т.е. могут использовать только одно ядро процессора, а не все сразу.

Наиболее полезные опции gzip и bzip2:
+ -1...-9: степень сжатия от 1 до 9, где 1 - минимальная, 9 - максимальная.
+ ```-d```: распаковать файл. Коэффициент сжатия здесь не требуется.
+ ``-с``: вывести результат на stdout. Входные файлы не удаляются при использовании ```-с```.

Примеры использования gzip и bzip2:
+ ```gzip -9 некий_файл``` -  Сжатие одного файла: ```некий_файл``` удаляется и создаётся файл ```некий_файл.gz```
+ ```gzip -9 *.txt``` - Сжатие всех файлов ```*.txt``` в текущей директории: все входные файлы удаляются, вместо них создаются новые файлы ```*.txt.gz```
+ ```bzip2 -9c некий_файл > некий_файл.bz2``` - Сжатие файла “некий_файл” и вывод результата в stdout. При работе с stdout входные файлы сохраняются
+ ```bzip2 -d некий_файл.bz2``` - Распаковка файла. ```некий_файл.bz2``` удаляется, вместо него создается ```некий_файл```
+ ```gzip -dc некий_файл.gz > некий_файл``` - Распаковка с сохранением исходного файла: входной файл ```некий_файл.gz``` сохраняется, так как указано ```-c```
+ ```cat *.log | bzip2 -5c > /tmp/compressed-logs.bz2``` - Сжатие данных, поступающих из stdout другой команды: при чтении входных данных из stdin через пайп необходимо указать опцию ```-c``` и перенаправить их вывод в какой-либо файл; в противном случае он будет выведен в терминал (что нежелательно в большинстве ситуаций).
### tar
```tar``` - основной инструмент создания архивов из нескольких файлов: 
+ имея на входе каталог, ``tar`` конкатенирует его содержимое в один файл.
+ ```tar``` может создавать сжатые архивы за один раз, подобно инструменту Windows zip.

Архив UNIX:
+ это "склеенная" пара входных файлов и каталогов, не обязательно сжатая
+ может быть сжат как во время, так и после его создания.
  
Для сжатия архивов могут использоваться внешние инструменты, такие как gzip и bzip2.

Наиболее полезные опции ```tar```
+ ```-с```: создать архив
+ ```-x```: извлечь все объекты
+ ```-t```: вывести список его содержимого
+ ```-f /path/to/file.tar```: имя входного или выходного файла. Опция ```-f``` в команде ```tar``` используется для указания имени файла архива. Она указывает ```tar```, где именно находится архив, который нужно создать, распаковать или просмотреть. Если опция ```-f``` используется с ключом ```-c``` (создание архива), то ```/path/to/file.tar``` указывает, куда сохранить созданный архив. Если опция ```-f``` используется с ключом ```-t``` (просмотр содержимого архива) или ```-x``` (извлечение архива), то ```/path/to/file.tar``` указывает путь к файлу архива, который нужно просмотреть или извлечь.
+ ```-z```: сжать архив с помощью ```gzip``` во время создания
+ ```-j```: сжать архив с помощью ```bzip2``` (если установлен) во время создания

Примеры использования ```tar```:
+ ```tar -c -f /путь/к/архиву.tar /некая/директория``` - Создать архив директории ```/некая/директория```
+ ```tar -t -f /путь/к/архиву.tar``` - Отобразить содержимое архива, то есть вывести имена файлов и директорий в стандартный поток вывода stdout
+ ```tar -xf /путь/к/архиву.tar.gz``` - Извлечь содержимое архива в текущую директорию
+ ```tar -xf /путь/к/архиву.tar -C /новое/место``` - Извлечь содержимое архива и поместить в другое место, НЕ в текущую директорию. Содержимое архива будет распаковано и помещено в /новое/место. Это место должно существовать перед выполнением “tar -xf” 
+ ```tar -czf /путь/к/архиву.tar.gz некая_директория``` - Архивировать каталог с помощью gzip
+ ```tar -cjf /путь/к/архиву.tar.bz2 некая_директория``` - Архивировать каталог некий_каталог с помощью bzip2
+ ```tar -cf - /path/to/dir | gzip -9c > my-archive.tar.gz``` - Архивирование директории с помощью gzip с использованием пайпов
+ ```gzip -dc my-archive.tar.gz | tar -xf``` - Распаховка существующего архива с использованием пайпов (или ```tar -xf my-archive.tar.gz -O | gzip -dc > my-archive.tar```)
+ ```tar cf - /path/to/dir | 7z a -si /path/to/file.tar.7z``` - упаковка tar + инструмент сжатия, не поддерживаемый tar внутренне (например, 7z)
## Передача файлов между компьютерами с помощью протокола SCP
Для передачи файлов с (или на) Linux-машин по сети следует использовать протокол SCP (Secure CoPy, или SSH CoPy). Соответствующий инструмент командной строки под названием "scp" поставляется с Linux, macOS и современными версиями Windows (для предыдущих версий Windows необходимо отдельно установить программу WinSCP, а также PuTTY для SSH-соединений), а также многими сетевыми устройствами, такими как Cisco

Полезные факты о SCP:
+ Он работает "поверх" SSH. Чтобы работать с удаленными машинами, необходимо иметь соответствующие учетные данные для входа в систему SSH. Логины и пароли такие же, как и для входа в SSH. (На удаленном хосте должен быть установлен и запущен SSH сервер)
+ SCP позволяет отправлять и получать как файлы, так и директории.

Примеры работы с scp:
+ ```scp некий_файл someone@host:/путь``` - Отправка файла на компьютер с именем ```host``` (можно указать как в виде IP-адреса, так и в виде доменного имени) от имени учётной записи ```someone```
+ ```scp некий_файл someone@host:/путь/другой_файл``` - Отправка файла на компьютер с именем ```host``` от имени ```someone```. Если файл ```/путь/другой_файл``` уже существует, он будет  перезаписан содержимым файла некий_файл. !!!При перезаписи файлов никаких предупреждений не выводится. Для SCP нельзя задать поведение, аналогичное "cp -i"
+ ```scp -P <port> <local_file_path> <remote_user>@<remote_host>:<remote_directory>``` - Если SSH-сервер на узле назначения использует нестандартный порт, вы можете указать его с помощью опции ```-P``` в команде ```scp```
+ ```scp -r someone@host:/path/to/target_dir ~/``` - копирование всей директории со всем содержимым. Это пример скачивания с использованием SCP. В результате вы получите директорию ```target_dir```, созданную в вашей домашней директории.

# 11 Как устроены сети
## Основные понятия сетей
### Модель клиент-сервер
![Модель клиент-сервер. HTTP как пример протокола](resources/http.drawio.png)

Программа, которая хочет получить данные, называемая "клиент", например, веб-браузер. Второй узел — это сервер, программа, обрабатывающая ваш запрос.
### Протоколы
Для общения с кем-либо мы должны разговаривать с собеседником на одном языке. В области сетей такие языки называются протоколами. Они устанавливают правила общения между компьютерами. Например, при подключении по Wi-Fi задействуется протокол 802.11. Также вы используете протоколы HTTP и HTTPS каждый раз, когда открываете веб-сайты.
### Утилиты для работы с сетевыми соединениями
#### UNIX/macOS - [nc](#nc) или netcat
nc, или netcat, это UNIX/macOS-утилита для работы с сетевыми соединениями. Она часто используется для отладки и тестирования сетей, так как поддерживает как TCP, так и UDP протоколы
```console
[user@host]$ nc example.com 80
GET / HTTP/1.1
Host: example.com
[ нажмите Enter ]
[ нажмите Enter ]
```
(нажать Ctrl+C после того, как сервер пришлёт что-нибудь в ответ)
#### Windows
1. Скачать на https://nmap.org/ в разделе "Microsoft Windows binaries" "Latest stable release self-installe
2. Запустите cmd или powershell и вызвать ncat (предварительно записав путь "c:\Program Files (x86)\Nmap" в PATH)
```console
[user@host]$ ncat example.com 80
GET / HTTP/1.1
Host: example.com
[ нажмите Enter ]
[ нажмите Enter ]
```
(нажать Ctrl+C после того, как сервер пришлёт что-нибудь в ответ)

или пользоваться telnet
```console
> telnet
Microsoft Telnet> set localecho //включает режим локального отображения команд
Microsoft Telnet> open example.com 80
GET / HTTP/1.1
Host: example.com
```
## Адреса и маршрутизация
### Cистема доменных имён DNS
![Схема обмена данными в рамках протокола DNS (Domain Name System)](resources/dns.drawio.png)

#### Разрешение имени ОС Linux, macOS:
1. ОС берет адрес DNS-сервера из своих сетевых настроек (из файла ```/etc/resolv.conf```)
```console
vboxuser@devDebian:~$ cat /etc/resolv.conf 
# Generated by NetworkManager
nameserver 192.168.50.1
```
2. ОС отправляет серверу DNS специальный запрос: «отправь мне IP-адрес, соответствующий имени example.com. Мы это можем выполнить:

```host example.com```, например:
```console
vboxuser@devDebian:~$ host example.com
example.com has address 93.184.215.14
example.com has IPv6 address 2606:2800:21f:cb07:6820:80da:af6b:8b2c
example.com mail is handled by 0
```
#### Разрешение имени ОС Windows:
1. ОС берет адрес DNS-сервера из своих сетевых настроек. Мы это можем выполнить с помощью ```ipconfig /all```
2. ОС отправляет серверу DNS специальный запрос: «отправь мне IP-адрес, соответствующий имени example.com. Мы это можем выполнить с помощью ```nslookup имя.сервера```
### IP-адреса и порты
![Взаимодействие клиент-сервер с помощью разных протоколов прикладного уровня (DNS и HTTPS) и портов (53 и 443 соответственно)](resources/ip-ports.drawio.png)

IP-адреса служат для идентификации узлов, подключённых к сетям

Взаимодействие клиент-сервер с помощью разных протоколов прикладного уровня (DNS и HTTPS) и портов (53 и 443 соответственно):
+ DNS: port 53
+ HTTPS: port 443
#### IP, MAC-адрес(а) вашего компьютера и маска локальной сети вашего компьютера:
+ ОС Linux:
  + ```ip addr list``` == ```ip addr show``` == ```ip a```
  + ```ifconfig``` (иногда)
+ macOS: ```ifconfig```
+ ОС Windows: ```ipconfig /all```
### Маршрутизация
![Механизм маршрутизации](resources/routing.png)

Связь узла с сервером example.com достигается с помощью механизма маршрутизации

![Маршрутизация не нужна для доступа к компьютерам в вашей локальней сети](resources/no-routing.drawio.png)

Для связи с компьютерами локальней сети маршрутизация не нужна

Получить "таблицу маршрутизации" (routing table):
+ Linux: ```ip route list``` == ```ip r```
+ macOS: ```netstat -rnf inet```
+ Windows: ```route -4 PRINT```

*Пример:*
```console
[user@host]$ ip route list
default via 10.8.0.1 dev eth0 proto dhcp src 10.8.0.2 metric 1024
10.8.0.0/24 dev eth0 proto kernel scope link src 10.8.0.2
192.168.0.0/24 dev eth1 proto kernel scope link src 192.168.0.2
```
Здесь:
+ компьютер подключён к двум локальным сетям, 10.8.0.0/24 и 192.168.0.0/24, и обладает внутри каждой из этих сетей IP-адресами 10.8.0.2 и 192.168.0.2 соответственно.
+ При попытке подключиться к узлу сети 10.8.0.0/24 компьютер будет использовать для этого устройство с именем eth0. 
+ При попытке подключиться к узлу сети 192.168.0.0/24 компьютер использует устройство с именем eth1
+ При попытке подключиться к узлу сети с именем example.com (93.184.216.34 - это IP-адрес ресурса с именем example.com) или любым другим узлом из внешних сетей операционная система будет применять маршрут по умолчанию с адресом 10.8.0.1

Для построения  маршрута от вашего узла до сервера example.com:
+ Linux, macOS: ```traceroute example.com```
+ Windows: ```tracert example.com```
## Физический уровень
![Как всё это выглядит с точки зрения аппаратного обеспечения](resources/hardware.drawio.png)

Представление с точки зрения аппаратного обеспечения

### Протокол ARP (Address Resolution Protocol — протокол определения адресов).
Протокол ARP применяется  для преобразования адресов только внутри локальной сети, его сообщения не могут передаваться через шлюзы в другие сети
1. Когда данные готовы к передаче, клиентская ОС запрашивает сетевой адаптер отправить специальное широковещательное сообщение: «узел с IP 10.8.0.1, ответь, мне нужен твой MAC-адрес, чтобы пообщаться с тобой»(на данном этапе сетевой адаптер знает только свой MAC-адрес, и что узел example.com находится за пределами вашей сети и поэтому вам нужен шлюз (в данном случае это 10.8.0.1) и, в свою очередь, ничего не знает об IP-адресах, масках подсети, используемом по умолчанию шлюзе).
2. В случае успеха ОС получит следующую информацию: «узел с IP-адресом 10.8.0.1 обладает MAC-адресом 46:09:9f:f5:87:aa», и запишет её в специальную таблицу, где отображаются устройства, с которым ваш узел "общался" в пределах локальной сети.
3. На следующем шаге (**ARP закончил работу**) клиентская ОС запрашивает сетевой адаптер передать сообщение вида "Узел с MAC-адресом  46:09:9f:f5:87:aa, для тебя есть сообщение: [текст сообщения]". Операционная система роутера (внутри этой маленькой коробочки также есть ОС) поместит ваше сообщение в пакет программного уровня, прочтёт IP-адрес узла назначения, выберет нужный интерфейс для дальнейшей пересылки и отправит сообщение через физический уровень этого интерфейса

Получить содержимое ARP-таблицы компьютера:
+ Linux, macOS: arp -a -n
+ Windows: arp /a

### Сетевые адаптеры и IP-адреса
Узлы и сетевые интерфейсы связаны как "один ко многим":
+ Компактный ноутбук может иметь всего 1 встроенный физический сетевой интерфейс, это WiFi-адаптер
+ Ноутбук большего размера как правило имеет 2 и более физических сетевых интерфейса, например один WiFi-адаптер и одну сетевую Ethernet-карту
+ смартфоны имеют как минимум 2 сетевых интерфейса (оба - беспроводные): один для передачи данных по мобильным сетям (4G или 5G), второй - WiFi-адаптер
+ Маршрутизаторы имеют 2 или более сетевых интерфейса для соединения с разными сетями и передачи данных между ними
+ При установке VPN-соединения в системе появляется еще минимум 1 виртуальный сетевой интерфейс для обмена данными внутри VPN-соединения
+ Даже если у компьютера нет ни одного физического сетевого интерфейса, все равно в системе присутствует минимум 1 виртуальный интерфейс, часто называемый loopback-интерфейсом или "интерфейсом обратной петли", необходимый для взаимодействия клиентского и серверного ПО, запущенного на одном и том же узле. 
+ Не бывает случаев, когда один и тот же сетевой интерфейс принадлежит нескольким разным узлам. Даже если на узле запущено несколько виртуальных машин, которые имеют доступ к одному и тому же физическому сетевому интерфейсу, каждая из виртуальных машин имеет свой собственный виртуальный сетевой интерфейс.

Связь между сетевыми интерфейсами и IP-адресами имеет тип "один ко многим":
+ Самый частый случай: 1 сетевой интерфейс имеет 1 IP-адрес, когда вы подключаете узел к локальной сети.
+ Один сетевой интерфейс не имеет ни одного настроенного IP-адреса. Пример: вы включаете ноутбук там, где нет никаких точек доступа WiFi.
+ Один сетевой интерфейс имеет несколько IP-адресов. Такие настройки могут встретиться на сетевых устройствах или серверах в специфических ситуациях.
+ Один и тот же IP-адрес НЕ может быть назначен нескольким сетевым интерфейсам в рамках одной сети.

# 12 Сетевые уровни и протокол IP
## Введение в стек TCP/IP
### Уровни
![Стек TCP/IP](resources/tcp_ip_12_1.png)

Что представляет собой стек TCP/IP

### Application Layer (Прикладной уровень). 
Большая часть протоколов, работающих в рамках модели клиент-сервер, относится к прикладному уровню (DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS. curl supports TLS certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies (SOCKS4, SOCKS5, HTTP and HTTPS), HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate, Kerberos, Bearer tokens and AWS Sigv4), file transfer resume, proxy tunneling, HSTS, Alt-Svc, unix domain sockets, HTTP compression (gzip, brotli and zstd), etags, parallel transfers, DNS-over-HTTPS). На этом уровне задаётся вопрос “ЧТО должно быть отправлено и получено”.
### Transport Layer (Транспортный уровень). 
Самые распространённые протоколы транспортного уровня это TCP, UDP. Протоколы транспортного уровня описывают КАК ИМЕННО запросы и ответы должны отправляться и приниматься: какой порт использовать, нужно ли проверять целостность данных и очерёдность пакетов, нужно ли повторно отправлять потерянные пакеты и т. д.
### Network Layer (Сетевой уровень).
Предназначен для адресации и поиска узла назначения, а также для маршрутизации. В модели TCP/IP сетевой уровень представлен протоколом IP (Internet Protocol — межсетевой протокол).
### Datalink Layer / Interface Layer (Уровень сетевого интерфейса, он же "канальный уровень", либо "уровень сетевого доступа").
Уровень служит интерфейсом между программным обеспечением (ПО) и физическими устройствами, например адаптерами для Ethernet, Wi-Fi, Bluetooth или модемами DSL.  Этот уровень также применяется для соединения устройств, находящихся в одной локальной сети, где используются аппаратные адреса без обращения к IP-адресам.
### Физический уровень (Physical Layer).
Он располагается после уровня сетевого интерфейса и используется для передачи данных по физической среде, например медному проводу, оптическому волокну или воздуху. На этом уровне нет программных протоколов, только физические сигналы.

*В идеальном случае ПО каждого уровня можно легко заменить, не затрагивая другие уровни*
### Инкапсуляция
Уровни модели TCP/IP связаны друг с другом посредством инкапсуляции, то есть помещения простых объектов в более сложные.
### cURL<a id="curl"></a>
```curl [options...] [url]```

cURL означает Client for URL (программный клиент для URL). Это многофункциональный инструмент для взаимодействия с веб-серверами и API:
+ поддерживает все методы HTTP-запросов
+ поддерживаемые протоколы: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS. curl supports TLS certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies (SOCKS4, SOCKS5, HTTP and HTTPS), HTTP/2, HTTP/3, cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, SCRAM-SHA, NTLM, Negotiate, Kerberos, Bearer tokens and AWS Sigv4), file transfer resume, proxy tunneling, HSTS, Alt-Svc, unix domain sockets, HTTP compression (gzip, brotli and zstd), etags, parallel transfers, DNS-over-HTTPS)
+ есть возможность скачивать и загружать файлы
+ поддерживает применение cookie
+ поддерживает аутентификацию
+ поддерживает конвейерную обработку HTTP (pipelining)
+ поддерживает прокси-серверы с проверкой подлинности (протоколы HTTP и Socks)
+ позволяет управлять заголовками
+ имеет библиотеки, такие как ```libcurl```, которые можно использовать в различных языках программирования для интеграции сетевых запросов в приложения

Опции команды:
+ ```-X``` / ```--request``` - указывает применяемый метод HTTP: curl -v -X POST https://example.org/index.html
+ ```-d``` / ```--data``` - задаёт содержимое тела запроса.
+ ```-H``` - определяет заголовки запроса.
+ ```-u``` - позволяет передать имя пользователя и пароль, если серверу требуется проверка подлинности.
+ ```-k``` - предписывает программе cURL игнорировать проблемы, связанные с сертификатом безопасности (применение этой опции небезопасно!).
+ ```-v``` - переключение в режим подробного вывода (чтобы получить больше сведений).
+ ```-F``` - отправка данных в формате (```Content-Type```) ```multipart/form-data```, который часто используется для загрузки файлов, но с формы. Указывают в формате ```-F "field_name1=значение" -F "field_name2=значение"```. Если нужно отправить файл, то добавляют к значению, которое является путем к файлу, префикс @:  ```-F "field_name1=@/path/to/file"```
+ ```--data-binary @/path/to/file``` - опция указывает curl отправить содержимое файла как бинарные данные. Символ ```@``` перед путём к файлу указывает curl загрузить файл с указанного пути
+ ```-x``` - выполнение запроса через HTTP-прокси
+ ```-L``` - автоматическое следование редиректам
+ ```-c``` - сохранение cookies в файл
+ ```-b``` - использование сохраненных cookies в запросе
+ ```--cert``` - указание файла сертификата клиента

**Примеры**
1. GET-запросы:
   1. ```curl http://example.com``` - вывод в терминал
   2. ```curl http://example.com -o example.html``` - вывод в файл
2. Отправка заголовков
   1. ```curl -H "User-Agent: Mozilla/5.0" http://example.com``` - отправка заголовка
   2. ```curl -H "User-Agent: Mozilla/5.0" -H "Accept: application/json" http://example.com``` - отправка нескольких заголовков
3. POST-запросы
   1. ```curl -X POST -d "username=user&password=pass" http://example.com/login``` - отправка данных формы в формате (```Content-Type```) ```application/x-www-form-urlencoded```, который является обычным способом отправки данных формы через HTTP POST запросы
   2. ```curl -X POST -H "Content-Type: application/json" -d '{"name": "Petty", "status": "available"}' 'https://petstore.swagger.io/v2/pet'``` - отправка POST-запроса с JSON-данными в формате ```application/json```
4. Аутентификация
   1. ```curl -u username:password http://example.com``` - базовая аутентификация
   2. ```curl -H "Authorization: Bearer YOUR_TOKEN" http://example.com``` - запрос с токеном аутентификации
5. Скачивание файлов
   1. ```curl -O http://example.com/file.zip``` - скачивание файла с указанного URL (без -O - выведет в терминал без сохранения файла)
   2. ```curl -o myfile.zip http://example.com/file.zip``` - скачивание файла и сохранения его с указанным именем
6. UPLOAD файлов на сервер 
   1. ```curl -X POST -F "file=@/path/to/file" http://example.com/upload``` - с использованием метода POST
   2. ```curl -X POST -F "file=@/path/to/file" -F "username=johndoe" http://example.com/upload``` - вместе с файлом будет отправлен параметр формы username с значением johndoe
   3. ```curl -X POST --data-binary @/home/user/documents/report.pdf http://example.com/upload```
7. Отправка данных с PATCH-запросом
   1. ```curl -X PATCH -H "Content-Type: application/json" -d '{"age":30}' http://example.com/users/123``` - отправка PATCH-запроса с JSON-данными
8. Просмотр заголовков ответа
   1. ```curl -I http://example.com``` - просмотр только заголовков ответа
   2. ```curl -v http://example.com``` - режим полезен для отладки, так как он показывает процесс подключения и отправки запроса, а также подробные заголовки ответа
9. Выполнение запросов через прокси
   1.  ```curl -x http://proxy.example.com:8080 http://example.com``` - выполнение запроса через HTTP-прокси
   2.  ```curl --socks5-hostname 127.0.0.1:1080 http://example.com``` - выполнение запроса через SOCKS-прокси
   3.  ```curl -x http://username:password@proxy.example.com:8080 http://example.com``` или ```curl -x http://proxy.example.com:8080 --proxy-user username:password http://example.com``` - аутентификация на прокси-сервере
10. Обработка редиректов
    1.  ```curl -L http://example.com``` - автоматическое следование редиректам. Используя опции ```-L```, ```--max-redirs``` и другие параметры, можно настроить curl для автоматического следования за редиректами, ограничить их количество и отладить процесс редиректов
11. Сохранение cookies и использование их в последующих запросах
    1.  ```curl -c cookies.txt http://example.com``` - сохранение cookies в файл
    2.  ```curl -b cookies.txt http://example.com``` - использование сохраненных cookies в запросе
12. Ограничение скорости
    1.  ```curl --limit-rate 100K http://example.com/file.zip``` - ограничение скорости загрузки
13. Таймауты
    1.  ```curl --connect-timeout 10 http://example.com``` - установка максимального времени ожидания для соединения
    2.  ```curl --max-time 20 http://example.com``` -установка максимального времени выполнения запроса
14. Опции SSL/TLS
    1.  ```curl -k https://example.com``` - игнорирование проверки SSL-сертификата (не рекомендуется)
    2.  ```curl --cert /path/to/cert.pem https://example.com``` - указание файла сертификата клиента
### Прохождение данных через стек TCP/IP
#### 1. Application Layer. 
На этом  уровне приложения генерируют данные, которые необходимо передать по сети. Эти данные передаются на транспортный уровень.
#### 2. Transport Layer. 
После Application Layer (например, после выполнения команды curl 192.168.100.5) операционная система передаст на Transport Layer, на котором ОС поместит ваши данные в пакет TCP (или UDP).

<img src="resources/tcp.png" alt="Структура TCP-пакета" width="65%"/>

Пакет TCP содержит множество полей, в т.ч. порт назначения (Destination Port у нас - 80), порт источник (Source Port), контрольная сумма (Checksum), данные (Payload - ваш запрос HTTP).
#### 3. Network Layer. 
Transport Layer не занимается адресацией. Эта обязанность лежит на нижележащем уровне, использующем протокол IP.

![Структура IP-пакета](resources/ip.jpg)

На этом уровне ОС поместит в поле:
+ Protocol (протокол) специальное число, говорящее получателю, что в поле Data лежит пакет TCP
+ Source address (адрес источника, отправителя) IP-адрес вашего компьютера
+ Destination address (адрес назначения, получателя) помещает IP-адрес удалённого узла
+ Data весь пакет TCP
+ TTL (Time to live — время существования) максимальное количество шлюзов, через которое может пройти пакет. Значение по умолчанию: 64 для Linux и macOS, 128 для современных версий Windows
#### 4. Datalink Layer / Interface Layer. 
На этом уровне:
+ все предыдущие данные приложения и пакеты протоколов IP и TCP/UDP будут упакованы в поле Data кадра Ethernet (если используется именно Ethernet).
+ Поле DA будет заполнено MAC-адресом узла назначения (или MAC-адресом шлюза, если таковой применяется), полученным с помощью протокола ARP. 
+ Аппаратный адрес вашего сетевого адаптера будет расположен в поле Source address (SA).
+ В поле CRC будет помещена контрольная сумма, необходимая для проверки того, что у отправителя и у получателя одинаковые копии данных

![Структура кадра Ethernet](resources/ethernet.png)
## Основы IP-сетей
### IP адресация
1. IP-адрес - xxx.yyy.zzz.qqq
2. Маска подсети - число между 0 и 32 или формат IP-адреса. Маска подсети должна состоять из непрерывного блока единиц, за которым следуют непрерывные нули. Например, маски подсети "24" и "255.255.255.0" эквивалентны. Маска подсети "/24" означает, что 24 бита из 32 используются для обозначения сети, а остальные 8 бит для обозначения узлов.
3. С помощью побитовой операции между IP-адресом и маской компьютер вычисляет диапазон адресов подсети. Например, узел с IP-адресом 192.168.0.1 и маской подсети 24 является частью подсети 192.168.0.0/24, включающей 256 адресов от 192.168.0.0 до 192.168.0.255. Расчёты проводятся с помощью простой двоичной арифметики: 2 ^ (32 - 24) = 2 ^ 8 = 256.

```ipcalc xxx.yyy.zzz.qqq[/ss]``` - утилита командной строки, которая предоставляет информацию о сетевых параметрах для заданного IP-адреса и маски подсети, например:
```console
vboxuser@devDebian:~$ ipcalc 192.168.33.62
Address:   192.168.33.62        11000000.10101000.00100001. 00111110
Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
=>
Network:   192.168.33.0/24      11000000.10101000.00100001. 00000000
HostMin:   192.168.33.1         11000000.10101000.00100001. 00000001
HostMax:   192.168.33.254       11000000.10101000.00100001. 11111110
Broadcast: 192.168.33.255       11000000.10101000.00100001. 11111111
Hosts/Net: 254                   Class C, Private Internet
```
### Маршрутизация
+ Идея IP-сетей - разделить адресное пространство на подсети, поместить узлы внутрь подсетей, а затем, при необходимости, обеспечить установку соединения между подсетями. 
+ Маршрутизация - механизм взаимодействия между сетями.

Для отображения таблицы маршрутизации на вашем компьютере (Linux) используется команда ```ip route list```:
```console
[user@linux]$ ip route list
default via 192.168.0.1 dev eth0 proto dhcp src 192.168.0.134 metric 1024
10.8.0.0/24 dev tap0 proto kernel scope link src 10.8.0.1
192.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.134
```

Каждая строка таблицы маршрутизации содержит три основных объекта:
1. Первая строка (с default):
+ ```default```: Этот маршрут является маршрутом по умолчанию. Все пакеты, которые не соответствуют другим маршрутам изтаблицы маршрутизации, будут отправляться по этому маршруту.
+ ```via 192.168.0.1```: Этот маршрут направляет пакеты через шлюз с IP-адресом 192.168.0.1.
+ ```dev eth0```: Этот маршрут использует интерфейс eth0 для отправки пакетов.
+ ```proto dhcp```: Маршрут получен через DHCP
+ ```src 192.168.0.134```: IP-адрес источника для отправляемых пакетов, когда они отправляются через этот маршрут.
+ ```metric 1024```: Метрика этого маршрута. Метрика используется для определения приоритета маршрута; меньшее значение метрики указывает на более предпочтительный маршрут.
2. Вторая строка (остальные варианты, без default). Третья строка - аналогична:
+ ```10.8.0.0/24```: Этот маршрут указывает на сеть с адресом 10.8.0.0 и маской подсети /24
+ ```dev tap0```: Этот маршрут использует интерфейс tap0 для отправки пакетов.
+ ```proto kernel```: Маршрут был добавлен ядром.
+ ```scope link```: Маршрут ограничен текущим интерфейсом.
+ ```src 10.8.0.1```: IP-адрес источника для отправляемых пакетов, когда они отправляются через этот маршрут.
#### Системные инструменты для прослеживания маршрута от вашего компьютера к удалённому узлу
+ ```ip route get xxx.yyy.zzz.qqq``` - вернет соответствующее правило для узла назначения (xxx.yyy.zzz.qqq) из таблицы маршрутизации  
+ ```traceroute xxx.yyy.zzz.qqq``` (ОС Linux, macOS) или ```tracert``` (ОС Windows) - сетевая утилита, возращающая список транзитных узлов между вами и удалённым узлом (xxx.yyy.zzz.qqq)  и определить, таким образом, самый отдалённый из работающих маршрутизаторов в случае проблем с маршрутизацией.. Эта команда отправляет узлу назначения специальные пакеты IP со значением поля TTL, начинающимся с 1 (увеличивая значение с каждым шагом на 1 до момента получения ответа от узла назначения). Благодаря такому значению промежуточные шлюзы отправляют обратно другой специальный пакет (об исчерпании поля TTL), таким образом обнаруживая себя (если это не отключено в настройках шлюза).
### Откуда берутся IP-адреса
Пространство IP-адресов:
+ частные
+ глобальные
#### Частные области
Частные области - зарезервированы в документации межсетевого протокола (Internet Protocol — IP) как подсети для создания локальных сетей. Эти сети не участвуют в глобальной маршрутизации

Список зарезервированных для этого подсетей: 10.0.0.0/8, 172.16.0.0/12, 192.0.0.0/24 и 192.168.0.0/16

Два подхода назначения IP-адресов в локальных сетях:
+ использование протокола DHCP (Dynamic Host Configuration Protocol — протокол динамического конфигурирования узлов) для автоматического назначения IP-адресов, адресов подсетей, маршрутов и адресов серверов DNS (применяется большинством современных маршрутизаторов);
+ использование статической конфигурации, полученную от вашего интернет-провайдера или системного администратора, задавая адреса вручную и используя одну из частных подсетей.
#### Глобальные (публичными) области
Публичный адрес выдает интернет-провайдер, а те - у специальных компаний, называемых брокерами IP-адресов, или у региональных интернет-регистраторов
### NAT: преобразование сетевых адресов
![NAT: что происходит, если у вашего компьютера нет глобального IP-адреса](resources/net02-06-NAT.png)

Принцип работы NAT, если у компьютера нет глобального IP-адреса

#### Пояснение на примере работы NAT
Дано:
+ у нас есть адрес 10.0.0.2 в локальной сети 10.0.0.0/24.
+ у нашего маршрутизатора есть два интерфейса с адресами 10.0.0.1 и 1.2.3.4. 
+ Мы хотим отправить запрос публичному серверу DNS с адресом 8.8.8.8.
Тогда:
+ наш компьютер на сетевом уровне упаковывает запрос в пакет IP с адресом назначения 8.8.8.8, ищет в таблице маршрутизации маршрут для адреса 8.8.8.8 и даёт понять, что пакет должен отправляться на маршрутизатор посредством его MAC-адреса. 
+ маршрутизатор получает пакет. Анализируя пакет IP, понимает, что он не конечный получатель. В этот момент в игру и вступает **механизм NAT (Network Address Translation — преобразование сетевых адресов)**.
  1. Маршрутизатор ищет в своей таблице маршрутизации маршрут к узлу назначения. В нашем случае он выберет интерфейс с публичным адресом 1.2.3.4
  2. Маршрутизатор сохраняет у себя информацию, что он теперь является промежуточным узлом между 10.0.0.2 и 8.8.8.8
  3. Маршрутизатор изменяет адрес источника в вашем пакете IP: с 10.0.0.2 на публичный адрес 1.2.3.4
  4. Маршрутизатор уменьшает значение поля TTL в вашем пакете IP на единицу. Это поле не позволяет пакету бесконечно блуждать по сети в случае образования маршрутной петли (контура). Каждый последующий маршрутизатор выполнит те же действия. Пакет с обнулившимся полем TTL будет отброшен
  5. Удалённый сервер DNS с адресом 8.8.8.8 обработает запрос и отправит ответ в новом пакете IP маршрутизатору с адресом 1.2.3.4, так как он думает, что узел с адресом 1.2.3.4 и есть автор запроса
  6. Маршрутизатор получает пакет с ответом от узла с адресом 8.8.8.8, проверяет свой список соединений и определяет, что этот пакет предназначен узлу с адресом 10.0.0.2
  7. Маршрутизатор изменяет в пакете адрес назначения с 1.2.3.4 на 10.0.0.2 и отправляет пакет клиенту.
### Localhost
Localhost - важная частная подсеть — ```127.0.0.0/8```

Используется:
+ когда вашему компьютеру нужно установить соединение с какой-либо сетевой службой, работающей локально (например, тестирование серверного ПО)
+ В современных дистрибутивах Linux, где DNS-сервер устанавливается локально (простое ПО для кэширования запросов и ускорения работы). Поэтому ваша операционная система устанавливает соединение с адресом 127.0.0.1 и портом 53 каждый раз, когда нужно преобразовать какое-либо имя в IP-адрес

**Как это работает:**
1. Есть виртуальный сетевой интерфейс, реализующий механизм «обратной петли», обычно с именем ```lo``` (на ОС Linux) с назначенным адресом ```127.0.0.1``` и маской подсети ```255.0.0.0```. *Хитрость интерфейса с обратной петлей в том, что он всегда ответит, на какой бы адрес этой подсети вы не отправили сообщение*. Поэтому если вы попытаетесь подключиться к любому адресу из подсети 127.0.0.0/8, то результат всегда будет одинаков.
2. Есть специальное имя ```localhost``` (локальный узел), служащее псевдонимом для узла с адресом ```127.0.0.1```. Его можно использовать вместо IP-адреса, если вам так удобнее.
3. Когда вы пытаетесь подключиться к ```127.0.0.1```, операционная система видит, что этот адрес относится к маршруту, связывающему подсеть ```127.0.0.0/8``` с интерфейсом ```lo```. Затем ваши данные будут отправлены виртуальному интерфейсу с обратной петлёй, а операционная система получит входящее сообщение, обработает его и самостоятельно ответит.
## DNS: Система доменных имён (Domain Name System)
Система доменных имён (Domain Name System) предназначена для преобразования доменных имён в IP-адреса
### Общий порядок преобразования имени в IP-адрес
1. ОС начинает поиск соответствия IP-адреса указанному доменному имени узла с файла ```/etc/hosts```, где локально хранятся пары «имя узла — IP-адрес»
2. В случае неудачи ОС возьмёт адрес DNS сервера из файла ```/etc/resolv.conf``` и инициирует отправку запроса ему:
   1. в ```/etc/resolv.conf``` часто указано, что основной DNS-сервер расположен локально на 127.0.0.1
### Преобразование имени в IP-адрес посредством утилит командной строки
#### host
1. Преобразование доменного имени в IP-адрес 
```console
vboxuser@devDebian:~$ host example.com
example.com has address 93.184.215.14
example.com has IPv6 address 2606:2800:21f:cb07:6820:80da:af6b:8b2c
example.com mail is handled by 0
```
2. Преобразование IP-адреса в доменное имя
```console
vboxuser@devDebian:~$ host 8.8.8.8
8.8.8.8.in-addr.arpa domain name pointer dns.google.
```
3. Получение информации о почтовых серверах (MX-записи) для домена
```console
vboxuser@devDebian:~$ host -t mx example.com
example.com mail is handled by 0 .
```
4. Получение информации о сервере имен (NS-записи) для домена
```console
vboxuser@devDebian:~$ host -t ns example.com
example.com name server a.iana-servers.net.
example.com name server b.iana-servers.net.
```
5. Запрос определенного типа записи, например, текстовой записи (TXT)
```console
vboxuser@devDebian:~$ host -t txt example.com
example.com descriptive text "v=spf1 -all"
example.com descriptive text "wgyf8z8cgvm2qmxpnbnldrcltvk4xqfn"
```
6. Использование определенного DNS-сервера для запроса
```console
vboxuser@devDebian:~$ host example.com 8.8.8.8
Using domain server:
Name: 8.8.8.8
Address: 8.8.8.8#53
Aliases: 

example.com has address 93.184.215.14
example.com has IPv6 address 2606:2800:21f:cb07:6820:80da:af6b:8b2c
example.com mail is handled by 0 .
```
#### dig
dig - мощный инструмент для преобразования имён В UNIX-подобных системах. Выводит большой объём информации
1. Запрос A-записи (IP-адрес) для домена
```console
$ dig example.com

; <<>> DiG 9.16.1-Ubuntu <<>> example.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 12345
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      A

;; ANSWER SECTION:
example.com.            3600    IN      A       93.184.216.34

;; Query time: 29 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:24:56 UTC 2021
;; MSG SIZE  rcvd: 65
```
2. Запрос MX-записей (почтовых серверов) для домена
```console
$ dig example.com MX

; <<>> DiG 9.16.1-Ubuntu <<>> example.com MX
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 67890
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 2

;; QUESTION SECTION:
;example.com.                   IN      MX

;; ANSWER SECTION:
example.com.            3600    IN      MX      10 mail1.example.com.
example.com.            3600    IN      MX      20 mail2.example.com.

;; Query time: 30 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:26:34 UTC 2021
;; MSG SIZE  rcvd: 95
```
3. Запрос NS-записей (серверов имен) для домена
```console
$ dig example.com NS

; <<>> DiG 9.16.1-Ubuntu <<>> example.com NS
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 13579
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3

;; QUESTION SECTION:
;example.com.                   IN      NS

;; ANSWER SECTION:
example.com.            3600    IN      NS      ns1.example.com.
example.com.            3600    IN      NS      ns2.example.com.

;; ADDITIONAL SECTION:
ns1.example.com.        3600    IN      A       192.0.2.1
ns2.example.com.        3600    IN      A       192.0.2.2

;; Query time: 31 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:27:45 UTC 2021
;; MSG SIZE  rcvd: 116
```
4. Запрос TXT-записей для домена
```console
$ dig example.com TXT

; <<>> DiG 9.16.1-Ubuntu <<>> example.com TXT
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 24680
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      TXT

;; ANSWER SECTION:
example.com.            3600    IN      TXT     "v=spf1 include:_spf.example.com ~all"

;; Query time: 32 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:28:56 UTC 2021
;; MSG SIZE  rcvd: 90
```
5. Запрос с указанием конкретного DNS-сервера
```console
$ dig @8.8.8.8 example.com

; <<>> DiG 9.16.1-Ubuntu <<>> @8.8.8.8 example.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11223
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;example.com.                   IN      A

;; ANSWER SECTION:
example.com.            3600    IN      A       93.184.216.34

;; Query time: 28 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:30:12 UTC 2021
;; MSG SIZE  rcvd: 65
```
6. Запрос PTR-записей для обратного DNS-запроса (преобразование IP-адреса в доменное имя)
```console
$ dig -x 8.8.8.8

; <<>> DiG 9.16.1-Ubuntu <<>> -x 8.8.8.8
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 98765
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;8.8.8.8.in-addr.arpa.          IN      PTR

;; ANSWER SECTION:
8.8.8.8.in-addr.arpa.   86400   IN      PTR     dns.google.

;; Query time: 27 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Mon Jun 07 10:31:23 UTC 2021
;; MSG SIZE  rcvd: 85
```
#### nslookup 
Используется для выполнения DNS-запросов и получения информации о DNS-записях. Она проще в использовании, чем dig, но менее гибкая
1. Запрос A-записи (IP-адрес) для домена
```console
$ nslookup example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   example.com
Address: 93.184.216.34
```
2. Запрос MX-записей (почтовых серверов) для домена
```console
$ nslookup -query=mx example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     mail exchanger = 10 mail1.example.com.
example.com     mail exchanger = 20 mail2.example.com.
```
3. Запрос NS-записей (серверов имен) для домена
```console
$ nslookup -query=ns example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     nameserver = ns1.example.com.
example.com     nameserver = ns2.example.com.
```
4. Запрос TXT-записей для домена
```console
$ nslookup -query=txt example.com

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
example.com     text = "v=spf1 include:_spf.example.com ~all"
```
5. Использование конкретного DNS-сервера для запроса
```console
$ nslookup example.com 8.8.8.8

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   example.com
Address: 93.184.216.34
```
6. Обратный DNS-запрос (преобразование IP-адреса в доменное имя)
```console
$ nslookup 8.8.8.8

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
8.8.8.8.in-addr.arpa   name = dns.google.
```
### FQDN (Fully Qualified Domain Name — полностью определённое имя домена)
+ На самом деле нужно преобразовывать имя с точкой на конце — www.example.com., чтобы быть уверенными, что это полное имя, известное также как FQDN
+ каждое доменное имя может быть разделено точками на зоны (www, example и com)
+ Если зона существует, то должен быть по крайней мере один сервер DNS, располагающий полной информацией об этой зоне. Такие серверы называются **полномочными (authoritative) серверами DNS**
![Иерархическая структура системы доменных имён DNS](resources/net02-07-dns-tree.jpg)

Иерархическая структура системы доменных имён DNS

+ Группа корневых серверов (зелёного цвета на схеме), хранит информацию о зонах первого уровня (жёлтого цвета) и об их полномочных серверах. 
+ серверы зон первого уровня располагают информацией о зонах второго уровня (красный цвет)
+ серверы зон второго уровня и следующих работают в рекурсивном режиме (т.е. отвечают на все запросы про нижестоящие доменные имена), поэтому можно запрашивать у серверов второго уровня информацию о доменах нижних уровней
### Виды DNS-серверов<a name="dns-server"></a>
#### Авторитативный сервер
1. Функция: Хранит и предоставляет точные данные о доменах.
2. Кэширование: Хранит официальные записи и не зависит от кэширования для предоставления данных
3. Ответы: Предоставляет окончательный и достоверный ответ для доменов, за которые он ответственен
#### Рекурсивный сервер
1. Функция: Обрабатывает запросы клиентов и ищет необходимую информацию, обращаясь к другим серверам.
2. Кэширование: Может кэшировать ответы на запросы для ускорения последующих запросов, но не хранит официальные записи
3. Ответы: Может предоставлять ответы, которые он закэшировал, или будет делать запросы к другим серверам для получения ответа
#### Пример взаимодействия:
1. Клиент делает запрос на преобразование доменного имени в IP-адрес.
2. Запрос идет к рекурсивному серверу (резолверу).
3. Если рекурсивный сервер не имеет закэшированного ответа, он делает последовательные запросы к другим серверам, начиная с корневых серверов, затем к серверам верхнего уровня (TLD) и, наконец, к авторитативному серверу, который хранит запрашиваемую информацию.
4. Авторитативный сервер возвращает точную информацию.
5. Рекурсивный сервер передает эту информацию клиенту и может закэшировать её для ускорения будущих запросов.

*Примечание:*
+ В большинстве случаев полномочные (Авторитативные) серверы не настроены на работу в качестве преобразователей для «чужих» зон. То есть сервер DNS, ответственный за доменную зону google.com, не ответит на запрос, касающийся зоны wikipedia.org.
### Записи системы DNS (самые распространённые )
#### Запись "A"
+ используется для преобразования имени домена в IP-адрес
+ у домена может быть несколько записей "A", содержащих несколько IP-адресов, назначенных этому домену. В таком случае ОС выберет адрес из списка случайным образом. Этот механизм называют каруселью, циклическим перебором, алгоритмом кругового обслуживания (round robin). У каждого популярного веб-сайта, например yahoo.com или yandex.ru, одному доменному имени может соответствовать множество IP-адресов, служащих для балансировки нагрузки "каруселью"
+ количество доменных имён, связываемых с одним IP-адресом, не ограничено. Для небольших веб-сайтов обычно множество доменов связано с одним и тем же IP-адресом. Такая конфигурация часто используется для вариантов веб-хостинга, когда на одном веб-сервере может располагаться и работать сотни сайтов с доменными именами наподобие сайт_петра.рф, сайт_ивана.рф или johns-site.com, marys-site.com и т.д.
+ Пример: ```example.com. IN A 192.0.2.1```
#### Запись PTR (pointer — указатель)
+ Выполняет обратную функцию, преобразуя IP-адреса в доменные имена. 
+ В большинстве случаев значения записей "A" и PTR не синхронизированы между собой, например A-запись для some-site.com может ссылаться на IP-адрес a.b.c.d, но PTR-запись для IP-адреса a.b.c.d будет ссылаться например на node52.some-webhosting.com. Поэтому обычно лучше опираться на запись "A". Это часто происходит из-за того, что A-записи управляются владельцами доменов, а PTR-записи управляются владельцами IP-адресов (например, интернет-провайдерами)
+ В контексте PTR-записей есть важное ограничение: каждый IP-адрес может иметь не более одной PTR-записи.
+ Также возможно, что для IP-адреса вообще не настроена PTR-запись. В таком случае при попытке выполнить обратное разрешение IP-адреса в доменное имя ответ будет отрицательным.
#### CNAME (canonical name — каноническое имя)
+ Это псевдоним. Например, если у вашего веб-сайта несколько доменных имён, то вы можете привязать одно к другому, указав это имя как псевдоним к имени, содержащемуся в записи "A". Если A-запись напрямую указывает на IP-адрес, то CNAME-запись указывает на другое доменное имя, которое в конечном итоге будет разрешено в IP-адрес с помощью A-записи - когда DNS-сервер получает запрос для домена с CNAME-записью, он перенаправляет запрос на другое доменное имя и возвращает IP-адрес, связанный с этим именем. Назначение - удобство: A-записи требуют обновления каждого доменного имени, если изменяется IP-адрес, а CNAME-записи позволяют управлять несколькими доменными именами централизованно. Например, изменение IP-адреса в A-записи автоматически применится ко всем доменным именам, которые ссылаются на нее через CNAME.
+ Пример: доменное имя www.example.com является псевдонимом для example.com. Когда клиент запрашивает www.example.com, DNS-сервер сообщает ему, что это имя должно разрешиться как example.com: ```www.example.com. IN CNAME example.com```.
#### MX (mail exchanger — почтовый обменник)
Это запись, указывающая, какой почтовый сервер  обрабатывает электронную почту этого домена. Для одного домена может быть настроено несколько почтовых серверов.
#### Записи NS (Authoritative Name Server — полномочный сервер имён) и SOA (Start-of-authority — начальная запись зоны)
NS-записи и SOA-запись играют важные, но разные роли в DNS:
+ NS-записи указывают на полномочные (авторитативные) серверы, которые ответственны за обработку запросов для домена, 
+ SOA-запись предоставляет основную административную информацию и параметры для управления зоной.
+ Для одной зоны может быть настроено несколько NS-серверов. 
+ С помощью NS-записей «резолверы» получают информацию о следующем сервере DNS, которому следует оправить запрос. 
#### Записи SRV (Server selection — выбор сервера) и TXT (Text String — текстовая строка)
Можно использовать для хранения любой текстовой информации. SRV (Server selection — выбор сервера) и TXT (Text String — текстовая строка)

# 13 Транспортный уровень и анализаторы трафика
## Транспортный уровень модели TCP/IP
Транспортный уровень определяет КАК данные будут передаваться

Транспортный уровень модели TCP/IP представлен в большинстве случаев протоколами TCP (Transmission Control Protocol — протокол управления передачей) и UDP (User Datagram Protocol — протокол пользовательских датаграмм).
### Основные принципы и понятия
#### Сетевые пакеты
+ нельзя передать большой файл за раз одной порцией - он разделяется на пакеты, которые принимающая сторона собирает в файл и передает приложению
+ максимальный размер пакета зависит от настроек канального уровня (Datalink Layer / Interface Layer). В современных сетях MTU (Maximum Transmission Unit) для Ethernet (максимально допустимый размер полезной нагрузки (payload) пакета на уровне канала передачи данных (Layer 2 OSI)) составляет 1500 байт. Это означает, что полезная нагрузка пакета не может превышать 1500 байтов. Включая заголовки и трейлеры, полный размер Ethernet-кадра будет чуть больше 1500 байт, поэтому:
  + когда вы запрашиваете файл или веб-страницу, обычно ваш запрос помещается в один пакет, а ответ сервера обычно превышает размер пакета и поэтому разделяется на части, которые доставляются приложению вашего клиента.
  + когда клиент загружает что-либо, отправляет электронное письмо и т.д. - размер запроса превышает размер одного пакета, потому запрос разделяется на несколько частей и отправляется серверу в виде нескольких пакетов.
#### Сетевые порты
*Сетевой порт* - это логический конструктивный элемент, используемый для идентификации конкретного процесса или сетевой службы на узле в сетевой архитектуре, при отправке данных к нужным процессам, обеспечивая, таким образом, надлежащую доставку информации в системах связи (используются как TCP, так и UDP протоколами). Порты делятся на три категории:
+ Well-known ports (0-1023): зарезервированы для стандартных служб (например, HTTP, FTP, SSH).
+ Registered ports (1024-49151): назначаются определённым приложениям или службам.
+ Dynamic or private ports (49152-65535): используются временными или частными подключениями.
#### Как это работает
+ Сетевое серверное приложение (например, веб-сервер) при запуске  открывает порт и начинает прослушивать его (веб-сервер прослушивает порт 80, а приложение сервера электронной почты слушает порт 25 для принятия входящих запросов)
+ Когда клиент хочет получить веб-страницу, то он должен отправить запрос на порт 80, но если он хочет отправить электронное письмо, то он должен направить его на порт 25.
+ Когда клиент обменивается данными с сервером, порт также открыт и на стороне клиента. Этот порт используется приложением клиента, для взаимодействия с удалённым сервером:
  + Каждое соединение представлено уникальным кортежем значений: {transport_protocol, client_IP, client_port, server_IP, server_port}. Это позволяет ОС клиента различать соединения разных программ, обменивающихся данными с разными удалёнными серверами.
  + Узел клиента может работать с несколькими серверами одновременно.
  + Более того, один и тот же узел клиента может работать с одним и тем же приложением сервера (например, 1.2.3.4:80), используя одновременно несколько приложений (например, запрашивая страницы одного и того же веб-сайта с помощью браузеров Firefox, Safari, Chrome, Opera, — для каждого соединения будет использоваться свой порт клиента, поэтому потоки данных не перепутаются).

Для каждого протокола, TCP и UDP, доступно по 65 536 портов
### TCP — протокол управления передачей
#### Достоинства
1. Управляет очерёдностью данных. На стороне получателя пакеты собираются воедино в том же порядке, в котором они были отправлены
2. Реализует повторную отправку потерянных пакетов. Если получение пакета не подтверждено любой из сторон, этот пакет запрашивается снова.
3. Управляет скоростью потока. Если одна конечная точка отправляет данные быстрее, чем вторая способна обрабатывать, то более медленная сторона может запросить снижение скорости отправки.
#### Недостатки (вызванные достоинствами):
1. Процессор должен выполнить намного больше работы, чтобы заполнить все поля заголовка
2. К каждой порции данных пакета, не превышающей **64 килобайт** (это максимально допустимый размер IP-пакета для IPv4), добавляется заголовок TCP размером от 20 и 40 байтами. Нужно уточнить **как это соотносится с MTU и MSS**:
   1. **Максимальный размер IP-пакета:** IP-пакет может быть размером до 65535 байт, включая заголовок, в теории - это максимальный размер, который может быть обработан IP-протоколом.
   2. **MTU и реальный размер пакетов:** На практике, размер пакета ограничивается MTU канального уровня. Для Ethernet это обычно 1500 байт. Это означает, что IP-пакет, передаваемый по Ethernet, не может превышать 1500 байт, чтобы избежать фрагментации.
   3. **MSS (Maximum Segment Size):**
      1. MSS — это максимальный размер TCP-сегмента, который передается в одном IP-пакете без фрагментации. MSS рассчитывается как MTU минус размер заголовков IP и TCP.
      2. Для Ethernet с MTU 1500 байт, MSS составляет 1460 байт (1500 - 20 байт IP-заголовок - 20 байт TCP-заголовок).

*Примечание:*

Эти накладные расходы особенно обременительны, если вы используете протокол TCP для передачи небольших пакетов данных. Например, протокол SSH отправляет каждый введённый вами с помощью клавиатуры символ как отдельный пакет. Таким образом, на один байт (на самом деле больше — из-за шифрования) «полезных данных» придется 20–40 байт заголовка TCP, поэтому протокол TCP обычно используется как основа для обмена данными между сетевыми приложениями, которым необходим строгий порядок отправки и получения данных и гарантия доставки. Примеры таких приложений:
+ Электронная почта
+ Торговля через Интернет и банковские приложения
+ Базы данных
+ Веб-сервисы
#### Поля TCP-пакета
<img src="resources/tcp.png" alt="Структура TCP-пакета" width="50%"/>

1. *Sequence number* (порядковый номер) - Протокол TCP сохраняет порядок следования пакетов. Sequence number используется для нумерации пакетов. У каждого пакета есть свой номер.
2. *Acknowledgment number* (номер подтверждения) - В протоколе TCP предусмотрен механизм подтверждения, поэтому узел должен отправлять подтверждение для каждого полученного пакета.
3. *Window* (окно)  - с помощью этого поля Window получатель может ограничивать объём входящих данных от отправителя, управляя скоростью передачи данных.
4. *Flags* (флаги) - используется для добавления в пакет специальных меток.
5. *Destination Port* (порт назначения) - используется для определения, какому приложению или службе на конечном узле предназначены данные;
6. *Source Port* (порт источника) - результат работы ОС на обращение приложения с просьбой установить соединение TCP с узлом x.y.w.v, порт abc. Порядок применения поля следующий:
   1. приложения с просит ОС установить TCP-соединение с узлом x.y.w.v, порт abc
   2. ОС резервирует локальный порт со случайным номером, связанным с IP-адресом, который будет использоваться для установки соединения
   3. ОС создаёт специальный программный интерфейс [сокет](#socket-position), представленный и идентифицирующийся в ОС с помощью уникального **кортежа** {transport_protocol, client_IP, client_port, server_IP, server_port}, который ассоциирует адрес памяти вашего компьютера с ссылкой на этот порт
   4. Далее, когда приложение хочет отправить некоторые данные этому удалённому узлу и порту, оно просто использует сокет, не заботясь о процессе передачи данных

*Пример на Python программного создания/применения TCP-сокета для сервера (SOCK_STREAM - означает TCP-сокет):*
```python
# Создание TCP сокета
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Привязка сокета к порту и прослушивание
server_address = ('localhost', 10000)
sock.bind(server_address)
sock.listen(1)

print('TCP сервер готов принимать соединения...')

while True:
# sock.accept() возвращает кортеж, где: 
# Первый элемент — это новый сокет, созданный для конкретного клиентского подключения.
# Второй элемент — это адрес клиента.
    connection, client_address = sock.accept()
    try:
        print(f'Подключено к {client_address}')
        
        while True:
            data = connection.recv(4096)
            if data:
                print(f'Получено: {data}')
                connection.sendall(data)
            else:
                break
    finally:
        connection.close()
```
*Пример на Python программного создания/применения TCP-сокета (SOCK_STREAM - означает TCP-сокет) для клиента:*
```python
# Создание TCP сокета
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_address = ('localhost', 10000)
sock.connect(server_address)

try:
    message = b'Hello, Server'
    print(f'Отправка {message}')
    sock.sendall(message)

    data = sock.recv(4096)
    print(f'Получено {data}')
finally:
    sock.close()
```
#### Процедура установки соединения (TCP handshake)
![«рукопожатие TCP»](resources/TCP_handshake.png)

По протоколу TCP данные можно отправлять только после установки соединения между клиентом и сервером. Алгоритм следующий:
1. В самом начале у нас есть клиент без каких-либо соединений и связанных с ними состояний, и сервер в состоянии LISTEN (прослушивание), которое означает, что сервер ждёт запроса на установку соединение. Если клиент попытается соединиться с портом, который никто не прослушивает, то он получит пакет с флагом RST (reset — сброс).
2. Клиент генерирует случайный номер (X) и в поле Sequence Number отправляет его серверу в  TCP пакете с меткой SYN, помещённой в поле флагов. SYN означает «синхронизация». Теперь соединение находится в состоянии SYN-SENT (SYN отправлен).
3. Сервер получает от клиента пакет SYN и формирует пакет с подтверждением устанавливая флаг ACK и копируя в поле Acknowledgment Number значение X + 1. Также сервер устанавливает в своём пакете флаг SYN и записывает свой случайный номер (Y) в поле Sequence Number, а затем отправляет TCP-пакет клиенту. Теперь соединение находится в состоянии SYN-RECEIVED (SYN получен).
4. Клиент получает от сервера пакет SYN+ACK и отправляет обратно пакет с флагом ACK и номером Y + 1 в поле Acknowledgment Number. Теперь у нас есть соединение в состоянии ESTABLISHED (установлено).
5. Теперь обе стороны знают, что между ними установлена связь, и могут отправлять полезные данные 
#### Обмен данными
После установления соединения начинается передача данных. Обмен данными в TCP-соединении осуществляется посредством последовательности сегментов с полезной нагрузкой (payload). Вот основные моменты этого процесса:
1. Передача данных:
   1. Данные разбиваются на сегменты, и каждый сегмент включает заголовок TCP, содержащий важные поля, такие как номера последовательности (SEQ) и подтверждения (ACK).
2. Номер последовательности (Sequence Number):
   1. Каждому байту данных присваивается уникальный номер последовательности. Поле SEQ в заголовке TCP указывает номер первого байта данных в данном сегменте.
   2. Например, если клиент отправляет данные длиной 100 байт, начальный SEQ равен 1000, то первый сегмент будет иметь SEQ = 1000. Если сервер подтверждает получение этого сегмента, он отправит ACK = 1100, указывая, что он ожидает следующий байт данных с номером 1100.
3. Номер подтверждения (Acknowledgment Number):
   1. Поле ACK в заголовке TCP указывает следующий ожидаемый номер последовательности от отправителя данных.
   2. Если клиент получил сегмент с SEQ = 1000 и длиной 100 байт, он отправит ACK = 1100, подтверждая получение данных и указывая, что он ожидает следующий сегмент с SEQ = 1100.
4. Контрольные флаги (Control Flags):
   1. Флаги SYN и ACK используются только в процессе установления соединения.
   2. В процессе обмена данными используются другие флаги, такие как PSH (Push) и URG (Urgent). Флаг PSH указывает на необходимость немедленной обработки данных, а флаг URG обозначает срочные данные.
#### Процедура завершением соединения (TCP teardown)
![TCP teardown](resources/tcp_close.gif)

1. Первый способ закрыть соединение TCP — это просто перестать отвечать. Удалённый узел выждет определённый период (время ожидания, настроенное в операционной системе) и удалит информацию об этом соединении из памяти. Это произойдёт, например, в случае перезагрузки одного из узлов.
2. Второй способ:
   1. Вначале узел отправляет пакет с флагом FIN.
   2. Второй узел отправляет первому подтверждение.
   3. Второй узел отправляет свой пакет с флагом FIN.
   4. Первый узел отправляет последний пакет с флагом ACK.
#### Список состояний TCP-соединения
  + LISTEN: Сервер ждет входящих соединений от клиентов. Это состояние ожидает, когда кто-то инициирует соединение.
  + SYN-SENT: Клиент отправил запрос на установление соединения (SYN) и ждет подтверждения от сервера. Это состояние устанавливается после отправки SYN-пакета.
  + SYN-RECEIVED: Сервер получил запрос на установление соединения (SYN) и отправил подтверждение (SYN-ACK). Это состояние устанавливается после отправки SYN-ACK, но до получения ACK от клиента.
  + ESTABLISHED: Соединение установлено, и данные могут передаваться в обоих направлениях. Это основное состояние для активного соединения.
  + FIN-WAIT-1: Активная сторона (которая инициировала завершение соединения) отправила запрос на завершение соединения (FIN) и ждет подтверждения (ACK) от другой стороны.
  + FIN-WAIT-2: Активная сторона получила подтверждение (ACK) на свой запрос на завершение соединения (FIN) и ждет запроса на завершение (FIN) от другой стороны.
  + CLOSE-WAIT: Пассивная сторона (которая не инициировала завершение) получила запрос на завершение соединения (FIN) и отправила подтверждение (ACK). Теперь она ждет, когда приложение закроет соединение.
  + CLOSING: Обе стороны одновременно отправили запрос на завершение соединения (FIN). Это редкое состояние, когда каждая сторона ждет подтверждения от другой.
  + LAST-ACK: Пассивная сторона отправила запрос на завершение соединения (FIN) после получения запроса на завершение (FIN) от активной стороны и теперь ждет подтверждения (ACK).
  + TIME-WAIT: Активная сторона завершила соединение и ждет, чтобы убедиться, что другая сторона получила подтверждение (ACK) на ее запрос на завершение (FIN). Это состояние длится в течение времени, называемого TIME-WAIT (обычно 2 * MSL, максимальная длительность жизни сегмента).
  + CLOSED: Соединение закрыто, и никаких дальнейших данных не передается. Это состояние представляет завершенное соединение.
#### Диаграмма переходов между состояниями TCP в зависимости от полученных и отправленных пакетов (RFC 793):
1. LISTEN:
   + Получение SYN → SYN-RECEIVED
   + Отправка SYN → SYN-SENT
2. SYN-SENT:
   + Получение SYN-ACK → ESTABLISHED
   + Получение SYN → SYN-RECEIVED
   + Получение RST → CLOSED
3. SYN-RECEIVED:
   + Получение ACK → ESTABLISHED
   + Получение SYN-ACK → SYN-RECEIVED (если устанавливается симметричное соединение)
4. ESTABLISHED:
   + Получение FIN → CLOSE-WAIT
   + Отправка FIN → FIN-WAIT-1
5. FIN-WAIT-1:
   + Получение ACK → FIN-WAIT-2
   + Получение FIN → CLOSING
6. FIN-WAIT-2:
   + Получение FIN → TIME-WAIT
7. CLOSE-WAIT:
   + Отправка FIN → LAST-ACK
8. CLOSING:
   + Получение ACK → TIME-WAIT
9. LAST-ACK:
   + Получение ACK → CLOSED
10. TIME-WAIT:
    + По истечении времени → CLOSED
11. CLOSED:
    + Конечное состояние, никаких переходов не происходит.
#### Пример процесса установки и завершения соединения:
1. Установка соединения:
   1. Клиент в состоянии CLOSED отправляет SYN и переходит в состояние SYN-SENT.
   2. Сервер в состоянии LISTEN получает SYN, отправляет SYN+ACK и переходит в состояние SYN-RECEIVED.
   3. Клиент в состоянии SYN-SENT получает SYN+ACK, отправляет ACK и переходит в состояние ESTABLISHED.
   4. Сервер в состоянии SYN-RECEIVED получает ACK и переходит в состояние ESTABLISHED.
2. Обмен данными:
   1. Оба участника находятся в состоянии ESTABLISHED и обмениваются данными.
3. Завершение соединения:
   1. Клиент в состоянии ESTABLISHED отправляет FIN и переходит в состояние FIN-WAIT-1.
   2. Сервер в состоянии ESTABLISHED получает FIN, отправляет ACK и переходит в состояние CLOSE-WAIT.
   3. Клиент в состоянии FIN-WAIT-1 получает ACK и переходит в состояние FIN-WAIT-2.
   4. Сервер в состоянии CLOSE-WAIT отправляет FIN и переходит в состояние LAST-ACK.
   5. Клиент в состоянии FIN-WAIT-2 получает FIN, отправляет ACK и переходит в состояние TIME-WAIT.
   6. Сервер в состоянии LAST-ACK получает ACK и переходит в состояние CLOSED.
   7. Клиент в состоянии TIME-WAIT ждет определенное время и переходит в состояние CLOSED.
### UDP — протокол пользовательских датаграмм
В отличие от TCP, UDP обеспечивает ненадежную и неупорядоченную передачу данных, что делает его более быстрым и легковесным, но менее надежным (нет упорядочивания пакетов, подтверждения получения данных и управления скоростью потока, UDP не использует соединение: нет ни «рукопожатия», ни вежливого «прощания», только передача данных от одной точки к другой)

![Структура UDP-пакета](resources/udp.gif)

Структура заголовка UDP (поле Data (данные) содержит данные приложения, инкапсулируемые в пакете). 

Протокол UDP применяют в случае когда нет времени на повторную отправку повреждённых данных т.к. моменту повторной отправки эти данные уже утратят актуальность:
+ потоковой передачи мультимедиа
+ голосовой связи (VoIP)
+ преобразования доменных имён в системе DNS и онлайн-игр

Как и в TCP, в протоколе UDP предусмотрено следующее:
+ Порты как для клиента, так и сервера.
+ Работа с сокетами - основным механизмом для передачи данных между устройствами в сети.
### QUIC
Протокол QUIC (Quick UDP Internet Connections) представляет собой современный транспортный протокол, разработанный Google, который работает поверх UDP

Ключевые особенности QUIC:<a id="quic"></a>
+ QUIC позволяет установить защищенное соединение за один RTT (Round-Trip Time), объединив процесс установки соединения и TLS рукопожатие.
+ QUIC поддерживает мультиплексирование множества логических потоков в рамках одного соединения (мультиплексирование без блокировки: позволяет избежать проблем с задержками и блокировками, связанных с HTTP/2)
+ QUIC позволяет сохранять соединение при смене IP-адреса или порта (полезно для мобильных устройств, меняющих сети, переключаясь с Wi-Fi на мобильные данные).
+ QUIC включает в себя интеграцию с TLS 1.3: все соединения QUIC шифруются по умолчанию, обеспечивая защиту данных в транзите.
+ QUIC включает современные алгоритмы управления перегрузкой и механизмы восстановления потерь (обработки потерь пакетов), которые более эффективны  по сравнению с TCP.

Примеры протоколов прикладного уровня, которые взаимодействуют с QUIC: HTTP/3, DNS over QUIC, gRPC over QUIC, SMB over QUIC, WebRTC over QUIC и FTP over QUIC.
### Средства командной строки для работы с портами
#### Мониторинг прослушиваемых портов TCP и UDP:
Это порты, на которых сервер ожидает входящих соединений от клиентов:
+ ОС Linux: ```netstat -vpntul``` или ```ss -pntul```
+ macOS: ```netstat -anf inet | egrep -v 'EST|WAIT' | sort | uniq```
+ Windows: ```netstat```
#### Мониторинг активных портов TCP и UDP (ESTABLISHED):
Это порты, на которых сетевое соединение активно передает данные:
+ ОС Linux: ```netstat -vpntu```
+ macOS: ```netstat -anf inet | egrep EST```
+ Windows: ```netstat -a```
#### Cоотнесение портов с сетевыми приложениями
+ (только для Linux) с помощью сведений в правом столбце: ```netstat -vpntul``` (за соотнесение портов с сетевыми приложениями отвечает параметр -p).
+ (только для  Linux и macOS) в файле ```/etc/services```:
  ```http            80/tcp          www     # WorldWideWeb HTTP```
#### netstat подробно <a id="netstatdetail">
netstat — самая известная (но немного устаревшая) из инструментов анализа сетевых соединений. Часто используемые опции следующие:
+ ```-n```: отображение портов и адресов узлов в виде чисел и IP-адресов соответственно. Рекомендуется ее применять, так как это позволяет избежать задержек, связанных с попыткой разрешения имен хостов и сервисов.
+ ```-t``` отображение портов TCP.
+ ```-u```: отображение портов UDP; может сочетаться с ```-t```.
+ ```-l```: отображение только прослушиваемых портов. Если эту опцию упустить, то будут отображаться только активные соединения (а не прослушиваемые порты).
+ ```-a```: отображение как прослушиваемых портов, так и активных соединений.
+ ```-p```: отобразить процессы, открывшие эти порты и соединения; показывается ограниченный объём информации, если вы не являетесь пользователем root.

<a id="socket-position"></a>

### Сокеты и сетевые порты
#### Как сокеты соотносятся с портами и процессами
Сокеты представлены и идентифицируются в ОС с помощью уникального **кортежа** 
+ {transport_protocol, client_IP, client_port, server_IP, server_port}

Значение **кортежа** в виде значений колонок ```Proto```, ```LocalAddress``` и ```Foreign Address``` образует вывод команды ```netstat```:
```console
$ netstat -pnt
Не все процессы могут быть идентифицированы, информация о не принадлежащих процессах не будет показана, вам придется стать root, чтобы увидеть все это.)
Активные интернет-соединения (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp       25      0 192.168.31.18:52024     170.114.52.3:443        CLOSE_WAIT  61649/zoom          
tcp        0      0 192.168.31.18:59570     52.149.21.60:443        ESTABLISHED 6802/skypeforlinux  
tcp       25      0 192.168.31.18:52034     170.114.52.3:443        CLOSE_WAIT  61649/zoom          
tcp        0      0 192.168.31.18:51420     3.68.61.181:443         ESTABLISHED 9223/Slack --standa
[ ...  и ниже еще больше строк ... ]
```
*Примечание: Строки 1 и 3 относятся к двум процессам zoom, которые закрывают соединения с удалённым сервером 170.114.52.3. ОС клиента их различает по разным сокетам, так как клиентские порты разные.*
#### Серверные (т.е. прослушиваемые) порты
Порты серверов (т.е. прослушиваемые порты) показываются тоже как сокеты, но у них ненастоящие адреса в поле ```Foreign Address``` (внешний адрес), так как никто ещё не подключён.
```
$ netstat -ntul
Активные интернет-соединения (только сервера)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
tcp6       0      0 :::7031                 :::*                    LISTEN     
tcp6       0      0 ::1:25                  :::*                    LISTEN     
tcp6       0      0 :::33060                :::*                    LISTEN     
tcp6       0      0 :::9031                 :::*                    LISTEN     
tcp6       0      0 :::3306                 :::*                    LISTEN  
udp        0      0 127.0.0.53:53           0.0.0.0:*             
```
*!!! На примере выше:*
+ Для прослушиваемых портов внешние адреса показываются как 0.0.0.0:* или :::* (для tcp6)
+ Локальные адреса, наподобие 1.2.3.4:5000, показывают, на каком IP-адресе доступен этот порт
  + 0.0.0.0 означает, что этот порт доступен на всех IP-адресах этого сервера. Например, если у сервера IP-адреса 1.2.3.4 и 5.6.7.8, то клиенты для доступа к этому порту (и соответствующему приложению, прослушивающему этот порт) могут указать любой из этих адресов
  + 127.0.0.1 означает, что этот порт доступен только на этом IP-адресе, то есть, чтобы получить доступ к этому порту (например, 25), клиент должен использовать IP-адрес 127.0.0.1. (IP-адрес 127.0.0.1 говорит, согласно сказанному ранее в этом модуле, что такое возможно, только если клиентское приложение и сервер работают на одном компьютере).
+ ":::7031" вместе с меткой "tcp6" означают, что порт TCP 7031 доступен посредством протокола TCP, при использовании как IPv4, так и IPv6, на любом IP-адресе компьютера. Символы “::” в версии IPv6 являются аналогом 0.0.0.0 в версии IPv4, обозначающим все IP-адреса.
+ "::1:25" означает то же, что и 127.0.0.1:25, но для IPv6. Поэтому "::1" в версии IPv6  это аналог адреса 127.0.0.1 версии IPv4.
+ Для портов UDP состояние LISTEN не показывается, но в действительности они являются прослушиваемыми портами.
+ порт 53 не используется дважды как кажется, а дважды открыт для двух разных протоколов: TCP и UDP.

*Примечание:*
+ У одного процесса может быть много сокетов. Каждый сокет может быть связан с одним и только одним локальным IP-адресом и одним локальным портом (и с одним внешним IP-адресом и внешним портом, если говорить об активных соединениях). Поэтому взаимосвязи между ними следующие:
  + процесс и сокеты: один-ко-многим
  + сокеты и кортежи {transport_protocol, local_IP, local_port, remote_IP, remote_port}: один-к-одному.
+ Если приложение хочет создать прослушиваемый порт (например, 22) с использованием определённого протокола (например, TCP), этот порт должен быть свободен. В противном случае, ОС отправит сообщение об ошибке и прервёт эту попытку.
+ Если порт сервера не прослушивается ни одним процессом, то он называется закрытым портом (то есть он свободен). Такие порты не показаны в выводе программы netstat из примера выше.
+ Если клиентское приложение попытается соединиться с закрытым портом, то ответ сервера будет зависеть от протокола:
  + TCP: сервер отправит пакет с установленным флагом RST, означающим, что это соединение было сброшено из-за сбоя.
    + UDP: для этого протокола флаги наподобие RST не предусмотрены. Вместо пакета с таким флагом сервер может отправить сообщение ICMP Destination Unreachable (порт недоступен), говорящее клиенту, что этот порт никто не прослушивает. Отправка такого сообщения ICMP является желательным поведением согласно стандартам, но не обязательным. Сервер может быть настроен на игнорирование таких запросов по разным причинам, например, для обеспечения безопасности.
+ Когда клиентское приложение соединяется с сервером, серверное приложение (прослушивающее соответствующий порт) открывает активный сокет для обработки запроса. В то же время прослушиваемый сокет не затрагивается и остаётся готовым для новых соединений с другими клиентами.

![Схематическое представление клиентских и серверных сокетов](resources/09-sockets.png)

Схематическое представление клиентских и серверных сокетов
## Анализаторы сетевого трафика «снифферы»
### Общие понятия
Самые популярные анализаторы — **tcpdump** и **Wireshark**. Они могут значительно помочь в поиске и устранении сложных неисправностей, связанных с сетью, например:
+ Сервер работает, но не отвечает
+ Сервер работает, но его ответы выглядят некорректно.
+ Состояние сервера неизвестно, удалённый доступ (например, посредством сессии SSH) запрещён, поэтому нам нужно посмотреть, что происходит с сетевым трафиком
### tcpdump <a id="tcpdump"></a>
tcpdump — это анализатор пакетов с интерфейсом командной строки, совместимый с большинством современных ОС

```tcpdump <options> <expression>```, где 
+ options - определяют, что и как будет собираться, а 
+ expression - фильтры
#### Опции для сбора пакетов:
Опции определяют, что и как будет собираться:
+ ```-c <N>``` (например, ```-c 20```): собрать первые N пакетов и выйти. По умолчанию, "tcpdump" работает до остановки нажатием Ctrl+C;
+ ```-i <interface_name>``` (название интерфейса): задают сетевой интерфейс, например ```lo``` или ```eth0```; по умолчанию берётся первый интерфейс, не являющийся ```lo```. Для сбора пакетов со всех интерфейсов нужно указать следующее: ```-i any```, например, ```tcpdump -i eth0,eth1```;
+ ```-s <N>```: установка захватываемой длины пакета. ```-s 0``` — для сбора полных пакетов; ```-s60``` — для сбора только первых 60 байт каждого пакета;
+ ```-w <file>``` (файл): вместо вывода на терминал сохранять поток собранных данных в файле формата PCAP (формат файлов для хранения необработанных сетевых данных);
+ ```-r <file>``` (файл): считывать пакеты из файла PCAP, а не из сетевых интерфейсов. Опция полезна для глубокого исследования сетевого потока.
#### Опции для отображения:
Эти опции определяют, как  данные пакетов будут отображаться программой tcpdump, и не влияют на параметры сбора. Поэтому их можно применить как для вышеупомянутых файлов PCAP (если используется опция -r), так и для сбора пакетов в реальном времени (опция -i):
+ ```-n```: не преобразовывать IP-адреса в имена узлов;
+ ```-nn```: показывать адреса узлов в виде IP-адресов, а порты в виде номеров. Эту опцию рекомендуется использовать в большинстве случаев;
+ ```-X```: вывод необработанного содержимого пакетов, представленного как шестнадцатеричной формой, так и форматом, удобным для человека (символы ASCII). Очень полезна для более тщательного анализа содержимого пакетов при изучении неисправностей;
+ ```-A```: вывод необработанного содержимого пакетов в компактном формате без шестнадцатеричной части. Если не указаны -X, и -A, то в формате, удобном для человека, отображаются только заголовки;
+ ```-ttt```: вместо полной временной метки выводить прирост времени с момента предыдущего элемента;
+ ```-v``` / ```-vv``` / ```-vvv```: три степени подробности.
#### Выражения (фильтры):
С помощью выражений (также называемых фильтрами) определяются элементы, которыми необходимо ограничить сбор данных. Элементы можно сочетать с помощью ключевых слов or (или), and (и), not (не), а также с помощью скобок. Если логические операторы не указаны, то tcpdump интерпретирует их по умолчанию как логическое "И".  Если применяются скобки, то выражение необходимо заключать в кавычки, например: "(tcp or icmp)", а не (tcp or icmp). Можно применять как двойные, так и одинарные кавычки.

| Синтаксис  | Значения  | Примеры выражений (фильтров)  | Пояснение  |
|-----------|-----------|-----------|-----------|
| host X | Только трафик, исходящий от узла X или предназначающийся ему. Это двунаправленное условие, поэтому собираются как запросы клиентов, так и ответы серверов | host example.com<br><br>host 8.8.8.8 | Весь поток пакетов между данным узлом (на котором установлена программа tcpdump) и удалённым узлом example.com. То же для узла 8.8.8.8 |
| net X/Y | Подобно host, но собирается поток данных для всех узлов этой сети. X — адрес сети, Y — маска подсети. Например, tcpdump может быть запущен на узле, который видит весь трафик этой сети. Это может быть маршрутизатор, коммутатор с настроенным SPAN-портом или сервер, через который проходит весь трафик сети. | net 8.8.0.0/16 | Весь поток пакетов, проходящий между данным узлом и любым узлом сети 8.8.0.0/16 |
| tcp / udp / icmp | Название протокола, поток которого будет собираться | tcp and port 8080<br><br>udp and not port 53<br><br>icmp | Пакеты TCP, исходящие из порта 8080 или предназначающиеся ему.<br>Пакеты UDP, исходящие из любого порта или предназначающиеся любому порту кроме 53.<br>Все пакеты протокола ICMP |
| port X | Номер порта протокола TCP или UDP. Не применимо к ICMP, так как в рамках этого протокола порты не используются | "tcp and (port 22 or port 3389)"<br><br>port 53 | Пакеты TCP, исходящие из порта 22 или 3389 или предназначающиеся им.<br><br>Пакеты TCP и UDP, исходящие из порта 53 или предназначающиеся ему |
| src | Применимо к ключевым словам host, net, port, portrange. Означает поток данных, исходящий  от этого источника: узла, сети, порта или диапазона портов (portrange) | tcp and src host 192.168.40.150 and src port 22<br><br>udp and dst host 8.8.8.8 and dst port 53 | Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.<br><br>Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться). |
| dst | Подобно src, но означает поток данных, идущий к указанному узлу, сети, порту, диапазону портов | tcp and src host 192.168.40.150 and src port 22<br><br>udp and dst host 8.8.8.8 and dst port 53 | Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.<br><br>Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться). |
| portrange X-Y | Сбор только пакетов протокола TCP или UDP с любым номером порта (исходящего и входящего) в диапазоне от X до Y | tcp and src portrange 1-1023 | Все пакеты TCP, исходящие от портов с номерами от 1 до 1023 |

*Пример 1. Собрать все пакеты TCP с портами 80 или 443, идущие между данным узлом и узлом example.com*
```console
$ sudo tcpdump 'tcp and host example.com and (port 80 or port 443)'
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes

14:53:25.123456 IP your_machine.local.12345 > example.com.http: Flags [S], seq 123456789, win 65535, options [mss 1460,sackOK,TS val 123456789 ecr 0,nop,wscale 6], length 0
14:53:25.123789 IP example.com.http > your_machine.local.12345: Flags [S.], seq 987654321, ack 123456790, win 65535, options [mss 1460,sackOK,TS val 987654321 ecr 123456789,nop,wscale 6], length 0
14:53:25.124012 IP your_machine.local.12345 > example.com.http: Flags [.], ack 987654322, win 65535, options [TS val 123456790 ecr 987654321], length 0
14:53:25.124345 IP your_machine.local.12345 > example.com.http: Flags [P.], seq 123456790:123456850, ack 987654322, win 65535, options [TS val 123456790 ecr 987654321], length 60: HTTP: GET / HTTP/1.1
14:53:25.124678 IP example.com.http > your_machine.local.12345: Flags [.], ack 123456850, win 65535, options [TS val 987654322 ecr 123456790], length 0
14:53:25.125001 IP example.com.http > your_machine.local.12345: Flags [P.], seq 987654322:987654382, ack 123456850, win 65535, options [TS val 987654322 ecr 123456790], length 60: HTTP: HTTP/1.1 200 OK

14:54:00.234567 IP your_machine.local.54321 > example.com.https: Flags [S], seq 234567890, win 65535, options [mss 1460,sackOK,TS val 234567890 ecr 0,nop,wscale 6], length 0
14:54:00.234890 IP example.com.https > your_machine.local.54321: Flags [S.], seq 987654321, ack 234567891, win 65535, options [mss 1460,sackOK,TS val 987654321 ecr 234567890,nop,wscale 6], length 0
14:54:00.235012 IP your_machine.local.54321 > example.com.https: Flags [.], ack 987654322, win 65535, options [TS val 234567891 ecr 987654321], length 0
14:54:00.235345 IP your_machine.local.54321 > example.com.https: Flags [P.], seq 234567891:234567951, ack 987654322, win 65535, options [TS val 234567891 ecr 987654321], length 60: HTTPS
14:54:00.235678 IP example.com.https > your_machine.local.54321: Flags [.], ack 234567951, win 65535, options [TS val 987654322 ecr 234567891], length 0
14:54:00.236001 IP example.com.https > your_machine.local.54321: Flags [P.], seq 987654322:987654382, ack 234567951, win 65535, options [TS val 987654322 ecr 234567891], length 60: HTTPS
```
##### Значения флагов в поле Flags:
По значениям флагов в поле Flags можно определить тип каждого пакета и понять последовательность установления соединения и передачи данных:
+ [F.] - FIN-ACK пакет. Указывает на завершение соединения и подтверждение.
+ [R.] - RST-ACK пакет. Указывает на сброс соединения и подтверждение.
+ [S] - Только SYN пакет. Инициирует соединение.
+ [S.] - SYN-ACK пакет. Подтверждает запрос на установление соединения.
+ [.] - Только ACK пакет. Подтверждение получения данных.
+ [P.] - PSH-ACK пакет. Указывает на немедленную передачу данных и подтверждение.
+ [U] - URG пакет. Указывает на срочные данные.
+ [U.] - URG-ACK. Указывает на срочные данные с подтверждением.
+ [F] - Только FIN пакет. Указывает на завершение соединения.
+ [FP.] - FIN-PSH-ACK. Указывает на завершение соединения, немедленную передачу данных и подтверждение.

*Пример 2. Изучить обмен данными по протоколу UDP, проанализировав процесс преобразования доменного имени example.com общедоступным сервером DNS (т. е. «резолвером») с адресом 8.8.8.8:*
```console
[user@host]$ sudo tcpdump -nn -ttt 'udp and host 8.8.8.8 and port 53'
tcpdump: data link type PKTAP
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on pktap, link-type PKTAP (Apple DLT_PKTAP), capture size 262144 bytes
 00:00:00.000000 IP 192.168.0.6.49292 > 8.8.8.8.53: 24940+ [1au] A? example.com. (40)
 00:00:00.028381 IP 8.8.8.8.53 > 192.168.0.6.49292: 24940$ 1/0/1 A 93.184.216.34 (56)
```
*Примечание*: 
1. Обмен данными в примере 2 намного короче, чем в примере 1, так как нет «рукопожатия», используемого в протоколе TCP. В выводе мы видим только передачу данных.
2. tcpdump может мониторить [QUIC](#quic), но есть некоторые аспекты, которые стоит учитывать:
   1. QUIC - это протокол транспортного уровня, который работает поверх UDP. Это значит, что tcpdump, который изначально предназначен для захвата пакетов на уровне TCP/IP, может захватывать и UDP-пакеты, включая те, которые используются для QUIC.
      1. Команда для захвата трафика: ```sudo tcpdump -i <interface> udp port 443```
      2. Пример вывода:
         ```console
         18:15:01.123456 IP 192.168.1.100.12345 > 93.184.216.34.443: UDP, length 1252
         18:15:01.124789 IP 93.184.216.34.443 > 192.168.1.100.12345: UDP, length 1350
         18:15:01.126012 IP 192.168.1.100.12345 > 93.184.216.34.443: UDP, length 1200
         18:15:01.127345 IP 93.184.216.34.443 > 192.168.1.100.12345: UDP, length 1250
         ```
   2. Однако, поскольку QUIC использует шифрование (TLS 1.3), содержимое пакетов QUIC будет зашифровано, что означает, что tcpdump не сможет расшифровать их содержимое напрямую. Вместо этого он будет отображать метаданные пакетов QUIC, такие как исходный и целевой IP-адреса, порты, размеры пакетов и т. д. Расшифровка содержимого QUIC возможна только с использованием специализированных инструментов, поддерживающих декодирование QUIC (например, Wireshark с расширением для QUIC).
### Wireshark
Wireshark — анализатор сетевых данных, созданный на основе той же библиотеки, что и tcpdump, но с графическим интерфейсом пользователя
+ В отличие от ```tcpdump``` Wireshark кроме отображения пакетов TCP и UDP может автоматически определять сообщения протоколов прикладного уровня (например, HTTP)
+ Wireshark схожа с ```tcpdump``` и наличием фильтра пакетов. Логика составления выражений во многом та же, но синтаксис несколько отличается:
  + [Wireshark — подробное руководство по началу использования](https://habr.com/ru/articles/735866/),
  + [Wireshark фильтр по IP, по порту, по протоколу, по MAC](https://networkguru.ru/wireshark-filtr-po-ip-portu-protokolu-mac/),
  + [Как настроить фильтры для захвата трафика в WireShark? Примеры!](https://networkguru.ru/kak_nastroit_filtru_dlya_zahvata_trafika/)
#### Особенности захвата и анализа трафика QUIC с использованием TCPdump + Wireshark
Захват и анализ трафика QUIC с использованием TCPdump имеет свои особенности и ограничения. Вот ключевые моменты:
1. Захват трафика QUIC с помощью TCPdump:
```console
sudo tcpdump -i eth0 udp port 443 -w quic_traffic.pcap
```
1. Анализ трафика в Wireshark:
+ Откройте файл quic_traffic.pcap в Wireshark.
+ Использовать фильтр отображения для поиска пакетов QUIC: quic.
+ Если доступны ключи шифрования, импортируйте их в Wireshark для расшифровки трафика:
  + В меню Wireshark выберите Edit > Preferences.
  + Перейдите в раздел Protocols > TLS.
  + В поле (Pre)-Master-Secret log filename укажите путь к файлу с ключами.

# 14 Поиск сетевых неисправностей
## Проблемы на сетевом уровне
### ICMP — Internet Control Message Protocol
**ICMP** - протокол транспортного уровня. Служит для пересылка сообщений о состоянии узлов и сетевых проблемах от одного узла к другому (не для передачи данных).

<img src="resources/ts_1.png" alt="Структура пакета ICMP" width="70%"/>, где:

+ Type (Тип) - поле, определяющее тип сообщения ICMP, например, ошибки в сети, запросы эха (ping) и другие управляющие сообщения.
  + "Echo Request"(Эхо-запрос) (Type=8) и “Echo Reply” (Type=0). Эти типы используются утилитой ping, а также программой traceroute в режиме ICMP
  + "Destination Unreachable" (Type=3) - используя этот тип сообщения, шлюзы уведомляют, что они не могут достичь узла назначения текущего IP-пакета.
  + "Time Exceeded" (Type=11). Если на шлюз пришел пакетом с нулевым полем TTL в заголовке IP (Time to live — время существования, то есть количество промежуточных узлов, до исчерпания которого пакет существует в сети, а затем отбрасывается маршрутизатором), то он пошлёт отправителю сообщение «Время истекло». Именно на основе этого принципа работает утилита traceroute
+ Code (Код) - дополнительное поле, которое дополняет тип сообщения и может уточнять его. Например, для сообщений об ошибке этот код может указывать на конкретный тип ошибки.
  + "Destination port unreachable" (Code=3) добавляется в некоторых случаях удалённым узел в ответ на попытку подключения по протоколу UDP к закрытому порту в дополнение к "Destination Unreachable" (Type=3) (так как у самого UDP нет способа реакции на такое событие)
  + "Time to live exceeded in transit" (Code=0) при Time Exceeded (Type=11) обычно используется для указания причины превышения времени
+ Checksum (Контрольная сумма): Это поле содержит контрольную сумму заголовка ICMP-сообщения, помогая обнаруживать ошибки в передаче данных.
+ Content (Содержание) - содержимое самого сообщения ICMP, которое может варьироваться в зависимости от его типа и кода. Например, для сообщений об ошибках содержание может включать дополнительную информацию о характере ошибки, а для запросов эха - данные для проверки доступности хоста.

*ICMP не предполагает использование портов.*
### ping
ping -  сетевая утилита, используемая для диагностики сетевых подключений.
#### Функции 
+ Проверка достижимости удалённого узла.
+ Измерение суммарного времени, потраченного на передачу и подтверждение пакета (параметр RTT, round-trip time). Высокие значения RTT указывают на высокую задержку, что может повлиять на производительность сетевых приложений. *Постоянно высокие или резко изменяющиеся значения RTT могут свидетельствовать о проблемах со стабильностью сети, таких как нестабильные маршруты или перегруженные сетевые устройства*
#### Принцип работы
1. Удалённому узлу отправляется эхо-запрос протокола ICMP;
2. Если удалённый узел настроен надлежащим образом, то он отправит пакет с “Echo Reply” (Type=0) протокола ICMP
#### Полезные опции ping для ОС Linux и macOS
```ping [options] <remote_host>```
+ ```-c <N>```: остановиться после N пакетов
+ ```-s <N>```: отправлять пакеты размером N байт. Отправка очень больших пакетов (например, 65000 байт) может использоваться для тестирования, но также может вызвать проблемы, такие как фрагментация пакетов, нагрузка на сеть или на целевой узел, что может привести к потерям пакетов или другим проблемам. Многие сети и устройства могут блокировать или ограничивать размер пакетов, чтобы предотвратить атаки и перегрузки. Такие большие пакеты могут быть отброшены или ограничены
+ ```-t <N>```: установить значение поля TTL IP-пакета в N. Установив -t 1 можно получить IP-адрес шлюза, используемого по умолчанию, т.к. при значении TTL = 1 пакет будет отброшен ближайшим промежуточным узлом (то есть вашим шлюзом, используемым по умолчанию) с отправкой сообщения «Время истекло»
+ ```-A```: включает адаптивный режим, который автоматически завершает команду ping, если ответы становятся стабильными. Это может помочь предотвратить бесконечный пинг, если узел стабильно отвечает на запросы
+ `-q`: включает тихий режим. Показывает только итоговую статистику, не показывая каждое отдельное эхо-запрос.

#### Примеры
+ ```ping example.com```
+ ```ping -c 10 example.com``` (по умолчанию ```ping``` работает до нажатия клавиш Ctrl+C)
+ ```sudo ping -A -s 65000 192.168.100.1```
+ ```ping -t 1 example.com```

*вывод ping:*
```console
[user@host]$ ping -c 3 example.com
PING example.com (93.184.216.34): 56 data bytes
64 bytes from 93.184.216.34: icmp_seq=0 ttl=50 time=129.329 ms
64 bytes from 93.184.216.34: icmp_seq=1 ttl=50 time=128.532 ms
64 bytes from 93.184.216.34: icmp_seq=2 ttl=50 time=128.729 ms


--- example.com ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 128.532/128.863/129.329/0.339 ms
```
#### ВАЖНО
1. ```ping``` **не измеряет пропускную способность соединения (bandwitch)**. Могут быть соединения с низкой задержкой (т. е. параметром RTT) и одновременно с низкой пропускной способностью («скоростью»), а также с высоким RTT и высокой пропускной способностью.
2. ```ping``` **нельзя использовать для проверки доступности удалённого ПОРТА**. Это распространённая ошибка новичков: на вопрос «как вы будете проверять, открыт удалённый порт или нет?», некоторые отвечают «я буду использовать ping». В протоколе ICMP нет портов, и он не относится к протоколам TCP и UDP, поэтому его нельзя применить для такой проверки. Вместо этого используйте программы nc или nmap (о них поговорим позже).
3. **Протокол ICMP может быть заблокирован в настройках межсетевых экранов или серверов**. По этой причине не будет эхо-ответа даже от доступных корректно работающих узлов. Отсутствие эхо-ответа от удалённого узла может означать всего лишь работу межсетевого экрана.

*Примечание: Значения TTL в выводе ping — работающий способ приблизительно определить тип ОС удалённого узла*
### traceroute
**traceroute** — это сетевая утилита, показывающая маршрут, по которому пакеты проходят от исходного хоста до целевого узла в IP-сети, позволяя выявить узкие места, задержки или точки отказа в сети.

```traceroute [options] destination```
#### Алгоритм работы 
Программа отправляет пакеты с TTL = 1, TTL = 2…, пока не достигнет удалённого узла и не получит ожидаемый ответ. Все промежуточные узлы отклоняют пакеты, когда параметр TTL достигает нуля, а в каждом ответе этих узлов содержится их IP-адрес.
#### Функции
+ показывает все промежуточные узлы (маршрутизаторы), через которые проходят пакеты до достижения целевого хоста.
+ показывает время обратного хода (RTT) для каждого хопа, что позволяет оценить задержку на каждом этапе маршрута
+ помогает определить, на каком участке сети возникают задержки или потери пакетов
#### Опции
1. ```-U``` - в UNIX (Linux, macOS) ```traceroute``` по умолчанию применяет пакеты UDP (```traceroute -n yandex.ru``` = ```traceroute -n -U yandex.ru```), отправляемыми вовне на случайные порты серверов. Поэтому он часто блокируется межсетевыми экранами, и ```traceroute``` в таком случае не покажет некоторые промежуточные узлы, расположенные между вами и удалёнными узлами (```traceroute -n -U yandex.ru```).
2. ```-T``` - ```traceroute``` поддерживает протокол TCP. В Этом случае будут отправляться пакеты с флагом SYN
3. ```-I``` - использовать ICMP пакеты вместо UDP;
4. ```-p``` - указать порт вместо порта по умолчанию;
5. ```-g``` - передавать пакет через указанный шлюз;
6. ```-i``` - передавать пакет через указанный интерфейс;
7. ```-P``` - протокол, доступны такие значения: raw, dccp, udplite, udp, tcpconn, tcp, icmp
8. ```-n``` - указывает traceroute не преобразовывать IP-адреса в имена хостов. Это ускоряет выполнение команды, так как не требуется обратное разрешение DNS для каждого узла.
9. ```-m``` - задает максимальное количество переходов пакета до пункта назначения. По умолчанию максимальное значение TTL установлено на 30.

*Алгоритм работы ```traceroute``` не зависит от используемого протокола*

*```tracert``` (аналог ```traceroute``` в Windows) применяет только протокол ICMP*
+ ```tracert google.com``` - по умолчанию использует ICMP для отправки запросов;
+ ```tracert -h 5 google.com``` - Указание максимального количества прыжков (hops);
+ ```tracert -d google.com``` - не выполнять DNS-резолвинг IP-адресов в имена хостов, что ускоряет выполнение команды.
#### Примеры
+ ```traceroute -n yandex.ru```
+ ```traceroute -nI yandex.ru```
+ ```traceroute -nT yandex.ru```
+ ```traceroute -nU yandex.ru``` = ```traceroute -n yandex.ru```

*Пример вывода*
```console
traceroute to example.com (93.184.216.34), 30 hops max, 60 byte packets
 1  192.168.1.1 (192.168.1.1)  1.098 ms  1.045 ms  1.014 ms
 2  10.0.0.1 (10.0.0.1)  2.123 ms  2.096 ms  2.071 ms
 3  172.16.0.1 (172.16.0.1)  3.245 ms  3.221 ms  3.201 ms
 4  192.0.2.1 (192.0.2.1)  4.367 ms  4.344 ms  4.321 ms
 5  203.0.113.1 (203.0.113.1)  5.493 ms  5.470 ms  5.447 ms
 6  198.51.100.1 (198.51.100.1)  6.613 ms  6.589 ms  6.567 ms
 7  93.184.216.34 (93.184.216.34)  7.789 ms  7.766 ms  7.744 ms
```

*Примечание*
Пример иллюстрирует процесс прохождения пакетов через различные маршрутизаторы (hop) от вашего компьютера до сервера example.com. Каждый hop отображает IP-адрес и время задержки в миллисекундах (ms). каждое число времени задержки представляет собой отдельное измерение времени ответа для данного "hop". По умолчанию, ```traceroute``` (```tracert```) отправляет три пакета к каждому маршрутизатору на пути к конечной цели, поэтому отображаются три времени задержки. Использование трёх измерений времени помогает выявить нестабильность или изменения в задержках при передаче пакетов через маршрутизаторы. Например, если одно из значений сильно отличается от других.
### Проблемы с маршрутизацией и узлами, отключенными от сети
<!-- HTML для объединения ячеек -->
<table>
  <thead>
    <tr>
      <th>Текст ICMP-сообщения</th>
      <th>Причины</th>
    </tr>
  </thead>
  <tbody>
    <tr>
	  <td rowspan="3">"No route to host"</td>
	  <td>Это сообщение генерируется ОС узла-отправителя (в т.ч. маршрутизатора), когда в его таблице маршрутизации отсутствует соответствующий маршрут для доставки пакета к указанному IP-адресу. Сообщение "No route to host" в основном связано в ICMP с Тип 3 (Destination Unreachable) и кодом 0 (Network Unreachable). Причины:</td>
    </tr>
     <tr>
      <td>- нет ни одного правила в вашей таблице маршрутизации</td>
    </tr>
    <tr>
      <td>- в настройках узла не указан маршрутизатор, используемый по умолчанию</td>
    </tr>
    <tr>
      <td rowspan="4">"Destination host unreachable"</td>
      <td>Это сообщение генерируется маршрутизатором или шлюзом, когда они не могут доставить пакет до целевого узла (устройство достигло хоста назначения, но не может установить с ним соединение). Причины:</td>
    <tr>
      <td>- сетевые проблемы, такие как перегрузка сети, сбои оборудования или проблемы с кабелем</td>
    </tr>
    </tr>
    <tr>
      <td>- узел назначения не в сети (выключен, не подключен к сети или фильтруется межсетевым экраном)</td>
    </tr>
    <tr>
      <td>- протокол ICMP отключён на промежуточных межсетевых экранах или узле назначения</td>
    </tr>
  </tbody>
</table>

При необходимости проверить доступность узла при отключенном на промежуточных межсетевых экранах или на самом узле назначения протокола ICMP  (```ping``` возвращает «Destination host unreachable») достаточно удалённо проверить TCP или UDP порты узла с помощью:
+ ```nc -vz host_name №_порта``` или
+ ```traceroute -U -p №_порта host_name``` (однако, важно понимать, что ```traceroute``` и ```nc``` (```netcat```) имеют разные цели. nc проверяет доступность конкретного порта на целевом узле, пытаясь установить соединение, в то время как traceroute показывает маршрут пакетов и может использоваться для диагностики проблем с сетевой связью на каждом шаге маршрута)
### Проблемы с системой DNS
<table>
	<thead>
		<tr>
			<th>Текст сообщения</th>
			<th>Причины</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td rowspan="5">"Name or service not known"</td>
			<td>"Name or service not known" - не относится к ICMP-сообщениям. Это сообщение является ошибкой, генерируемой библиотеками разрешения имён (такими как gethostbyname или getaddrinfo) в операционных системах при попытке разрешить имя хоста или имя сервиса в IP-адрес (хотя и выводится после вызова ping, если не удалось разрешить имя). Причины:</td>
		</tr>
		<tr>
			<td>- доменное имя не существует</td>
		</tr>
		<tr>
			<td>- доменное имя существует, но у него нет IP-адреса (доменное имя зарегистрировали, но при не настроили доменную зону). Чтобы определить существование доменного имени можно использовать инструмент командной строки <code>whois</code> в ОС Linux /</td>
		</tr>
		<tr>
			<td>- на клиентском узле ошибка в настройке «DNS-резолвера» (следует проверить /etc/resolv.conf)</td>
		</tr>
		<tr>
			<td>- не работает «резолвер» (проверить можно с помощью публичных «резолверов»: <code>host badhostname.com 8.8.8.8</code> или <code>dig badhostname.com @8.8.8.8</code>)</td>
		</tr>
	</tbody>
</table>

*Примечание:*

[DNS-резолвер](#dns-server) (или DNS-клиент) — это компонент программного или аппаратного обеспечения, отвечающий за выполнение DNS-запросов. Его основная задача — преобразование человекочитаемых доменных имен в соответствующие IP-адреса и наоборот
### Потеря пакетов
#### Признаки
+ слишком медленное соединение;
+ передача данных застопорилась;
+ имеют место неожиданные сбросы соединения TCP.
#### Причина
Перегрузка интерфейса одного из узлов (включая шлюзы) или проблемы с физическим каналом. 
#### Диагностика
1. Выполните проверку связи с удалённым узлом с помощью пакетов размером примерно 1 КБ и опции "-s" (Использование маленького размера пакета (1 байт) может быть полезным для минимизации влияния самой команды ping на сеть, что иногда важно для высоконагруженных сетей или для получения более точных измерений времени задержки без учета дополнительной нагрузки) и посмотрите статистику. Если доля потерянных пакетов (packet loss при выводе с помощью ping) > 5 %, то дело может быть в потере пакетов: ```ping -s 1 example.com```. По умолчанию команда ```ping``` использует размер полезной нагрузки ICMP Echo Request пакета, равный 56 байтам. При добавлении заголовка ICMP (8 байт) это составляет общий размер 64 байта.
2. Создайте файл PCAP с образцом потока пакетов между клиентом и удалёнными узлами, используя программу [```tcpdump```](#tcpdump) с фильтрами для узлов и портов. Если есть такая возможность, выполните то же самое на узле назначения. Откройте сохранённый файл в программе Wireshark и поищите красные и (или) чёрные метки. *Красный цвет обычно обозначает критические ошибки или сбои. Это могут быть пакеты с ошибками, такие как неправильные контрольные суммы, повреждённые данные или др.*. Чёрный цвет часто указывает на менее критичные проблемы или предупреждения. Эти сообщения могут быть полезными для диагностики, но они не обязательно указывают на серьёзные сбои, например, сообщения о проблемах с производительностью "Slow Acknowledgment"
## Проблемы на транспортном уровне
+ Для удалённой проверки (при отсутствии доступа к интересующему узлу по протоколу ```SSH```) использовать утилиты: ```nc``` и ``nmap``
+ Для локальной проверки открытых портов (при наличии доступа к интересующему узлу посредством протокола ```SSH```) использовать программы [netstat](#netstatdetail) или ```ss```. Продвинутые пользователи ОС Linux могут также использовать программу lsof (если она установлена).
### nc <a id="nc"></a>
+ **nc** - инструмент для чтения и записи данных через сетевые соединения с использованием протоколов TCP или UDP
+ в сетевом администрировании и тестировании применяется для диагностики на транспортном и прикладном уровне стека TCP/IP *(т.к. при поиске неисправностей некоторые реализации ```nc``` не очень хорошо работают с UDP, поэтому в этом случае рекомендуют применять ```nmap```)*
+ не предназначен (в отличие от [cURL](#curl)) для работы с HTTP/HTTPS и не предоставляет  функций поддержки куки, редиректов, сжатия и аутентификации, необходимых для работы с веб-протоколами.
#### nc: простое соединение с сервером
```console
nc [хост] [порт]
```
#### nc: прослушивание на порту 1234
```console
nc -l -p 1234
```
#### nc: отправка файла через TCP
```console
# На принимающей стороне:
nc -l -p 1234 > received_file.txt
```
```console
# На отправляющей стороне:
nc [хост] 1234 < file_to_send.txt
```
#### nc: простая обратная оболочка (на удаленной машине):
```console
# На принимающей стороне:
nc -l -p 1234 -e /bin/bash
```
```console
# На соединяющейся стороне:
nc [хост] 1234
```
#### nc: проверить только один порт
```console
# -v - для получения подробного вывода (т.е. будут показаны и неудачные попытки)
# -z - для проверки доступности порта
nc -vz server_address port
```
#### nc: проверить диапазон портов
```console
nc -z server_address 1000-2000
```
### nmap		
nmap - сетевой сканер. Его задача:
+ находить сетевые узлы;
+ сканировать открытые порты с целью сбора информации о сети (это часто делается непосредственно перед атакой);
+ определять работающие на этих портах службы.

#### Сканирование портов TCP с установкой соединения
Сканирование портов TCP в диапазоне от A до B на определённом узле, аналогично программе nc (т.е. с установкой соединения TCP посредством «рукопожатия»). Опция -sT означает режим сканирования — «рукопожатие TCP»		
```console
nmap -sT -pA-B адрес_узла
```
#### Сканирование портов TCP без установки соединения
То же самое, но намного быстрее (посредством отправки только пакетов TCP SYN, без установки соединения), требуются права пользователя root. -sS означает режим сканирования — SYN:
```console
sudo nmap -sS -pA-B адрес_узла
```
#### Сканирование портов UDP 
-sU означает режим сканирования — UDP. Нужны права root. Эта операция намного медленнее, даже чем режим с опцией -sT:
```console
sudo nmap -sU -pA-B адрес_узла
```
#### Поиск доступных в сети узлов
-sP означает режим сканирования — ping (хотя, на самое деле, сам ping для сканирования используется не всегда, в локальных сетях вместо этого применяется протокол ARP):
```console
nmap -sP адрес_сети/маска
```
#### Узнать, какие порты фильтруются фаерволом, а какие нет
ACK сканирование отправляет TCP-пакеты с установленным флагом ACK (Acknowledgement) на указанные порты целевого узла. Если узел отвечает пакетом TCP RST, это означает, что порт не фильтруется (т.е. он открыт или закрыт, но не фильтруется фаерволом). Если узел не отвечает на пакет ACK, это обычно означает, что порт фильтруется (т.е. фаервол блокирует попытки установить соединение на этом порту):
```console
nmap -sA -p 80,443 192.168.1.1
```
#### Отключение предварительного пингования портов при сканировании портов заданного узла:
```console
nmap -Pn -sT -p22,9099,10000 адрес_узла 
```
```-Pn``` (No Ping) - отключает этап пинга перед сканированием портов. Nmap по умолчанию пытается определить, активен ли целевой узел, отправляя пинг (ICMP echo request) и другие типы запросов. Если узел не отвечает на пинг, Nmap предполагает, что он недоступен, и завершает сканирование. Параметр -Pn указывает Nmap не выполнять этот предварительный шаг и продолжать сканирование портов, даже если узел не отвечает на пинг:
+ полезно, если целевой хост блокирует ICMP или другие пакеты обнаружения. 
+ делает сканирование более медленным, так как Nmap будет пытаться соединиться с каждым портом без предварительной проверки доступности узла, и в случае, если узел недоступен - приведет к длительным таймаутам
+ увеличивает вероятность обнаружения сканирования системой обнаружения вторжений (IDS), так как посылается большое количество TCP-запросов без предварительного ICMP-пинга, что может быть воспринято как подозрительная активность

*Пример вывода:*
```console
[st00@c7-sandbox ~]$ nmap -sT -p9000-9100 192.168.40.150
Starting Nmap 6.40 ( http://nmap.org ) at 2022-08-01 00:42 MSK
Nmap scan report for 192.168.40.150
Host is up (0.029s latency).
Not shown: 86 closed ports
PORT STATE SERVICE
9000/tcp open cslistener
9011/tcp open unknown
...
9031/tcp open unknown
Nmap done: 1 IP address (1 host up) scanned in 0.14 seconds
```

```nmap``` выводит: номер порта (PORT), его состояние (STATE) и службу, его слушающую (SERVICE)

#### Список состояний просканированных Nmap портов:
+ open - доступен для клиентов, не заблокирован межсетевым экраном, прослушивается неким приложением на серверной стороне;
+ closed - доступен для клиентов и не заблокирован межсетевым экраном, не прослушивается ни одним приложением;
+ filtered - заблокирован межсетевым экраном, все пакеты, отправленные на этот порт, были отброшены. Неизвестно, прослушивается ли этот порт каким-либо приложением;
+ unfiltered - возможно только при TCP-сканировании и означает, что порт доступен, но Nmap не может определить, открыт он или закрыт. Этот статус может возникнуть при некоторых типах сканирования, таких как ACK scan, который в отличие от SYN scan, не определяет, открыт ли порт, а выявляет, какие порты фильтруются фаерволом. Этот метод используется для обхода некоторых типов фильтров и получения информации о настройках сети. Принцип работы ACK scan: на указанные порты целевого узла отправляются TCP-пакеты с флагом ACK (Acknowledgement). Если узел отвечает TCP-пакетом RST, это означает, что порт не фильтруется (т.е. он открыт или закрыт, но не фильтруется фаерволом. Если узел не отвечает на пакет ACK, это обычно означает, что порт фильтруется);
+ open|filtered - Nmap не может определить, открыт порт или фильтрован. Это может случиться, если пакет не возвращает явного ответа. Такое состояние часто возникает при UDP-сканировании (если порт открыт или закрыт, но отключен ICMP-протокол);
+ closed|filtered - Nmap не может определить, закрыт порт или фильтрован. Такое состояние может появиться при сканировании IP ID
### Реакция порта на запрос
#### Порт открыт и доступен
```console
[st00@c7-backend ~]$ nc -vz 127.0.0.1 22
Connection to 127.0.0.1 22 port [tcp/ssh] succeeded!
```
#### Connection refused
Ошибка “Connection refused” ("в подключении отказано") обычно возникает при попытке соединения с закрытым портом и формируется на уровне TCP/IP стека операционной системы (вне зависимости от того, какая команда используется - nc, telnet, [curl](#curl), ssh и т. д.). Причины:	
+ остановка сетевого приложения на удаленном сервере, которое должно было прослушивать порт назначения
+ указание неверного порта (порт "неверный" в том смысле, что на нем нет ожидаемого сервиса)
+ работа межсетевого экрана

```console
[st00@c7-backend ~]$ nc -vz 127.0.0.1 23
nc: connect to 127.0.0.1 port 23 (tcp) failed: Connection refused
```

*Протокол TCP:* Если настроить сниффер во время выполнения команды ```nc -vz адрес_узла #порта```, ```sudo nmap -sS -pA-B адрес_узла``` или ```nmap -sT -pA-B адрес_узла```, то при ошибке "Connection refused" в сетевом потоке также будет пакет RST

*Протокол UDP:* Сообщение "Connection refused" выдается только для TCP сканирования и указывает на то, что на целевом порте нет приложения, которое слушает соединения. Это сообщение не используется в контексте UDP сканирования, поскольку UDP — это протокол без установки соединения, и закрытие порта обычно определяется через ICMP сообщения, а не через отказ в соединении. Если настроить сниффер во время выполнения команды ```sudo nmap -sU -pA-B адрес_узла```, то хотя при протоколе UDP механизм сообщения о закрытых портах не предусмотрен (пакет с установленным флагом RST, как для TCP-запроса, в ответ не шлется), но, как сказано в стандарте протокола ICMP может (но обязательно) от удалённой ОС быть получено сообщение ICMP "Destination Unreachable" с кодом "Port Unreachable" и в этом случае это указывает на то, что порт закрыт и не прослушивается ни одним приложением, что и выдаст nmap, интерпретировав это как указание на то, что порт закрыт (closed)
#### Connection timeout
```Connection timeout``` (как и ```Connection refused```) является стандартным сообщением, которое выводят различные команды при неудачной попытке установить соединение с удаленным сервером. Независимо от того, какая команда используется (nc, telnet, [curl](#curl), ssh и т.д.), если удаленный узел недостижим в течение определенного времени (тайм-аут), вы получите сообщение ```Connection timeout```. Узел недостижим, если: 
+ физически или логически отключен от сети 
+ узел физически подключен к сети, но нет маршрута к узлу из-за проблем в маршрутизации;
+ пакеты заблокированы межсетевыми экранами или системами предотвращения вторжений (IPS) для конкретного источника или типа трафика;
+ проблемы в сети - обрывы кабелей, проблемы на маршрутизаторах и т.д. 
```console
[st00@c7-backend ~]$ time nc -vz 87.250.250.242 22
nc: connect to 87.250.250.242 port 22 (tcp) failed: Connection timed out

real    2m7.336s
user    0m0.003s
sys     0m0.005s
```
*Команда ```time``` добавляет информацию о времени выполнения команды, но не изменяет её поведение. Сообщение ```Connection timed out``` появилось бы в любом случае, если соединение не удалось установить из-за тайм-аута*

Чтобы уточнить причину ```Connection timeout``` нужно:
1. Определить, находится ли этот удалённый узел в сети с помощью других способов, например следующих:
   1. ```ping``` / ```traceroute``` с использованием протокола ICMP.
   2. ```nc -z``` с использованием других (возможно, открытых) портов.
   3. ```nmap``` со сканированием диапазона портов (только если у вас есть на это разрешение).
2. Если узел обнаружен в сети, но не отвечает на определённые запросы и вы получаете сообщения об ошибке «Connection timeout», значит, этот порт и (или) протокол блокируются межсетевым экраном.

*Примечание*
Сообщение ```Connection timeout``` ассоциируется с TCP (UDP не имеет встроенного механизма таймаута, так как это протокол без установления соединения). Но таймауты также могут возникать и при UDP сканировании. ```nmap``` интерпретирует отсутствие ответа (таймаут) для обоих протоколов (TCP и UDP) и использует это для определения состояния порта, выводя соответствующие состояния, такие как ```open|filtered``` для UDP (но это же сообщение будет, если порт закрыт, но сообщения ICMP отключены) и ```filtered``` для TCP.

#### Address already in use
При запуске приложения, работающего с портом X, который уже используется другим приложением, вы получите ошибку «Address already in use» (адрес уже используется). При обнаружении этой ошибки (в журнале приложения или в выводе команды) список открытых портов необходимо проверить с помощью программы ```netstat``` или ```ss``` локально. Пример:
```console
[st00@c7-sandbox ~]$ nc -l 15672
nc: Address already in use

[st00@c7-sandbox ~]$ netstat -ntl | egrep :15672
tcp        0      0 0.0.0.0:15672           0.0.0.0:*               LISTEN
```

*Примечание*
 1. При наличии прав администратора root выполнить ```netstat -nptl``` (добавили опцию -p) для получения информации про процесс, использующий в текущий момент этот порт.
2. ```nc -l №_порта``` - запуск программы ```nc``` в режиме сервера, прослушивающего TCP-порт, а ```nc -u -l №_порта``` - в режиме сервера, прослушивающего UDP-порт
#### Permission denied
В UNIX открытие портов TCP и UDP с номерами меньше 1024 разрешено только пользователю root. Если процесс, запущенный от имени простого пользователя, попытается открыть один из таких портов, то получит ошибку «Permission denied»
## Проблемы прикладного уровня
Здесь речь не о логических дефектах, а о том, что у похожих программных продуктов могут быть отличающиеся реализации протоколов прикладного уровня (HTTP в том числе). 

*Например, в официальном описании протокола HTTP говорится следующее:*
+ *Каждая строка в запросе клиента должна заканчиваться символами CRLF.*
+ *Но лучше, если серверное приложение также сможет работать и с одним символом LF на конце строки.*
## Основы работы межсетевых экранов
Межсетевой экран — это программное обеспечение или сетевое устройство, блокирующее или пропускающее определённые сетевые пакеты согласно настроенным правилам.
### Состояния и правила межсетевых экранов
+ **Отключён**. Часто встречается на клиентских компьютерах. Например, на узлах, работающих на ОС Windows, могут присутствовать отключённые межсетевые экраны.
+ **"Allow All" ("Allow by Default")**. Включён с правилами по умолчанию, означающими разрешение всего трафика и блокировку только явно указанного. Такую конфигурацию часто можно встретить на клиентских узлах, серверах и сетевом оборудовании во внутренних сетях компаний.
+ **"Deny All" ("Deny by Default")**. Включён с правилами по умолчанию, означающими блокировку всего трафика и разрешение только явно указанных пакетов. Такая конфигурация типична для корпоративного окружения, которому характерны высокие требования к безопасности, и для серверов, доступных из глобальной сети Интернет, которым нужна защита от атак злоумышленников.

![Варианты межсетевых экранов, сконфигурированных на клиентских компьютерах, серверах и сетевых устройствах](resources/lot-of-firewalls-to-publish.drawio.png)

Варианты межсетевых экранов, сконфигурированных на клиентских компьютерах, серверах и сетевых устройствах

### Элементы типичного правила межсетевого экрана
+ Описание пакетов, в которое могут входить следующие сведения:
  + IP-адрес(а) назначения и (или) источника.
  + протокол транспортного уровня.
  + номер(а) порта(ов) назначения и (или) источника.
  + сетевой интерфейс, используемый в ходе этого сетевого взаимодействия.
+ Действия для этих пакетов, например, следующие:
  + Блокировать (**block**) (также могут использоваться термины: отбросить (**drop**), запретить (**deny**) и т. п.). Соответствующие пакеты молча отбрасываются так, что ни клиент, ни сервер не узнают о блокировке.
    + Когда межсетевой экран применяет правило "block" к определенному трафику, он просто отбрасывает этот трафик, не предоставляя ответа отправителю.
    + Для отправителя это может выглядеть так, как если целевой хост не отвечает на запрос или как недостижимость хоста. Он не получит подтверждения доставки пакета.
    + В случае TCP/UDP-соединения это может привести к тому, что отправитель будет ждать ответа (Connection timeout) и попытается повторно отправить пакеты или завершить соединение.
  + Разрешить (**allow**) (также могут использоваться термины: принимать (**accept**), пропустить (**pass**) и т. п.).
  + В некоторых случаях: выполнить ещё что-либо, согласно функциям межсетевого экрана. Например, в межсетевом экране ОС Linux предусмотрено также действие **REJECT** (отклонить), означающее отбрасывание входящих пакетов и имитацию закрытого порта назначения.
    + Когда применяется правило "reject", межсетевой экран отправляет ICMP сообщение о недоступности порта или хоста обратно к отправителю.
    + Для отправителя это выглядит как явное сообщение о том, что порт или хост недоступен, и отправитель получит это сообщение в качестве ответа на свой запрос.
    + В случае TCP/UDP-соединений, это сообщение может содержать информацию, указывающую на то, что порт закрыт (ICMP сообщение типа 3, код 3 - Port Unreachable).

![Пример правил межсетевого экрана, применяемых к входящему трафику](resources/14_2.png)

Расшифровка примера. Каждая строка расшифровки соответствует строке на рисунке с соответствующим номером в колонке num:
1. Разрешено всё приходящее на интерфейс lo (вспомните предыдущие главы — lo означает loopback, т е. механизм «обратной петли», с адресом 127.0.0.1). Это необходимо некоторым управляющим приложениям, которые работают на этом сервере.
2. Разрешены пакеты, идущие на порт TCP 22 от любых отправителей и получателей.
3. Разрешены пакеты с а) состоянием RELATED (связанный), т. е. это ответы SYN-ACK от удалённых серверов - это "почти что" установленное соединение, или б) состоянием ESTABLISHED (установлено), т. е. это пакеты установленного соединения.
4. Разрешены пакеты, идущие на порты TCP с номерами между 9000 и 9100.
5. Разрешены все пакеты из сети 192.168.40.0/24.
6. Разрешены пакеты протокола ICMP от любых отправителей и получателей.
7. Пакеты TCP на порты 111, 4369, 15672, 25672 разрешены, если IP-адрес получателя — 192.168.40.14.

Все остальные пакеты блокируются, как указано в первой строке вывода: «policy DROP» (запрещающая политика). *Конфигурация межсетевого экрана, показанная в этом примере, характерна для корпоративных серверов и серверов Интернета.*
### Другие способы обнаружения межсетевого экрана (кроме Nmap)
### nc как способ обнаружения межсетевого экрана
[nc](#nc)
### tcpdump как способ обнаружения межсетевого экрана
tcpdump. Если в вашем рабочем окружении нет возможности использовать nc или nmap, то могут помочь анализаторы сетевых пакетов, наподобие tcpdump. В примере ниже мы видим серию пакетов TCP SYN (отмеченных буквой «S», означающей флаг SYN), отправленных на удалённый сервер от клиента 192.168.40.100 во время показанного выше запуска программы nc, но ответов сервера не наблюдается. Это может означать, что этот порт скрыт за межсетевым экраном (но предварительно надо убедиться с помощью ping или nc, например, что узел доступен).
```console
[st00@c7-backend ~]$ tcpdump -vnn -ttt -i eth0 tcp and port 22
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
 00:00:00.000000 IP (tos 0x0, ttl 64, id 60589, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xd6ea), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297328130 ecr 0,nop,wscale 7], length 0
 00:00:01.001736 IP (tos 0x0, ttl 64, id 60590, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xd300), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297329132 ecr 0,nop,wscale 7], length 0
 00:00:02.003947 IP (tos 0x0, ttl 64, id 60591, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xcb2c), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297331136 ecr 0,nop,wscale 7], length 0
 00:00:06.084977 IP (tos 0x0, ttl 64, id 48874, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42340 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xa0dc), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297337221 ecr 0,nop,wscale 7], length 0
 00:00:01.003010 IP (tos 0x0, ttl 64, id 48875, offset 0, flags [DF], proto TCP (6), length 60)
[ ... more similar packets below ... ]
```
### traceroute как способ обнаружения межсетевого экрана
1. Сначала нужно определить маршрут между узлами клиента и сервера, используя любой протокол (ICMP, TCP,UDP), принимаемый сервером и не блокируемый межсетевым экраном
```console
[st00@c7-backend ~]$ traceroute -nI 5.255.255.242
traceroute to 5.255.255.242 (5.255.255.242), 30 hops max, 60 byte packets
 1  192.168.40.2  0.213 ms  0.203 ms  0.196 ms
 2  5.200.37.73  0.300 ms  0.315 ms  0.313 ms
 3  81.27.241.116  0.676 ms  0.738 ms  0.736 ms
 4  * * *
 5  81.27.254.74  12.071 ms  12.079 ms  12.078 ms
 6  * * *
 7  5.255.255.242  12.215 ms  12.194 ms  12.169 ms
```
2. Теперь нужно определить маршрут, используя именно те протокол и порт, которые нас интересуют (например, TCP и 22).
```console
[st00@c7-backend ~]$ traceroute -n -T -p 22 5.255.255.242
traceroute to 5.255.255.242 (5.255.255.242), 30 hops max, 60 byte packets
 1  192.168.40.2  0.155 ms  0.108 ms  0.060 ms
 2  5.200.37.73  0.367 ms  0.323 ms  0.288 ms
 3  81.27.241.116  0.775 ms  0.741 ms  0.711 ms
 4  * * *
 5  81.27.254.74  9.475 ms  8.185 ms  8.152 ms
 6  93.158.172.23  18.989 ms 93.158.160.113  28.479 ms 93.158.160.151  26.504 ms
 7  * * *
 8  * * *
[ ... all lines below are * * * ... ]
```
+ сравним два варианта и поразмыслим логически:
1. Пакеты для порта TCP 22 передаются успешно на шагах от 1 до 6.
2. Согласно маршрута, построенного с помощью ICMP, сервером назначения должен быть 7-й узел.
3. Если программа ```traceroute``` непрерывно показывает символы «* * *» до остановки своей работы, значит, пакеты где-то блокируются межсетевым экраном.
4. Во время второй ничего не видно, начиная с 7-го промежуточного узла.
5. Поэтому наиболее вероятно, что ограничительные правила межсетевого экрана установлены на узле № 7 (узел назначения 5.255.255.242).

# 15 HTTP, URL, JSON, API
## HTTP
### Уровень модели OSI:
HTTP (HyperText Transfer Protocol): работает на прикладном уровне (седьмой уровень модели OSI). HTTP определяет, как данные формируются, отправляются и принимаются между клиентом и сервером. Он описывает синтаксис и семантику запросов и ответов, но полагается на транспортные протоколы, такие как TCP, для фактической передачи данных.
### Назначение и функции:
Основная задача HTTP — предоставление средств для взаимодействия с ресурсами в интернете, такими как веб-страницы, API и другие типы данных. HTTP определяет методы, такие как GET, POST, PUT, DELETE и другие, для выполнения различных операций над ресурсами. HTTP также определяет формат сообщений, заголовки и коды статуса для общения между клиентом и сервером.
### Область применения:
Используется преимущественно для взаимодействия с веб-серверами и предоставления доступа к ресурсам в интернете, включая веб-страницы, API и другие веб-сервисы.

Сейчас широко используются:
+ HTTP/1.1
+ HTTPS
+ HTTP/2
+ HTTP/3
### HTTP/1.1
+ Год выпуска: 1997
+ Характеристики:
  + HTTP-сообщение отправляется открытым текстом, передаваемая информация может быть легко перехвачена и расшифрована.
  + Поддерживает постоянные соединения (keep-alive), что позволяет использовать одно соединение для передачи нескольких запросов и ответов.
  + Ограничение на количество одновременных соединений с одним сервером (обычно 6-8).
  + Серверы не могут инициировать передачу данных без запроса клиента (односторонняя связь).
  + Заголовки передаются в виде текста, что может привести к избыточности и большим объемам данных.
  + Порт по умолчанию: 80
### HTTPS
+ Год выпуска: 1994
+ Характеристики:
  + HTTPS — это расширение HTTP, использующее SSL/TLS для шифрования данных.
  + Обеспечивает защиту передаваемых данных от перехвата и подделки.
  + Поддерживается всеми версиями HTTP (HTTP/1.1, HTTP/2, HTTP/3).
  + Включает механизмы аутентификации сервера (подробнее см. ниже) и иногда клиента (сервер в HTTPS-соединении может аутентифицировать клиентов различными способами, включая использование клиентских сертификатов, учетных данных и токенов доступа).
  + Использование HTTPS обязательно для защиты чувствительных данных и рекомендуется для всех веб-сайтов.
  + Порт по умолчанию: 443
### HTTP/2
+ Год выпуска: 2015
+ Характеристики:
  + Использование бинарного протокола позволило улучшить производительность и снизить задержки по сравнению с текстовым HTTP/1.1 за счет:
    + Мультиплексирования: позволяет отправлять несколько запросов и получать несколько ответов одновременно по одному TCP-соединению.
    + Сжатия заголовков: заголовки сжимаются, уменьшая объем передаваемых данных.
    + Server Push: Сервер может инициировать передачу данных, что позволяет отправлять данные клиенту до того, как он их запросит (добавлена вместо сокета новая сущность "логические потоки", через которую сервер инициирует Server Push).
  + Хотя протокол может работать и без шифрования на порту 80, основное применение HTTP/2 происходит через HTTPS на порту 443, обеспечивая таким образом безопасное шифрование данных с использованием TLS. В большинстве современных браузеров и серверов HTTP/2 автоматически включается при установке HTTPS-соединения.
#### Алгоритм работы HTTP/2 Server Push
1. Инициирование соединения: Клиент устанавливает соединение с сервером с использованием HTTP/2.
2. Запрос ресурса: Клиент запрашивает определенный ресурс, например HTML-страницу.
3. Анализ запроса сервером: Сервер анализирует запрошенный ресурс и определяет, какие дополнительные ресурсы могут понадобиться клиенту для корректного отображения страницы (например, CSS, JavaScript, изображения).
4. Отправка Pushed ресурса:
   1. Сервер создает поток для каждого ресурса, который он хочет отправить клиенту.
   2. Сервер посылает клиенту заголовок PUSH_PROMISE, который сообщает клиенту, что сервер собирается отправить дополнительные ресурсы.
   3. PUSH_PROMISE содержит заголовки, описывающие будущий ресурс, так что клиент может понять, что он получит, и, возможно, избежать дублирования запросов на те же ресурсы.
5. Получение PUSH_PROMISE клиентом: Клиент получает заголовок PUSH_PROMISE и может решить, принимать ли ресурс. Если клиент уже обладает данным ресурсом (например, из кэша), он может отклонить его, отправив серверу RST_STREAM для соответствующего потока.
6. Отправка ресурса сервером: Если клиент не отклонил PUSH_PROMISE, сервер начинает отправку ресурса по соответствующему потоку.
7. Использование ресурса клиентом: Клиент получает ресурс и может использовать его для отображения запрошенной страницы.
#### Пример работы Server Push
Рассмотрим пример, когда клиент запрашивает страницу index.html, и сервер решает отправить также style.css и script.js.
1. Клиент: запрашивает index.html.
2. Сервер:
   1. Отправляет заголовок PUSH_PROMISE для style.css.
   2. Отправляет заголовок PUSH_PROMISE для script.js.
   3. Отправляет index.html.
   4. Отправляет содержимое style.css.
   5. Отправляет содержимое script.js.
#### Преимущества и Недостатки Server Push
1. Преимущества:
   1. Сокращение времени загрузки: Клиент получает необходимые ресурсы заранее, что позволяет быстрее отобразить страницу.
   2. Уменьшение числа запросов: Устраняется необходимость в дополнительных запросах от клиента, снижая накладные расходы.
2. Недостатки:
   1. Сложность реализации: Настройка и управление Server Push требует точной конфигурации и понимания запросов клиента.
   2. Риск избыточной передачи данных: Если сервер отправляет ресурсы, которые клиент уже имеет в кэше, это может привести к избыточной передаче данных.
### HTTP/3
+ Год выпуска: 2020 (экспериментальная реализация), 2022 (RFC 9114)
+ Характеристики:
  + Основан на протоколе [QUIC](#quic) - современном транспортном протоколе, работающем поверх UDP и разработанном Google для замены или дополнения традиционного TCP, обеспечив более быструю и надежную передачу данных в интернете. Он обладает рядом улучшений по сравнению с TCP, особенно в контексте использования с протоколом HTTP/3
  + Порт по умолчанию: 443
### Основные особенности гипертекстовых протоколов
+ HTTP/1.1: Стандартный, простой в реализации, но ограничен в производительности из-за последовательной передачи данных.
+ HTTP/2: Улучшенная производительность за счет мультиплексирования и сжатия заголовков, позволяет быстрее загружать веб-страницы.
+ HTTP/3: Еще более быстрая и эффективная передача данных благодаря использованию QUIC и работы поверх UDP, лучше подходит для современных сетей с высокой задержкой.
+ HTTPS: Обеспечивает безопасность передачи данных, защищает от атак типа "человек посередине" (MITM) и обеспечивает конфиденциальность и целостность данных (ВНИМАНИЕ!!! В большинстве современных браузеров и серверов при установке HTTPS-соединения автоматически включается HTTP/2).
### Stateless protocol
HTTP/1.1, HTTP/2, HTTP/3 и HTTPS - протоколы без состояния (stateless protocol). С точки зрения сервера, каждый новый запрос как будто поступает от совершенно нового клиента (сервер не помнит, что вы только что были на предыдущей странице или авторизовались). Чтобы обеспечить и согласованность запросов, используются:
+ Cookies (куки): Маленькие файлы, которые сервер отправляет браузеру клиента, и которые затем отправляются обратно серверу с каждым последующим запросом. Таким образом, сервер может "узнавать" клиента и отслеживать его действия. Они доступны для чтения и записи только веб-сайтам, которые установили эти куки. Местоположение файлов куков зависит от операционной системы и браузера:
  + В Windows: обычно в папке ```%APPDATA%\Roaming\<BrowserName>\Cookies```.
  + В macOS: в папке ```~/Library/Application Support/<BrowserName>/Cookies```.
  + В Linux: в папке ```~/.config/<BrowserName>/Cookies```.
+ Сессии (sessions): Сервер может создавать уникальные идентификаторы сессий для каждого пользователя, которые сохраняются в куки или в URL. Эти идентификаторы позволяют серверу связывать текущий запрос с предыдущими запросами от того же клиента.
+ Заголовки HTTP (HTTP headers): В HTTP-заголовках могут передаваться дополнительные данные, которые помогают серверу идентифицировать и отслеживать клиента. Например, заголовок ```Authorization``` может содержать токен, который сервер использует для проверки прав доступа клиента.
### Шифрование при передаче данных
Для шифрования информации, передаваемой по протоколу HTTPS, на сервере должен быть установлен так называемый сертификат SSL (Secure Sockets Layer) или TLS (Transport Layer Security, улучшенная версия SSL). Сертификат SSL/TLS состоит из двух частей: открытого ключа, используемого для шифрования данных, и закрытого ключа, используемого для их расшифровки, который доступен и известен только владельцу сайта и хранится на сервере в защищенном месте. Генерацией данной пары ключей занимается центр сертификации (CA), которому необходимо отправить запрос на подписание сертификата (CSR), сообщив о назначении вашего сайта, названии организации и т.д. Запрос имеет специальный формат и может быть автоматически сгенерирован специальными программами.
#### Процедура обмена данными по HTTPS
1. *Инициация соединения и TLS/SSL Handshake (рукопожатие):* Клиент отправляет запрос на сервер для установления соединения по HTTPS, обычно указывая URL, начинающийся с "https://".
   1. *Client Hello*: Клиент отправляет запрос на сервер для установления соединения по HTTPS, указывая URL, начинающийся с "https://". В рамках этого запроса клиент отправляет сообщение "Client Hello", содержащее:
      1. Версию протокола TLS/SSL, которую поддерживает клиент.
      2. Список шифров (алгоритмов шифрования), поддерживаемых клиентом.
      3. Случайное число (random number), которое будет использоваться для создания сессионного ключа.
   2. *Server Hello*: Сервер отвечает сообщением "Server Hello", содержащее:
      1. Выбранную версию протокола TLS/SSL.
      2. Выбранный шифр из списка, предложенного клиентом.
      3. Случайное число от сервера.
2. *Аутентификация и передача сертификата*
   1. *Сертификат сервера*: Сервер отправляет свой цифровой сертификат, выданный доверенным центром сертификации (CA). Этот сертификат содержит:
      1. Публичный ключ сервера.
      2. Информацию о сервере и о центре сертификации.
      3. Подпись центра сертификации, подтверждающую подлинность сертификата.
   2. *Проверка сертификата*: Клиент проверяет сертификат сервера, чтобы убедиться, что он:
      1. Выдан доверенным центром сертификации.
      2. Не просрочен и не отозван.
      3. Соответствует имени сервера (имя хоста в URL).
3. *Генерация сессионного ключа*
   1. *Client Key Exchange*: Клиент создает премастер-секрет (pre-master secret), шифрует его публичным ключом сервера и отправляет на сервер. Только сервер может расшифровать этот премастер-секрет своим приватным ключом.
   2. *Создание мастер-секрета*: Клиент и сервер используют премастер-секрет и случайные числа, обменянные ранее, для создания мастер-секрета. Мастер-секрет используется для генерации сессионных ключей, которые будут использоваться для симметричного шифрования данных.
4. *Завершение рукопожатия*
   1. *Client Finished*: Клиент отправляет сообщение "Finished", зашифрованное сессионным ключом. Это сообщение содержит хэш всех предыдущих сообщений рукопожатия, чтобы сервер мог подтвердить целостность процесса.
   2. *Server Finished*: Сервер отвечает аналогичным образом, отправляя сообщение "Finished", также зашифрованное сессионным ключом.
5. *Передача данных*: После успешного завершения рукопожатия клиент и сервер начинают передавать данные по зашифрованному каналу, используя симметричное шифрование с сессионными ключами.
## URL, URN, URI
URI (Uniform Resource Identifier): Общий термин, который используется для обозначения идентификатора ресурса. Он может быть либо URL, либо URN.
1. URL (Uniform Resource Locator): Специфический тип URI, который используется для обозначения адреса ресурса в Интернете и содержит информацию о том, как этот ресурс можно получить (например, через HTTP, HTTPS, FTP и т.д.).
2. Термин URN (Uniform Resource Name) - это уникальная идентификация ресурса в определенном пространстве (книги, RFC и т.д.), в специальном пространстве, начинающемся с urn: ```urn:ietf:rfc:7230``` (серверы реализуют mapping между представлением URN и URL)
### Структура URL
<img src="resources/url_NOPROCESS1_.png" alt="Структура URL" width="70%"/>

1. Протокол (protocol) - набор правил, которые необходимо использовать для доступа к ресурсу. Это может быть:
   1. HTTP
   2. HTTPS
   3. FTP и другие
2. Хост (host) - Адрес сервера - www.nexus.oy...- - это как строка "город-улица-здание" в физическом адресе. Он может быть представлен в виде:
   1. слов, разделенных точками (например, mentorpiece.education или nexus.oy.defects.tst) - каждое слово является уровнем домена
   2. цифр, разделенные точками, в данном случае это IP-адрес (например, 192.168.40.100/)
   3. localhost (означает локальный компьютер, IP-адрес по умолчанию - 127.0.0.1)
3. Порт (port)- Целевое приложение "слушает" этот порт и обрабатывает соответствующие запросы - 8079 - это как номер квартиры внутри здания
   1. Порт по умолчанию для протокола HTTP - 80
   2. Порт по умолчанию для протокола HTTPS - 443
   3. Порт по умолчанию для протокола FTP - 21
   4. Порт по умолчанию для почтового протокола (SMTP)  - 587
4. Путь (path)- путь к ресурсу - /service/rest/v1/search - рассматривайте его как путь к комнате внутри этой квартиры.
5. Параметры (parameters) - некоторые значения для модификации запроса - ?sort=version и ?direction=desc - воспринимайте это как вопрос типа "Есть ли у вас в комнате такая книга?".

*Примечание:*
+ URL чаще встречаются в повседневной работе в Интернете, поскольку они используются для доступа к веб-ресурсам
+ URN встречаются реже, но служат конкретной цели обеспечения постоянных и независимых от местоположения идентификаторов ресурсов, что делает их ценными в некоторых специализированных областях, где стабильность и уникальность ресурсов имеют первостепенное значение.
### Методы HTTP
HTTP определяет типы запросов, которые могут быть отправлены от клиента к серверу. Эти типы называются HTTP-методами:
+ ``GET`` - используется для чтения данных с сервера
+ ```POST``` - используется для создания чего-либо на стороне сервера. Например, создать новую учетную запись пользователя.
+ ```PUT``` - используется для полного обновления ресурса (клиент должен отправить полный набор данных ресурса, даже если необходимо изменить только одну часть ресурса). Он заменяет весь текущий ресурс на сервере новыми данными, переданными в запросе. ```PUT``` является идемпотентным методом. Это означает, что повторный вызов PUT с одинаковыми данными приведет к одному и тому же результату, не изменяя ресурс повторно
+ ```DELETE``` - что-то удалить.
+ ```PATCH``` - используется для частичного обновления ресурса. Он вносит изменения только в те части ресурса, которые указаны в запросе. ```PATCH``` может быть неидемпотентным, что означает, что повторные вызовы могут привести к различным результатам
+ ```HEAD``` - аналогично ```GET```, но возвращаются только заголовки ответа (некоторая метаинформация) (без данных).
+ ```OPTIONS``` - метод не выполняет никаких изменений и не возвращает данные ресурса; вместо этого он возвращает информацию о том, какие методы HTTP и другие параметры коммуникации поддерживаются. Метод ```OPTIONS``` широко используется в механизме ```CORS``` для выполнения предварительных запросов (preflight requests). Когда браузер делает запрос к ресурсу на другом домене, сначала отправляется запрос ```OPTIONS``` для проверки разрешений. Ответ на этот запрос включает информацию о том, разрешен ли доступ и какие методы и заголовки допустимы. Пример предварительного запроса (preflight request):
```console
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: http://www.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header
```
Пример ответа на предварительный запрос:
```console
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://www.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-Custom-Header
```
+ ```CONNECT``` - используется для установления туннеля связи между клиентом и целевым сервером через промежуточный сервер (создание туннелей для HTTPS, для создания туннелей для VPN-соединений и других туннельных протоколов, где требуется передача данных через защищенный канал).
+ ```TRACE``` - используется для диагностики, отладки сетевых соединений, отладка прокси-серверов и шлюзов, проверка целостности запроса. Он позволяет клиенту отправить запрос на сервер и получить в ответе точную копию этого запроса. Это помогает определить, какие изменения или модификации были внесены в запрос при его прохождении через различные промежуточные узлы (прокси-серверы, шлюзы и т.д.). Метод ```TRACE``` может представлять угрозу безопасности, так как он возвращает клиенту всю информацию запроса, включая возможные конфиденциальные данные и заголовки. Это может быть использовано злоумышленниками для проведения атак, таких как ```Cross-Site Tracing (XST)```. Многие веб-серверы и прокси-серверы по умолчанию отключают поддержку метода ```TRACE``` или ограничивают его использование для повышения безопасности.
#### CRUD
Четыре метода (```GET```, ```POST```, ```PUT```, ``DELETE``) называют ``CRUD``: CREATE-READ-UPDATE-DELETE (где CREATE - POST, READ - GET, UPDATE - PUT, а DELETE - DELETE).
### HTTP Запрос/Ответ
<img src="resources/Req_resp_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

### Коды состояния HTTP
+ 200 OK. Все в порядке, вот содержимое запрашиваемой страницы.
+ 201 Created. Запрашиваемый ресурс успешно создан.
+ 301 Moved Permanently. Ресурс с этим URI навсегда перемещен по адресу, указанному в заголовках на стороне сервера.
+ 302 Moved Temporarily. Аналогично, но перемещено временно. Часто 301 и 302 означают одно и то же, это зависит от настроек веб-сервера (или веб-приложения). Так что основная идея кодов 301/302 - "возьмите новый адрес и перейдите туда".
+ 304 Not Modified. Если был использован заголовок клиента "If-Modified-Since" (если изменен, то...) и ресурс не был изменен, то нет необходимости получать его снова.
+ 400 Bad Request. Что-то не так с вашим запросом.
+ 401 Unauthorized. Вы должны быть авторизованы, чтобы открыть этот URI. Когда сервер отвечает этим кодом, он также показывает вам форму авторизации для ввода логина и пароля.
+ 403 Forbidden. Доступ запрещен. Показывается, например, когда введены неправильные логин и/или пароль.
+ 404 Not found. Ресурс с таким URI не существует (или сервер хочет, чтобы вы так думали).
+ 418 I’m a teapot. (418 Я чайник) Код из первоапрельской шутки, на самом деле не должен работать.
+ 500 Internal Server Error. Что-то не так с сервером.
+ 502 Bad Gateway. Сервер попытался перенаправить ваш запрос на другой сервер, но не преуспел в этом.
+ 503 Service Unavailable. По сути, то же самое, что 500.
+ 504 Gateway Timeout. То же самое, что и 502, но в случае ошибки тайм-аута.
### Заголовки HTTP
Вторая часть HTTP-запроса или ответа - раздел заголовков.
#### Заголовки запросов
##### General Headers (Общие заголовки):
+ ```Host```: Указывает доменное имя и порт сервера, к которому обращается клиент.
+ ```Connection```: Управляет параметрами текущего соединения. Например, ```Connection: keep-alive``` сохраняет соединение открытым для последующих запросов.
+ ```Cache-Control```: Управляет кешированием запросов. Например, ```Cache-Control: no-cache```.
##### Request Headers (Заголовки запросов):
+ ```Accept```: Указывает типы медиа, которые клиент может обработать. Например, ```Accept: text/html```.
+ ```User-Agent```: Идентифицирует клиентское приложение. Например, ```User-Agent: Mozilla/5.0```.
+ ```Accept-Language```: Указывает предпочтительные языки. Например, ```Accept-Language: en-US```.
+ ```Authorization```: Передает учетные данные для аутентификации. Например:
  + ```Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела запроса. Например, ```Content-Type: application/json```.
+ ```Content-Length```: Указывает длину тела запроса в байтах. Например, ```Content-Length: 348```.
#### Заголовки ответов
##### General Headers (Общие заголовки):
+ ```Date```: Указывает дату и время, когда сервер сгенерировал ответ. Например, ```Date: Wed, 12 Jun 2024 15:00:00 GMT```.
##### Response Headers (Заголовки ответов):
+ ```Server```: Идентифицирует серверное программное обеспечение. Например, ```Server: Apache/2.4.1 (Unix)```.
+ ```Set-Cookie```: Устанавливает cookie в браузере. Например, ```Set-Cookie: sessionId=abc123; Path=/; Secure; HttpOnly```.
+ ```WWW-Authenticate```: Указывает метод аутентификации, требуемый для доступа к ресурсу. Например:
  +  ```WWW-Authenticate: Basic realm="Access to the site"```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела ответа. Например, ```Content-Type: text/html; charset=UTF-8```.
+ ```Content-Length```: Указывает длину тела ответа в байтах. Например, ```Content-Length: 348```.
+ ```Content-Encoding```: Указывает кодировку, использованную для сжатия тела. Например, ```Content-Encoding: gzip```.
#### Другие важные заголовки
+ ```Referer```: Указывает URL, с которого был сделан запрос. Например, ```Referer: https://www.example.com```.
+ ```Location```: Используется для перенаправлений, указывает новый URL. Например, ```Location: https://www.example.com/newpage```.
+ ```Transfer-Encoding```: Управляет фрагментацией тела сообщения. Например, ```Transfer-Encoding: chunked```  позволяет серверу передавать данные в виде серии "чанков", что особенно полезно, когда размер контента неизвестен на момент начала передачи.
+ ```X-Content-Type-Options```: Заголовок ```X-Content-Type-Options: nosniff``` - инструмент для повышения безопасности веб-приложений. Он сообщает браузеру, что он должен строго следовать указанному типу MIME и не пытаться определять его самостоятельно. Это помогает предотвратить выполнение потенциально опасных файлов. 
+ ```Strict-Transport-Security```: Указывает политику безопасности для HTTPS. Когда браузер получает  от сервера этот заголовок, он запоминает домен и обязуется в течение указанного периода времени (максимального возраста) использовать только HTTPS для всех последующих запросов к этому домену. Если злоумышленник попытается заставить браузер использовать HTTP, а не HTTPS, данный заголовок предотвратит это, так как браузер будет знать, что только HTTPS соединения разрешены. Пример:
  + ```Strict-Transport-Security: max-age=31536000```. 

*Примечание:*
Существуют пользовательские заголовки, поддерживаемые только конкретным приложением. Например, вы можете отправить в запросе заголовок x-correlation-id, и ваш сервер должен знать, как обработать этот заголовок.
### Тело HTTP-запроса/ответа
HTTP-запрос/ответ может содержать полезную нагрузку, которая помещается в часть Request Body или Response Body. Тело может содержать:
+ исходный код веб-страницы
+ данные в формате JSON
+ различные типы медиа в соответствии со стандартом: аудио, изображение, текст и так далее.

При выполнении запроса (PUT, POST) тип данных задается с помощью заголовка ```Content-type```, например:
+ ```Content-Type: text/html; charset=utf-8```
## JSON
JSON (JavaScript Object Notation) - легковесный и фундаментальный формат для создания современных веб-приложений и API. JSON используется
+ для передачи данных между сервером и веб-приложением
+ в файлах конфигурации и хранения данных.

К особенностям JSON можно отнести то, что он:
+ стандартизирован: имеет согласованные структуры и форматы данных, хорошо документирован и обладает широкой инструментальной поддержкой. Всё это облегчают работу по  межсистемному тестированию (созданию тестовых данных, обработке ошибок и сотрудничеству с командами разработчиков);
+ независим от языка программирования (хотя в названии JSON присутствует JavaScript), что делает его универсальным и подходящим для широкого спектра приложений.
+ представляет данные в виде набора пар ключ-значение. Каждый ключ - это строка, заключенная в ДВОЙНЫЕ кавычки, а значения могут быть строками, числами, булевыми значения, объектами, массивами или null. Эти наборы пар заключены в фигурные скобки {}
+ игнорирует пробельные символы (пробелы, табуляции, переносы строк) вне строк, что облегчает форматирование для удобства чтения, например:
```console
{"name":"Alice","age":30,"city":"Wonderland"}
```
то же, что и:
```console
{
    "name": "Alice",
    "age": 30,
    "city": "Wonderland"
}
```
### Типы данных
1. **Строка**: Строка - это последовательность символов, заключенных в двойные кавычки. Строки используются для представления текста и могут включать буквы, цифры, символы и пробелы.
2. **Число**: JSON поддерживает как целые числа, так и числа с плавающей точкой. Числа не заключаются в кавычки и могут быть положительными или отрицательными.
3. **Boolean**: В JSON есть два булевых значения: true (истина) и false (ложь).
4. **Объект**: Объект - это неупорядоченная коллекция пар ключ-значение, заключенная в фигурные скобки {}. Ключи - это строки, а значения могут быть любого типа данных JSON, включая другие объекты или массивы.
5. **Массив**: Массив - это упорядоченный список значений, заключенный в квадратные скобки []. Массивы могут содержать значения любого типа данных JSON, включая строки, числа, булевы, объекты и другие массивы. Массивы не ограничены одним типом данных, поэтому один и тот же массив может одновременно содержать строки, числа, булевы значения, объекты, другие массивы и null.
6. **Null**: Специальное значение null означает отсутствие данных или пустое значение. Оно часто используется для обозначения того, что значение намеренно отсутствует или не определено.
<img src="resources/json-introduction_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

## API
API (Application Programming Interface) - определяет методы, которые одно программное приложение может использовать для взаимодействия с другим. Он служит интерфейсом, через который программы могут запрашивать и обмениваться данными и функциональностью. Существуют различные API:
+ Аппаратное обеспечение (например, интерфейс жесткого диска)
+ Операционная система (доступ к файловой системе, доступ к пользовательскому интерфейсу)
+ Относящееся к Web (SOAP, REST, GraphQL)
+ gRPC для микросервисов и высоконагруженных систем
### SOAP
**SOAP** (Simple Object Access Protocol) - это протокол обмена структурированными сообщениями в распределенной вычислительной среде, основанный на XML. Он предназначен для обмена информацией между компьютерными системами по сети, независимо от используемых программных языков и аппаратных платформ. Был популярен в начале 2000-х годов.
#### Основные характеристики SOAP API:
1. SOAP использует XML для форматирования запросов и ответов.
2. SOAP обычно работает поверх прикладных протоколов, таких как HTTP и HTTPS. Эти прикладные протоколы в свою очередь используют транспортные протоколы, такие как TCP. SOAP также может работать поверх других прикладных протоколов, таких как SMTP.
3. Сообщения SOAP состоят из трех основных частей:
   1. Envelope (Конверт): Обертка сообщения, которая определяет, что содержимое является SOAP-сообщением и предоставляет пространство имен.
   2. Header (Заголовок): Необязательная часть, содержащая информацию для маршрутизации и обработки сообщения.
   3. Body (Тело): Основная часть сообщения, содержащая запрос или ответ.
4. Расширяемость: SOAP поддерживает расширяемые архитектуры, позволяя добавлять новые функциональные возможности через заголовки и модули.
5. Стандарты безопасности: SOAP поддерживает ```WS-Security```, что обеспечивает безопасную передачу сообщений через сети.
#### Преимущества SOAP API:
1. Платформенная независимость: SOAP может использоваться на различных платформах и с различными языками программирования благодаря использованию стандартного XML-формата.
2. Безопасность: SOAP включает в себя расширения безопасности, такие как ```WS-Security```, для обеспечения конфиденциальности и целостности данных.
3. Междоменная связь: SOAP легко проходит через междоменные политики и файрволы, так как часто использует HTTP/HTTPS.
4. Формальная спецификация: SOAP имеет четко определенные стандарты и спецификации, что делает его надежным и хорошо документированным протоколом.
#### Примеры использования SOAP API:
1. Банковские и финансовые системы: SOAP часто используется в финансовых приложениях, где важна безопасность и надежность передачи данных.
2. Корпоративные системы: Большие предприятия используют SOAP для интеграции различных систем и приложений внутри организации.
3. Услуги правительственных организаций: SOAP применяется для передачи данных между государственными учреждениями и сервисами, требующими высокой степени безопасности и согласованности.
#### Пример SOAP-сообщения:
```htm
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:m="http://www.example.org/stock">
   <soap:Header>
      <m:Trans>234</m:Trans>
   </soap:Header>
   <soap:Body>
      <m:GetStockPrice>
         <m:StockName>IBM</m:StockName>
      </m:GetStockPrice>
   </soap:Body>
</soap:Envelope>
```
*В этом примере SOAP-сообщения запрос отправляется для получения цены акции компании IBM. Конверт оборачивает все сообщение, заголовок содержит идентификатор транзакции, а тело содержит сам запрос.*
#### Недостатки SOAP:
SOAP имеет несколько недостатков по сравнению с другими протоколами обмена сообщениями, такими как REST:
1. Тяжеловесность: SOAP использует XML для форматирования сообщений, что делает его более тяжеловесным по сравнению с более современными и легковесными форматами данных, такими как JSON. Это требует больше ресурсов для обработки и передачи данных. Отсюда и проблемы производительностью и, таким образом, меньше подходит для ресурсоемких операций.
2. Сложность разработки и поддержки: SOAP имеет сложную спецификацию и требует строгого соблюдения стандартов. Это может усложнять процесс разработки, особенно для новичков в области веб-сервисов.
3. Низкая читаемость: XML-структура SOAP-сообщений не так легко читаема как JSON, что может затруднять отладку и мониторинг.
4. Сложность интеграции с современными веб-технологиями: В современных веб-приложениях, где широко используются JavaScript и RESTful API, интеграция с SOAP может потребовать дополнительных усилий и библиотек.
5. Сложность в настройке безопасности: Хотя SOAP поддерживает WS-Security для обеспечения безопасности сообщений, его конфигурация и настройка могут потребовать дополнительных усилий и специализированных знаний.
### gRPC
gRPC (gRPC Remote Procedure Calls) — разработанный Google в 2015 году современный, высокопроизводительный RPC фреймворк, использующий ```HTTP/2``` для транспорта и ```Protocol Buffers``` (protobuf) для сериализации данных. 

*RPC (Remote Procedure Call) — это протокол, который позволяет программе выполнять методы на удаленном сервере так, как будто они выполняются локально.*
#### Преимущества gRPC
1. Высокая производительность: 
   1. HTTP/2 в качестве транспорта обеспечивает эффективную передачу данных (мультиплексирование запросов, компрессию заголовков и поддержку server push).
   2. Protocol Buffers обеспечивают компактное представление данных в бинарном формате, что уменьшает размер передаваемых данных, ускоряет их передачу по сети и, благодаря простоте и эффективности бинарного формата, обеспечивают более компактное и быстрое кодирование/декодирование данных по сравнению с JSON или XML.
2. Сильная типизация: gRPC использует строго типизированные контракты, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает лучшее автодополнение и рефакторинг в IDE.
3. Мультиплатформенность: gRPC поддерживает множество языков программирования, включая C++, Java, Python, Go, Ruby, C#, Node.js и другие, что позволяет использовать его в различных экосистемах для эффективного обмена данными между различными компонентами системы
4. Двусторонний стриминг: gRPC поддерживает не только одноразовые запросы-ответы, но и потоковые взаимодействия (как клиент-сервер, так и двусторонние), что делает его идеальным для приложений реального времени.
5. Интероперабельность: gRPC обеспечивает высокую степень совместимости между различными системами и сервисами благодаря четко определённым интерфейсам и стандартизованным инструментам.
#### Недостатки gRPC
1. Сложность настройки: В отличие от REST, который часто используется в веб-разработке и имеет большое количество документации и инструментов, gRPC может потребовать больше усилий для настройки и интеграции, особенно для разработчиков, незнакомых с Protocol Buffers и HTTP/2.
2. Ограниченная поддержка браузеров: gRPC предназначен в первую очередь для взаимодействия между микросервисами и серверными приложениями, где он обеспечивает высокую производительность благодаря использованию HTTP/2 и Protocol Buffers. Однако, из-за использования бинарного формата и специализированной обработки, gRPC не поддерживается непосредственно большинством современных веб-браузеров. Для того чтобы клиентские веб-приложения могли взаимодействовать с gRPC-бэкендами, был разработан протокол gRPC-Web, являющийся адаптацией gRPC для работы через стандартный HTTP/1.x и поддерживаемый браузерами. Однако для использования gRPC-Web требуется дополнительный прокси-сервер или промежуточный слой на стороне сервера, который конвертирует запросы и ответы между gRPC и gRPC-Web. Этот прокси-сервер или промежуточный слой позволяет преобразовывать запросы HTTP/1.x от клиентских браузеров в gRPC-запросы на сервере и наоборот.
3. Изучение новых технологий: Разработчикам, привыкшим к REST и JSON, может потребоваться время на освоение Protocol Buffers и принципов работы gRPC, что может замедлить начальную разработку.
4. Необходимость в gRPC-специфичных инструментах: Для генерации клиентских и серверных кодов необходимо использовать специфические инструменты gRPC, что может добавить сложности в процессы сборки и развертывания.
5. Командное управление версиями: Управление версиями и обновление контрактов может быть сложнее в gRPC из-за строгой типизации и необходимости синхронизации между клиентами и серверами.
#### Примеры использования gRPC
1. Микросервисная архитектура: gRPC идеально подходит для внутреннего взаимодействия микросервисов благодаря своей высокой производительности и поддержке различных языков программирования.
2. Системы реального времени: Потоковые возможности gRPC делают его отличным выбором для чатов, видеоконференций, игр и других приложений, требующих низкой задержки и высокой пропускной способности.
3. Интерфейсы для мобильных и IoT-устройств: Благодаря компактному формату Protocol Buffers, gRPC может эффективно использоваться на устройствах с ограниченными ресурсами, таких как мобильные и IoT-устройства.
#### Заключение
gRPC предоставляет мощные возможности для создания производительных и масштабируемых распределенных систем. Однако, он может быть сложнее в настройке и использовании по сравнению с REST, особенно для разработчиков, привыкших к традиционным веб-технологиям. Выбор между gRPC и другими протоколами, такими как REST, зависит от конкретных требований проекта, включая производительность, сложность, поддерживаемые платформы и тип взаимодействия.
### GraphQL
+ GraphQL (Graph Query Language) — это язык запросов для API, разработанный Facebook в 2012 году и выпущенный в открытый доступ в 2015 году. GraphQL предоставляет гибкий и эффективный способ взаимодействия с сервером, позволяя клиенту запрашивать именно те данные, которые ему необходимы, и ничего лишнего.
+ GraphQL может работать поверх любого транспортного протокола, но обычно используется с HTTP/HTTPS для взаимодействия между клиентом и сервером (поддерживается веб-браузерами без дополнительных инструментов в отличие от gRPC). 
+ Запросы и ответы GraphQL передаются в формате JSON, что делает их легкими для чтения и обработки.
+ Клиент может отправлять запросы различными способами, в зависимости от используемых инструментов и среды разработки, в том числе, с помощью Postman;
  1. Создайте новый запрос и выберите тип GraphQL
  2. Вставьте ваш GraphQL-запрос в поле для запроса:
```console
query GetBook($id: ID!) {
  book(id: $id) {
    title
    author {
      name
    }
  }
}
```
  1. Введите URL вашего GraphQL сервера, например, http://localhost:4000/graphql.
  2. Нажмите "Send" для выполнения запроса.
#### Преимущества GraphQL
1. Запрос только необходимых данных: Клиенты могут запрашивать ровно те поля, которые им нужны, что снижает объем передаваемых данных и повышает производительность.
2. Гибкость запросов: Клиенты могут комбинировать несколько запросов в одном вызове, делать вложенные запросы и т.д., что позволяет уменьшить количество сетевых запросов.
3. Типизированная система: GraphQL использует строгую типизацию схемы, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает автодополнение и документацию прямо в редакторе.
4. Единый эндпоинт: Все запросы обрабатываются через один эндпоинт, что упрощает архитектуру API и управление запросами.
5. Инструменты для разработки: GraphQL имеет отличные инструменты для разработки и отладки, такие как GraphiQL и Apollo Client, которые помогают разработчикам быстро и эффективно работать с API.
#### Недостатки GraphQL
1. Сложность настройки и обучения: Первоначальная настройка и обучение GraphQL может быть более сложной по сравнению с REST, особенно для разработчиков, незнакомых с концепцией схем и типизаций.
2. Производительность на сервере: Обработка запросов GraphQL может потребовать больше ресурсов на сервере, так как сервер должен динамически разбирать запросы и формировать ответ. Особенно это заметно при сложных или неоптимизированных запросах.
3. Кеширование: Кеширование в GraphQL сложнее реализовать по сравнению с REST. В REST можно использовать кеширование на уровне HTTP, тогда как в GraphQL запросы могут быть более сложными и динамическими, что затрудняет кеширование на уровне сети.
4. Ограничения в инструментах мониторинга и безопасности: Традиционные инструменты мониторинга и безопасности, которые хорошо работают с REST, могут быть несовместимы с GraphQL или требовать дополнительной настройки.
#### Примеры использования GraphQL
1. Facebook: Facebook использует GraphQL для своего мобильного приложения, обеспечивая эффективный и гибкий доступ к данным.
2. GitHub: GitHub предлагает GraphQL API, позволяя разработчикам запрашивать только необходимые данные и получать их в одном запросе.
3. Shopify: Shopify использует GraphQL для своего Storefront API, что позволяет разработчикам создавать гибкие и производительные интерфейсы для интернет-магазинов.
#### Заключение
GraphQL предоставляет мощные и гибкие возможности для разработки API, позволяя клиентам запрашивать только необходимые данные и улучшая производительность и эффективность взаимодействия с сервером. Однако, он требует более сложной настройки и обучения, а также может потребовать дополнительных ресурсов на сервере. Выбор между GraphQL и другими протоколами, такими как REST или gRPC, зависит от конкретных требований проекта, включая гибкость, производительность и сложность реализации.
### Endpoint API<a id="endpoint-api"></a>
Endpoint (конечная точка) в API — это конкретный URL-адрес, по которому можно выполнить определенное действие в рамках API(получение данных, создание ресурса, обновление или удаление).
#### Основные аспекты Endpoint в API:
1. URL-адрес: URL (Uniform Resource Locator) включает в себя доменное имя, путь и, возможно, параметры запроса. Например, в REST API URL может выглядеть так: ```https://api.example.com/users/123```.
2. Метод HTTP: Эндпоинт обычно ассоциируется с одним из HTTP-методов, таких как GET, POST, PUT, DELETE, которые определяют тип операции, которую клиент хочет выполнить.
   + GET: Получение данных.
   + POST: Создание нового ресурса.
   + PUT: Обновление существующего ресурса.
   + DELETE: Удаление ресурса.
3. Ресурсы и действия: Эндпоинты связаны с конкретными ресурсами или действиями. Например:
   + GET /users: Получить список пользователей.
   + POST /users: Создать нового пользователя.
   + GET /users/123: Получить информацию о пользователе с ID 123.
   + PUT /users/123: Обновить информацию о пользователе с ID 123.
   + DELETE /users/123: Удалить пользователя с ID 123.
4. Параметры: Эндпоинты могут включать параметры пути (path parameters) и параметры запроса (query parameters), которые уточняют запрос.
   + Параметры пути: /users/{id}
   + Параметры запроса: /users?sort=asc&limit=10
#### Примеры
##### REST API:
В REST API эндпоинты представляют собой URL-адреса, которые соответствуют ресурсам и действиям над ними. Например:
+ GET /api/products: Получить список продуктов.
+ POST /api/products: Создать новый продукт.
+ GET /api/products/123: Получить информацию о продукте с ID 123.
+ PUT /api/products/123: Обновить продукт с ID 123.
+ DELETE /api/products/123: Удалить продукт с ID 123.
+ GET /api/products?category=electronics: Фильтрация результатов
+ GET /api/posts?page=2&pageSize=10: Пагинация результатов
+ GET /api/articles/456/details: Получение подробностей о ресурсе
+ GET /api/countries/usa/cities/new-york: Получение ресурса с использованием путей
+ GET /api/articles/123/comments: Получение коллекции связанных ресурсов
##### GraphQL API:
В GraphQL API обычно есть один эндпоинт для всех запросов и мутаций. GraphQL API поддерживает для выполнения запросов к API использование методов HTTP POST (используется для выполнения запросов GraphQL, которые могут быть сложными, содержать мутации или большие данные) и GET (может использоваться для выполнения простых запросов GraphQL, часто для чтения данных, а также в ситуациях, когда требуется кэширование или передача параметров через строку запроса). Например, здесь все запросы и мутации отправляются на этот эндпоинт, а данные и операции указываются в теле запроса:
+ ```POST /graphql```
##### SOAP API:
В SOAP API эндпоинты представляют собой URL-адреса, к которым отправляются SOAP-сообщения. В отличие от GraphQL, который обычно имеет один универсальный эндпоинт для всех запросов и мутаций, SOAP API может иметь несколько эндпоинтов, каждый из которых представляет собой конкретную веб-службу или операцию. SOAP API, как правило, использует метод POST для отправки SOAP-запросов на сервер. Это обусловлено тем, что SOAP-запросы представляют собой структурированные XML-документы, которые передаются в теле HTTP-запроса. Например:
+ ```POST /service.asmx```.
##### Заключение
Эндпоинт в API играет ключевую роль в определении того, как клиент взаимодействует с сервером. Он включает URL-адрес, HTTP-метод, ресурсы и параметры, которые вместе определяют конкретное действие, которое должно быть выполнено.
### Документация по API
Документация по API содержит подробную информацию и инструкции о том, как эффективно использовать API и взаимодействовать с ним.

Пример открытого API Petstore на языке Swagger
<img src="resources/petstoreSwaggerList_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

<img src="resources/petstoreSwagger_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

#### Обычно документация по API содержит:
1. **Обзор**: объясняет, что делает API, какие данные или функциональные возможности он предоставляет и почему он полезен.
2. **Endpoint'ы**: в документации по API перечислены все доступные [endpoint'ы](#endpoint-api), в которых указано, к каким данным или действиям можно получить доступ через API.
3. **Методы запроса**: Эта часть объясняет, какие "действия" вы можете выполнять с каждым endpoint'ом. В мире API эти действия обычно представлены HTTP-методами GET, POST, PUT и DELETE.
4. **Параметры**: в документации API подробно описаны параметры, которые можно использовать при выполнении запросов API.
5. **Формат ответа**: документация по API подсказывает, какого рода ответ следует ожидать при использовании endpoint’а, объясняя формат данных, которые возвращает API.
6. **Обработка ошибок**: В документации по API приводятся инструкции о том, как API обрабатывает ошибки, реагируя на недействительные или неожиданные входные данные.
7. **Примеры**: Документация по API может содержать примеры использования API, пригодные для тестирования сценариев.
8. **Аутентификация**: документация по API объясняет, как аутентифицировать себя для безопасного использования API.
9. **Ограничения и квоты**: документация к API содержит подробную информация об ограничениях API, например, по частоте использования.
#### Документация условно делится на:
+ классическую (веб-страница, полная статичных таблиц и параграфов). Она проста для чтения и понимания, но основным недостатком классического подхода является то, что такая документация может быть устаревшей;
+ динамическую. В большинстве случаев генерируется на лету. Пример динамической документации: https://petstore.swagger.io/. Динамическая документация является наиболее актуальной и в некоторых случаях может использоваться для выполнения запросов или даже генерации программного кода (например, генерации исходного кода для клиента API). 
##### Инструменты и спецификации динамической документации:
1. ```OpenAPI```<a id="openapi"></a>
   1. OpenAPI - спецификация для описания RESTful API. Определяет стандартный формат для создания машинно-читабельной документации API, включающей в себя информацию о всех эндпоинтах, методах HTTP, параметрах, типах данных и так далее. OpenAPI Specification (OAS) предоставляет язык для описания интерфейсов API в формате JSON или YAML.
   2. OpenAPI JSON — это формат, используемый для описания API (интерфейсов прикладного программирования) с помощью спецификации OpenAPI. Использование OpenAPI JSON позволяет автоматизировать создание документации, генерацию клиентских и серверных библиотек и улучшить взаимодействие между различными частями системы. Основные компоненты OpenAPI JSON:
      1. openapi: Версия спецификации OpenAPI, используемой в документе.
      2. info: Метаданные об API, такие как название, версия, описание и контактная информация.
      3. servers: Список серверов, на которых доступен API.
      4. paths: Определения путей (endpoints), доступных в API, и методов (GET, POST, PUT, DELETE и т.д.), поддерживаемых каждым путем.
      5. components: Определения компонентов, используемых в API, таких как схемы данных (models), параметры, ответы, запросы и безопасность.
      6. security: Определение методов аутентификации и авторизации для API.
      7. tags: Список тегов для организации и группировки операций API.
      8. externalDocs: Ссылки на внешнюю документацию.
   3. Пример API с одним эндпоинтом /users, который поддерживает GET запрос для получения списка пользователей. В разделе components определяется схема User, описывающая структуру объекта пользователя
      ```json
      {
         "openapi": "3.0.0",
         "info": {
            "title": "Sample API",
            "description": "API для демонстрации OpenAPI спецификации",
            "version": "1.0.0"
         },
         "servers": [
            {
               "url": "https://api.example.com/v1"
            }
         ],
         "paths": {
            "/users": {
               "get": {
               "summary": "Получить список пользователей",
               "responses": {
                  "200": {
                     "description": "Успешный ответ",
                     "content": {
                     "application/json": {
                        "schema": {
                           "type": "array",
                           "items": {
                           "$ref": "#/components/schemas/User"
                           }
                        }
                     }
                     }
                  }
               }
               }
            }
         },
         "components": {
            "schemas": {
               "User": {
               "type": "object",
               "properties": {
                  "id": {
                     "type": "integer",
                     "format": "int64"
                  },
                  "name": {
                     "type": "string"
                  }
               }
               }
            }
         }
      }
      ```
2. ```Swagger```<a id="swagger"></a> - набор инструментов и экосистема для работы с API, созданная для поддержки и расширения возможностей, описанных в спецификации OpenAPI. Включает в себя следующие компоненты:
   1. Swagger Editor: Веб-редактор для создания и редактирования спецификаций OpenAPI.
   2. Swagger UI: Генератор пользовательского интерфейса для взаимодействия с API, описанным в спецификации OpenAPI. Этот инструмент позволяет пользователям легко тестировать API через веб-интерфейс.
   3. Swagger Codegen: Инструмент для генерации клиентских библиотек, серверных stubs и документации из спецификации OpenAPI.
   4. Swagger Inspector: Инструмент для тестирования API и генерации спецификаций OpenAPI из существующих API.

*Внимание!!! Чтобы понять, как спецификация OpenAPI в JSON может быть преобразована в человекочитаемую документацию по API, нужно посетить сайт https://editor.swagger.io/ и вставить приведенный выше "Пример API с одним эндпоинтом /users..." в редактор Swagger.*
### Примеры
1. Репозиторий [Public APIs](https://github.com/public-api-lists/public-api-lists) - это ресурс для разработчиков и широкой общественности. Он служит курируемой коллекцией публичных API из различных областей, облегчая разработчикам поиск и доступ к широкому спектру данных и сервисов. 
2. Документация по API на [GitHub](https://docs.github.com/en/rest) - это один из эталонных API в Интернете.
3. [Accuweather](https://developer.accuweather.com/) - один из публичных API сервисов прогнозов погоды.
## Авторизация и аутентификация API
### Аутентификация
Аутентификация - это процесс проверки подлинности личности пользователя, устройства или системы, пытающихся получить доступ к ресурсу. В контексте HTTP аутентификация часто включает в себя ввод имени пользователя и пароля, которые затем проверяются системой. Также могут использоваться и другие методы, такие как одноразовые пароли (OTP), отпечатки пальцев или двухфакторная аутентификация. После проверки подлинности пользователю предоставляется доступ к ресурсам системы. 
### Авторизация
Авторизация определяет уровень доступа **аутентифицированного пользователя** к определенным ресурсам и функциональным возможностям. Авторизация часто основывается на ролях или разрешениях, связанных с пользователем и не позволяет неавторизованным пользователям выполнять действия, выходящие за рамки их полномочий.
### API-токены
**API-токен** - это часть данных, которая используется для аутентификации и авторизации субъекта взаимодействия с API (пользователя, системы или приложения)

#### Ключевые моменты API-токенов:
1. *Аутентификация и авторизация*:  API может проверить токен, чтобы узнать, какими правами или ролями обладает носитель токена и, соответственно, предоставить или запретить доступ.
2. *Генерация токенов*: API-токены генерируются провайдером API или службой аутентификации после  аутентификации пользователя или приложения. Они уникальны для каждого субъекта взаимодействии с API.
3. *Истечение срока действия и аннулирование*: API-токены могут иметь срок действия, по истечении которого они становятся недействительными. Если токен скомпрометирован или больше не нужен, его можно отозвать, чтобы предотвратить дальнейший доступ. Для пользователя просроченный токен может выглядеть как просроченная сессия.
4. *Типы API-токенов*: Существуют различные типы API-токенов, в том числе:
   1. *API-ключ (API Keys)*:
      1. Описание:
         1. Простые строки: API-ключи обычно представляют собой простые строки или коды.
         2. Идентификация клиента: Основная цель API-ключей — аутентификация (идентификация) клиента, который делает запрос к API: чтобы API могло отличать одно приложение от другого и применять к ним разные правила доступа или квоты. Например:
            1. Разработчик регистрирует свое приложение в сервисе картографии и получает уникальный API Key.
            2. В приложении API Key используется для идентификации приложения при каждом запросе к API сервиса картографии.
            3. Сервис картографии использует API Key для отслеживания использования приложением и применяет разные правила доступа или квоты на основе зарегистрированных параметров приложения.
         3. Легкость использования: API-ключи легко интегрируются в запросы, часто просто добавляются в заголовок или параметр URL.
      2. Безопасность:
         1. Меньше безопасности: API-ключи не содержат информации о правах доступа или пользователе, их безопасность зависит от способа передачи (рекомендуется использовать HTTPS).
         2. Нет поддержки сроков действия: API-ключи обычно не имеют встроенного срока действия, что делает их более уязвимыми, если они будут скомпрометированы.
      3. Пример:
         1. предоставления API Keys в HTTP-заголовке
         ```console
         GET /api/resource HTTP/1.1
         Host: example.com
         X-API-Key: YOUR_API_KEY
         ```
         2. предоставления API Keys в URL-запросе
         ```console
         GET /api/resource?api_key=YOUR_API_KEY HTTP/1.1
         Host: example.com
         ```
   2. *Токен носителя (Bearer Tokens)*:
      1. Описание:
         1. Более сложные структуры: Токены носителя обычно представляют собой более сложные строки, часто сгенерированные с использованием протоколов аутентификации, таких как OAuth 2.0.
         2. Аутентификация и авторизация: Токены носителя не только идентифицируют клиента, но и предоставляют права доступа, встроенные в токен.
         3. Широкие возможности: Токены носителя могут содержать информацию о пользователе, правах доступа, времени действия и т.д.
      2. Безопасность:
         1. Повышенная безопасность: Токены носителя имеют ограниченный срок действия и могут быть отозваны, что делает их более безопасными.
         2. Часто используются вместе с HTTPS: Токены носителя передаются по защищенному соединению, что уменьшает риск их перехвата.
         3. Информация внутри токена: В случае JWT (JSON Web Tokens) токены содержат зашифрованную информацию о пользователе и его правах, что позволяет серверу быстро проверять токен без обращения к базе данных.

      3. Пример
         1. Запрос на получение токена:
            ```console
            POST /oauth/token HTTP/1.1
            Host: auth.example.com
            Content-Type: application/x-www-form-urlencoded

            grant_type=client_credentials&client_id=your_client_id&client_secret=your_client_secret
            ```
            Ответ:
            ```json
            {
            "access_token": "your_bearer_token_here",
            "token_type": "Bearer",
            "expires_in": 3600
            }
            ```
         2. Запрос к API с использованием токена носителя:
            ```console
            GET /v1/data HTTP/1.1
            Host: api.example.com
            Authorization: Bearer your_bearer_token_here
            ```
#### Алгоритм работы аутентификации на основе токена носителя (Bearer Tokens):
1. *Аутентификация пользователя*: Когда пользователь входит в систему, его учетные данные (обычно имя пользователя и пароль) отправляются на сервер аутентификации для проверки.
2. *Генерация токенов*: Если учетные данные пользователя действительны, сервер аутентификации генерирует уникальный токен. Этот токен связан с сессией пользователя и часто содержит информацию о его личности и разрешениях.
3. *Выдача токена*: Токен выдается пользователю, который затем предъявляет его при каждом последующем запросе на доступ к защищенному ресурсу или выполнение действия.
4. *Проверка подлинности*: Сервер, получивший токен, проверяет его действительность, убеждаясь, что срок его действия не истек и он не был подделан. Если токен действителен, доступ предоставляется; в противном случае запрос отклоняется.
<table><thead><tr><th style="width:18.0979%;"><br></th><th style="width:42.1696%;"><span>Bearer tokens</span></th><th style="width:40.1509%;"><span>API &nbsp;Keys</span></th></tr></thead><tbody><tr><td style="width:18.0979%;"><span>Безопасность</span></td><td style="width:42.1696%;"><p style="text-align:justify;">Считаются более безопасными, поскольку обычно имеют большую длину и генерируются криптографически. Они обеспечивают более высокий уровень безопасности и часто используются в потоках аутентификации на основе OAuth 2.0.</p></td><td style="width:40.1509%;text-align:justify;"><span>Ввиду простоты, они могут считаться менее безопасными, поскольку обычно являются статичными и могут быть легко перехвачены, если не передаются по защищенным соединениям.</span></td></tr><tr><td style="width:18.0979%;text-align:justify;"><span>Сценарий использования</span></td><td style="width:42.1696%;text-align:justify;">Часто используется, когда требуется более тонкий контроль доступа и безопасность, например, при доступе к пользовательским или конфиденциальным данным.<br></td><td style="width:40.1509%;text-align:justify;"><span>Обычно используется для простой аутентификации для доступа к общедоступным или менее чувствительным API.</span></td></tr><tr><td style="width:18.0979%;">Авторизация<br></td><td style="width:42.1696%;text-align:justify;">Могут нести дополнительную информацию о разрешениях и ролях пользователя или клиента, что делает их пригодными для более сложных сценариев авторизации.<br></td><td style="width:40.1509%;text-align:justify;">Обычно используется для простой аутентификации без возможности передачи данных о конкретном пользователе.<br></td></tr><tr style="text-align:justify;"><td style="width:18.0979%;">Примеры<br></td><td style="width:42.1696%;text-align:justify;">Используется для авторизации пользователя для доступа к информации его личного профиля на платформе социальных сетей.<br></td><td style="width:40.1509%;text-align:justify;">Используется для доступа к публичному API погоды, где достаточно простого ключа.<br></td></tr></tbody></table>

# 16 HTTP, REST, API — инструменты и тестирование
## REST
REST (REpresentational State Transfer) -  это, согласно его автору (Рэю Филдингу) архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы. Этому набору правил/ограничений/рекомендаций необходимо следовать при разработке веб-приложений (в основном веб-сервисов/API).

### Назначение REST в том, чтобы придать проектируемой системе такие свойства как:
Назначение REST в том, чтобы придать проектируемой системе такие свойства как:
+ Производительность,
+ Масштабируемость,
+ Гибкость к изменениям,
+ Отказоустойчивость,
+ Простота поддержки.

### 6 принципов REST
1. Клиент-серверная архитектура
   1. масштабируемость (при необходимости выдерживать большую нагрузку мы можем поставить несколько серверов)
   2. простота поддержки (для изменения логики обработки информации на сервере вносят изменения только на сервере)
2. Stateless
   1. Преимущества:
      1. Масштабируемость сервера (если каждый запрос содержит в себе абсолютно весь контекст, необходимый для обработки, то можно, например, клонировать сервер-обработчик: вместо одного поставить десять таких, и будет абсолютно неважно, в какой из этих клонов придёт запрос и не нужна синхронизация серверов).
      2. Уменьшение времени обработки запроса
      3. Простота поддержки (в логах видно, какое сообщение приходило от клиента, какой ответ он получал и не нужна дополнительная информация о том, какое состояние хранил сервер)
      4. Возможность использовать кэширование
   2. Проблемы:
      1. Усложнение логики клиента (именно на стороне клиента нам нужно хранить всю информацию о состоянии, о допустимых действиях, о недопустимых действиях и подобных вещах).
      2. Увеличение нагрузки на сеть (нужно передавать всю информацию по сети).
3. Кэширование. Согласно этому принципу каждый ответ сервера должен иметь пометку, можно ли его кэшировать
   1. плюсы:
      1. Уменьшение количества сетевых взаимодействий.
      2. Уменьшение нагрузки на системы (не грузим их дополнительными запросами).
   2. минусы
      1. кэшированные данные могут устареть
4. Единообразие интерфейса. Hypermedia as the Engine of Application State (HATEOAS) — одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить
   1. плюс этого подхода — клиент становится очень гибким в плане изменений на сервере с точки зрения изменения допустимых действий, изменения модели данных и т.д.
   2. минус - сильное усложнение логики, в первую очередь, клиента но и на сервере тоже, потому что такие ответы нужно правильно формировать. Фактически ответственность за действия, которые совершает клиент, мы передаём на его же сторону, ослабляя контроль валидности совершаемых операций на стороне сервера.
5. Layered system. Между клиентом и сервером могут быть посредники: proxy-сервера, роутеры, балансировщики и пр. Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.
   1. Плюсы - позволяет изменять общую архитектуру без доработок на стороне клиента или сервера.
   2. Минусы:
      1. Увеличение нагрузки на сеть (больше участников и больше вызовов, чем если бы мы шли один раз от клиента до сервера напрямую).
      2. Увеличение времени получения ответа (из-за появления дополнительных участников).
6. Code on demand: сервер передаёт исходный код (на javascript) клиенту, а тот его выполняет. Это вместе с принципом HATEOAS позволяет клиенту стать гибче. Согласно Рэю Филдингу - единственное необязательное ограничение
### Модель зрелости REST-сервисов
<img src="resources/modelZrelostiRESR.png" alt="Модель зрелости REST-сервисов" width="70%"/>

#### Уровень 0
К нему относятся любые сервисы, которые в качестве транспорта используют HTTP и какой-то формат представления данных. Например, JSON over HTTP: приложение использует единый путь для отправки команд и один и тот же HTTP-глагол для совершения абсолютно любых действий с любыми объектами
#### Уровень 1
Используются разные ресурсы (разные URL), но при этом всё ещё игнорируем HTTP-глаголы
#### Уровень 2
Правильно с точки зрения спецификации HTTP-протокола используются HTTP-глаголы.

Соответствие приложения второму уровню зрелости не означает, что спроектирована REST-систему/ REST-сервис. Но в очень распространённом понимании соответствие 2-ому уровню часто называют RESTfull сервисом.

**RESTfull**-сервис — это такой сервис, который спроектирован с учётом REST-ограничений. Хотя, в целом, правильнее сервис такого уровня зрелости называть HTTP-сервисом или HTTP-API, нежели REST-API.
#### Уровень 3
Это уровень, в котором начинают использовать концепцию HATEOAS - при передаче информации, ресурсов, потребителям (клиентам) также сообщается о том, какие ещё действия необходимо совершить ресурсу, а также связи с другими ресурсами.

#### Популярные трактовки, что такое REST
На рисунке выше выделены две наиболее популярные трактовки, что такое REST:
+ REST — всё, что передаётся в виде JSON поверх HTTP (Уровень 0).
+ REST — это сервис второго уровня зрелости, то есть HTTP-API, составленное в соответствии со спецификацией HTTP-протокола. Если правильно выделяются ресурсы, правильно используются HTTP-глаголы, а также выполняются некоторые требования HTTP-протокола, то это - REST.

*У каждого свой REST*
### Ресурсы
В REST архитектуре основная концепция — это "ресурс". Ресурс — это любая информация или объект, который можно идентифицировать и к которому можно получить доступ через уникальный URL. В контексте веб-приложений, например, ресурсами могут быть:
+ Профиль пользователя: ресурс с URL /users/{user_id}.
+ Пост пользователя: ресурс с URL /posts/{post_id}.
+ Комментарий пользователя: ресурс с URL /comments/{comment_id}.
#### Операции с ресурсами
В REST архитектуре для взаимодействия с ресурсами используются стандартные HTTP-методы:
+ GET: Получить представление ресурса (например, получить данные профиля пользователя).
+ POST: Создать новый ресурс (например, создать новый пост).
+ PUT: Полностью обновить существующий ресурс (например, обновить информацию о профиле пользователя),  идемпотентный метод (выполнение одного и того же запроса PUT несколько раз приводит к одному и тому же результату)
+ PATCH: Частичное обновление ресурса (не обязательно является идемпотентным методом)
+ DELETE: Удалить ресурс (например, удалить комментарий).
#### Тестирование ресурсов
Подобно тому, как детали автомобиля (двигатель, тормоза, шины и т.д.) проверяются отдельно и в совокупности, чтобы убедиться, что автомобиль работает правильно, ресурсы в RESTful API также должны быть тщательно протестированы:
+ отдельные детали (ресурсы): Каждая деталь проверяется на соответствие ожиданиям и стандартам (например, проверка профиля пользователя, поста или комментария).
+ система в целом: Все детали (ресурсы) работают вместе, корректно взаимодействуют, состояния, переходы, обработка ошибка в системе соответствуют ожиданиям (например, проверка того, что пользователь может создавать посты и комментарии, и они правильно отображаются на его профиле).
#### Примеры тестирования
1. Тестирование отдельных ресурсов: Каждый ресурс нужно тестировать отдельно, чтобы убедиться, что он правильно создается, обновляется, удаляется и возвращает корректные данные:
   1. Тестирование профиля пользователя:
      1. Создание нового профиля.
      2. Получение профиля по ID.
      3. Обновление профиля.
      4. Удаление профиля.
   2. Тестирование постов:
      1. Создание нового поста.
      2. Получение поста по ID.
      3. Обновление поста.
      4. Удаление поста.
   3. Тестирование комментариев:
      1. Создание нового комментария.
      2. Получение комментария по ID.
      3. Обновление комментария.
      4. Удаление комментария.
2. Тестирование системы в целом:
   1. Тестирование взаимодействий: Нужно проверять, как ресурсы взаимодействуют друг с другом. Например, когда создается новый комментарий, он должен быть правильно связан с соответствующим постом:
      1. Создание комментария для поста:
         1. Создать новый пост.
         2. Создать комментарий к этому посту.
         3. Убедиться, что комментарий правильно связан с постом и отображается при запросе комментариев для этого поста.
      2. Получение всех постов пользователя:
         1. Создать пользователя.
         2. Создать несколько постов от имени этого пользователя.
         3. Запросить список всех постов этого пользователя и убедиться, что они все правильно возвращаются.
   2. Тестирование состояния и переходов: Проверка, что ресурсы правильно изменяют свое состояние в ответ на различные операции. Например:
      1. Публикация и архивирование поста:
         1. Создать новый пост.
         2. Изменить статус поста на "опубликован" и убедиться, что он виден в списке опубликованных постов.
         3. Изменить статус поста на "архивирован" и убедиться, что он больше не виден в списке опубликованных постов, но доступен через запрос по ID.
   3. Тестирование ошибок и исключений: Убедиться, что система корректно обрабатывает ошибки, такие как попытка доступа к несуществующему ресурсу или нарушение правил валидации:
      1. Попытка получения несуществующего ресурса:
         1. Запросить профиль пользователя по несуществующему ID и убедиться, что сервер возвращает ошибку 404 (Not Found).
      2. Создание ресурса с некорректными данными:
         1. Попытаться создать нового пользователя без обязательных полей (например, без email) и убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
      3. Удаление ресурса, который связан с другими ресурсами:
         1. Создать пост с несколькими комментариями.
         2. Попытаться удалить этот пост и убедиться, что система либо удаляет все связанные комментарии (если такая логика предусмотрена), либо возвращает ошибку, указывая на наличие зависимых ресурсов.
### Форматы данных
RESTful API используют стандартные форматы данных для передачи информации между клиентом и сервером. Наиболее часто используемый формат — JSON, но также могут использоваться и другие форматы, такие как XML, YAML и т. д. Формат данных определяет структуру передаваемой информации, чтобы обе стороны знали, как правильно ее интерпретировать.
#### Тестирование форматов данных
Тестирование форматов данных включает проверку следующих аспектов:
1. Соответствие структуры данных ожидаемому формату:
   1. Убедиться, что данные содержат все необходимые поля.
   2. Убедиться, что поля имеют правильные типы данных (строки, числа, URL и т. д.).
2. Обработка различных форматов данных:
   1. Убедиться, что сервер правильно обрабатывает запросы и ответы в различных форматах данных (например, JSON и XML).
#### Примеры тестов для проверки форматов данных
1. Тестирование структуры данных:
   1. Создание пользователя:
      1. Отправить запрос на создание нового пользователя с корректным JSON-форматом.
      2. Убедиться, что ответ содержит все необходимые поля и правильные типы данных.
		```json
		{
		"name": "Alice",
		"email": "alice@example.com",
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
      3. Проверить ответ сервера:
		```json
		{
		"id": 124,
		"name": "Alice",
		"email": "alice@example.com",
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
   2. Получение профиля пользователя:
      1. Отправить запрос на получение профиля пользователя по ID.
      2. Убедиться, что ответ содержит все необходимые поля и правильные типы данных.
		```json
		{
		"id": 123,
		"name": "John Doe",
		"email": "john.doe@example.com",
		"profile_picture": "https://example.com/profiles/johndoe.jpg"
		}
		```
2. Тестирование обработки различных форматов данных:
   1. Отправка запроса в формате JSON:
      1. Отправить запрос на создание нового пользователя в формате JSON.
      2. Убедиться, что сервер правильно обрабатывает запрос и возвращает корректный ответ.
   2. Отправка запроса в формате XML:
      1. Отправить запрос на создание нового пользователя в формате XML.
      2. Убедиться, что сервер правильно обрабатывает запрос и возвращает корректный ответ.
		```json
		<user>
		<name>Alice</name>
		<email>alice@example.com</email>
		<profile_picture>https://example.com/profiles/alice.jpg</profile_picture>
		</user>
		```
      3. Проверить ответ сервера:
		```json
		<user>
		<id>124</id>
		<name>Alice</name>
		<email>alice@example.com</email>
		<profile_picture>https://example.com/profiles/alice.jpg</profile_picture>
		</user>
		```
3. Тестирование ошибок в формате данных:
   1. Отправка некорректного JSON:
      1. Отправить запрос с некорректным JSON (например, отсутствует запятая или кавычка).
      2. Убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
		```json
		{
		"name": "Alice"
		"email": "alice@example.com"
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
		```
   2. Отправка запроса с неправильным типом данных:
      1. Отправить запрос, где поле email содержит число вместо строки.
      2. Убедиться, что сервер возвращает ошибку 400 (Bad Request) с соответствующим сообщением об ошибке.
```json
		{
		"name": "Alice",
		"email": 12345,
		"profile_picture": "https://example.com/profiles/alice.jpg"
		}
```
## Тестирование REST API - POST, PUT, GET, DELETE
### Цель тестирования REST API
Цель тестирования REST API - выявление ошибок неправильной реализации методов API:
1. Нарушенная авторизация или аутентификация
2. Неправильная проверка значений свойств метода API
3. Ошибочные типы данных и, как следствие, некорректное отображение в пользовательском интерфейсе 
4. Неправильные ограничения на уровне API
5. Несоответствие между обработкой значений в API, UI и БД, например, разные типы данных для одного и того же объекта или разные границы для одного и того же значения.

Чтобы убедиться, что все эти случаи учтены, тестировщик должен принять во внимание следующее:
1. Поддерживает ли тестируемый программный интерфейс API все методы HTTP?
2. Структура запросов и ответов: какая структура корректная, какая некорректная, какие запросы и ответы вообще возможны.
3. Обязательные и необязательные параметры URL-адреса и поля тела запроса (перечень конкретных параметров и полей). И что должно прийти в ответ на запрос без обязательных данных.
4. Какие поддерживаются типы данных: символьные строки, числа, даты (значения дата-время обычно не являются источником проблем).
5. Пределы и ограничения: например, ограничение по длине имени пользователя в 121 знак. Что, если в теле запроса будет имя из 122 знаков?
6. Коды ответов: какие коды, приходящие в ответах, может получать клиент.

Первый пункт следует проверить перед началом работы, а следующие 5 пунктов выглядят немного по-разному для разных методов. Рассмотрим их на примере https://petstore.swagger.io/(opens in a new tab), отсортировав по HTTP-методам.
### Проверьте перед началом тестирования: Какие методы поддерживает тестируемый API?
Обычно используются следующие HTTP-методы:
+ POST (используется для создания изображения для питомца с заданным ID, нового питомца, обновления питомца с заданным ID, нового магазина, нового пользователя и т. д.)
+ PUT (используется только для обновления пользователя с заданным ID)
+ GET (используется для получения информации о питомце, магазине, пользователе и т. д.)
+ DELETE (используется для удаления питомца, магазина и пользователя).

Время от времени методы PUT и DELETE не используются из-за ограничений браузера и могут быть пропущены в RESTful-части. Иногда в браузере это выглядит как POST, но на уровне API преобразуется в PUT. Учитывайте эти нюансы.
### Тестирование POST/PUT
Тестирование этих методов очень похоже, разница лишь в том, что в POST мы обычно создаем новый объект, а в PUT только изменяем некоторые параметры. 
1. Протестируем POST https://petstore.swagger.io/v2/pet со следующим телом запроса:
```json
{
    "name": "doggie",
    "photoUrls": [
        "elit cillum exercitation",
        "tempor cupidatat sint aliqua"
    ],
    "id": -36071088,
    "category": {
        "id": 36135777,
        "name": "laborum elit"
    },
    "tags": [
        {
            "id": -58986065,
            "name": "id ut dolore ipsum dol"
        },
        {
            "id": -20316514,
            "name": "adipisicing nostrud"
        }
    ],
    "status": "available"
}
```
2. Структура запроса/ответа
   1. Протестируем POST с пустым JSON в BODY
   2. Протестируем POST с пустым телом.
3. Протестируем, что один и тот же объект можно изменить 2 раза. Этот тест должен корректно работать с PUT, но для POST, скорее всего, он просто создаст двух питомцев
4. Обязательные|опциональные параметры URL или поля тела запроса
   1. Попробуйте удалить некоторые обязательные параметры из тела запроса
   2. Сделать некоторые обязательные параметры пустыми
5. Какие типы данных поддерживаются
   1. В рассмотренном выше сервисе POST /pet типами данных параметров тела являются:
   + id - числовой
   + category - (id - числовое значение, название - строка)
   + name - строка
   + photoUrls - строка в специальном формате
   + tags - (id - числовое значение, имя - строка)
   + status - список предопределенных строк
   2. Попробуйте изменить значение ожидаемого типа на другое (например, дать строку вместо числового и т.д.)
6. Границы и ограничения
   1. Выполняют последовательное тестирование каждого из параметров, для чего необходимо использовать стандартные техники тестирования различных типов данных. 
   2. Для проверки параметра имени нужно создать:
   + Питомца с именем из одной буквы
   + Питомца с именем максимальной длины (если мы ее не знаем, то используем ограничение на тип string).
   + Питомец с пустым именем
   + Питомца со специальными символами в имени.
   3. Для тестирования параметра-список (например, photoUrls) использовать принципы тестирования списков. Создать:
   + Только один элемент списка (<string>)
   + Несколько элементов списка
   + Пустой список
   4. Проверить правильность самого URL и создать объекты, у которых он есть:
   + Правильный формат URL
   + Неправильный формат URL
   + Пустая строка вместо URL
   + URL максимальной длины
   + URL минимальной длины
   + URL, содержащий символы Unicode, например https://mentorpiece.ru/%d0%be%d0%b1%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5%d1%82%d0%b5%d1%81%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8e/
   5. И т.д.
7. Коды ответов
   1. Повторить описанные выше эксперименты, обращая особое внимание на коды ответов:
      1. Объект создан - код ответа 201
      2. Обязательные параметры пусты - это может быть код ответа 400 или 200, а значения назначены по умолчанию

*!!!Внимание JSON должен быть валидным, иначе будет ошибка от валидатора, а не от тестируемой системы.*
### Тестирование GET
Прежде чем приступить к тестированию ```GET https://petstore.swagger.io/v2/pet/:petId```, необходимо подготовить тестовые данные, содержащие нужные нам значения. Для этого требуется либо база данных (если она доступна и разрешена операция INSERT), либо метод POST, создающий соответствующий объект. Таким образом проверяется как корректность метода POST или PUT (если GET не выводит созданный объект, то, очевидно, что-то пошло не так), так и корректность самого метода GET (выведет ли он, например, животное без статуса?).
1. Структура запроса/ответа
   1. На примере GET /pet/{petId}:
   + проверить действительный ли идентификатор питомца (как мы сделали с идентификатором питомца = 1)?
   + проверить несуществующий ID питомца? Попробуйте сделать это с идентификатором питомца = 234343.
   + пропустить идентификатор (GET /pet - без идентификатора).
   + задать вместо ID не число?
   + проверить Id = 0
2. Обязательные|опциональные параметры URL или поля тела запроса
   1. В GET /pet/{petId} параметр Id является обязательным. Попробуйте запустить GET без ID /pet/{petId}.
3. Какие типы данных поддерживаются
   1. Тип данных ID здесь Integer (ожидается числовое значение). Попробуйте вместо этого задать строку. GET /pet/wrwerw
4. Границы и ограничения
   1. Проверить максимальный и минимальный ID
5. Коды ответов
   1. Повторить описанные выше эксперименты, обращая особое внимание на коды ответов.
   + Проверить действительный идентификатор питомца - код ответа 200
   + Проверить несуществующий ID питомца - код ответа 404 (Питомец не найден)
   + Пропустить идентификатор. Код ответа - ?
   + ID выглядит не как число. Код ответа - ?
   + Id был равен 0 - код ответа 404 (Pet not found).
### Тестирование DELETE
1. Проверив, как GET обрабатывает каждый из созданных объектов, можно удалить его с помощью метода ```DELETE https://petstore.swagger.io/v2/pet/:petId.```.
2. Перед тестированием необходимо подготовить тестовые данные, содержащие нужные значения. Для этого требуется либо база данных (если она доступна и разрешена операция INSERT), либо метод POST, создающий соответствующий объект.
3. Структура запроса/ответа
   1. проверить действительный идентификатор питомца
   2. проверить несуществующий ID питомца.
   3. пропустить идентификатор.
   4. задать не число в качестве ID
   5. проверить Id = 0?
4. Обязательные|опциональные параметры URL или поля тела запроса
   1. В DELETE /pet/{petId} параметр Id является обязательным. Попробовать запустить DELETE без параметра: DELETE /pet/.
5. Какие типы данных поддерживаются
   1. Тип данных ID здесь Integer (ожидается числовое значение). Попробовать вместо этого задать строку. DELETE /pet/wrwerw
6. Границы и ограничения
   1. Кроме исследования вокруг конкретного значения, попробовать удалить объект с максимальным и минимальным идентификатором.
   2. Удалите один и тот же объект 2 раза. Во второй раз должна быть получена ошибка.
7. Коды ответов
   1. Повторить описанные выше эксперименты, обращая особое внимание на коды ответов.
      1. проверить действительный идентификатор питомца - код ответа 200
      2. проверить несуществующий ID питомца - код ответа 404 (Питомец не найден)
      3. пропустить идентификатор? (DELETE /pet - без ID)
      4. заменить ID на не число
      5. попробовать Id = 0 - код ответа 404 (Pet not found).
### Вывод
1. В результате должен получиться следующий позитивный сценарий:
   1. POST (создать объект) --> GET (получить информацию о созданном объекте) --> PUT (изменить характеристики объекта) --> GET (убедиться, что характеристики изменились) --> DELETE (удалить объект) --> GET (убедиться, что объект был удален).
2. Негативные сценарии генерируются на основе предложенных выше тестов и их комбинаций.
## Инструменты работы с API
### curl 
[cURL](#curl) можно использовать для тестирования REST-методов.
### [OpenAPI](#openapi) 
### [Swagger](#swagger) 
Главное удобство этого инструмента заключается в том, что разработчик или тестировщик может выполнить любой описанный метод.

Пример: 
+ https://catfact.ninja/
+ https://petstore.swagger.io/
### Boomerang (Chrome)
Плагин позволяет тестировщику применять разные методы HTTP, указывать URL назначения, определять заголовки запросов, содержимое тела и т. д. Также есть возможность импортировать запросы из файла и сохранять запросы для дальнейшего использования

Его аналог в Firefox - RESTED
### Postman
+ Postman — это инструмент для разработки и тестирования API (интерфейсов прикладного программирования). Позволяет создавать, тестировать и документировать API, а также автоматизировать тестирование и мониторинг.
+ Postman предоставляет удобный интерфейс для создания коллекций запросов, добавления тестов, управления окружениями и выполнения запросов к API. 
+ Postman позволяет импортировать спецификации API, такие как OpenAPI, и генерировать коллекции запросов на их основе.
+ Postman поддерживает интеграцию с инструментами CI/CD, такими как Jenkins и Newman.
+ Postman поддерживает как [веб-версия](https://web.postman.co/), так и версия для [десктопов](https://www.postman.com/downloads/).
#### Простые действия Postman
+ отправлять запросы;
+ сохранять запросы для последующего использования;
+ организовывать запросы в коллекции;
+ сохранять ответы в качестве примеров;
+ импортировать/экспортировать запросы или коллекции;
**+ создавать коллекции запросов путем импорта документации в формате OpenAPI (Swagger), RAML, WSDL или других форматов;**
+ использовать различные виды серверной аутентификации;
+ проводить некоторую автоматизацию тестирования.
#### Работа с коллекциями Postman
Основная идея - пакетная (совместная) обработка всех методов:
+ импорт и экспорт их в один файл
+ обмен коллекциями с коллегами
+ документирование API
+ автоматизация работы Postman
+ форк коллекции (т.е. отделение версии).
#### Postman: Переменные
Переменные в коллекциях Postman используются для упрощения и улучшения управления запросами и их параметрами. Они помогают сделать API-запросы более гибкими, повторяемыми и легко изменяемыми. Вот основные назначения и преимущества использования переменных в коллекциях:
##### Назначение переменных
1. Динамическое управление параметрами запросов
Переменные позволяют динамически изменять параметры запросов, такие как URL, заголовки, параметры пути, параметры строки запроса и тело запроса. Это делает запросы более гибкими и уменьшает количество дублирующегося кода. ```GET {{base_url}}/api/v1/pets``` - В данном примере {{base_url}} является переменной, которую можно легко изменить для переключения между разными окружениями (например, разработка, тестирование, продакшн).
2. Управление окружениями
Использование переменных коллекций в сочетании с переменными окружения позволяет легко переключаться между различными окружениями, не изменяя сами запросы. Например, вы можете создать разные окружения для разработки, тестирования и продакшн, каждое из которых имеет свои значения переменных.
3. Безопасное хранение чувствительных данных
Переменные могут использоваться для безопасного хранения и использования конфиденциальной информации, такой как ключи API, токены доступа и пароли. Эти данные можно хранить в переменных окружения, что позволяет избежать их жесткого кодирования в запросах. ```Authorization: Bearer {{api_token}}```
4. Автоматизация тестов
Переменные могут использоваться для хранения значений, полученных из ответов предыдущих запросов, что позволяет создавать сложные сценарии тестирования и автоматизировать их выполнение. ```pm.environment.set("user_id", pm.response.json().id);```
5. Переменные для тела запроса
В теле запросов можно использовать переменные для параметров, значения которых могут изменяться.
```json
{
    "name": "{{pet_name}}",
    "status": "{{pet_status}}"
}
```
##### Типы переменных в Postman
1. Глобальные переменные (Global Variables): Доступны во всех коллекциях и запросах Workspace-а.
2. Переменные окружения (Environment Variables): Доступны только в определенном окружении. Полезны для переключения между различными настройками окружений (например, разработка, тестирование). Для смены окружения программно: ```pm.environment.setName("Production");```
3. Переменные коллекции (Collection Variables): Доступны только в рамках определенной коллекции. Полезны для значений, которые используются во всей коллекции, но не зависят от окружения.
4. Переменные запроса (Local Variables): Доступны только в рамках одного запроса или его тестов. Они временные и существуют только в течение выполнения одного запроса.
##### Приоритизация выбора Postman значений переменных
Postman использует определенный порядок разрешения переменных переменных, когда встречает конструкцию вида ```{{variable_name}}```:
1. Local Variables (Локальные переменные): Локальные переменные задаются и используются внутри одного запроса или его тестов. Они имеют наивысший приоритет и существуют только в течение выполнения одного запроса. ```pm.variables.set("variable_name", "value");```
2. Data Variables (Переменные данных): Переменные данных предоставляются при запуске коллекции с использованием Collection Runner или Newman. Эти переменные задаются в CSV или JSON файлах, используемых для параметризации тестов.
3. Collection Variables (Переменные коллекции): Переменные коллекции доступны во всех запросах, входящих в данную коллекцию. Они используются для значений, которые применяются во всей коллекции. ```pm.collectionVariables.set("variable_name", "value");```
4. Environment Variables (Переменные окружения): Переменные окружения задаются для определенного окружения (например, разработка, тестирование, продакшн). Они позволяют изменять значения переменных в зависимости от выбранного окружения. ```pm.environment.set("variable_name", "value");```
5. Global Variables (Глобальные переменные): Глобальные переменные доступны во всех коллекциях и запросах в Postman. Они имеют наименьший приоритет и используются, если переменная не найдена в других контекстах. ```pm.globals.set("variable_name", "value");```
#### Postman: Автоматизация
В Postman можно настраивать выполняющиеся скрипты и **автоматически проверять ответы методов**. Существуют специальные шаблоны, называемые сниппетами, позволяющие использовать заранее написанный код для часто повторяющихся операций и проверок.
##### Chai
Chai - это библиотека утверждений BDD / TDD для node и браузера, которая может быть прекрасно сопряжена с любым фреймворком тестирования javascript. В контексте Postman Chai можно использовать для написания и выполнения тестовых сценариев в коллекциях запросов. Chai поддерживает три основных стиля утверждений:
1. **expect**: Этот стиль является наиболее современным и перспективным стилем. Он использует конструкцию "ожидания". 
   1. Утверждения в стиле expect выглядят как естественный язык и легко читаются, что делает код тестов более понятным. (```pm.expect()...```)
   2. Его синтаксис поддерживает продвинутые конструкции, такие как асинхронные тесты и сложные проверки.
   3. expect предоставляет мощный и гибкий интерфейс для создания цепочек утверждений, что позволяет писать более сложные и точные проверки.
   4. Стиль expect де-факто стандарт  в сообществе JavaScript-разработчиков благодаря читабельности и выразительности. Широко используется в современной документации и примерах, что облегчает обучение и использование и хорошо сочетается с современными фреймворками и библиотеками для тестирования, такими как Mocha и Jest.
   ```javascript
   // Пример 1: Проверка равенства значений
   pm.test("Value should be 10", function () {
      let value = 10;
      pm.expect(value).to.equal(10);
   });

   // Пример 2: Проверка типа данных
   pm.test("String should be of type string", function () {
      let str = 'Hello, world!';
      pm.expect(str).to.be.a('string');
   });

   // Пример 3: Проверка свойств объекта
   pm.test("Object should have properties name and age", function () {
      let obj = { name: 'John', age: 30 };
      pm.expect(obj).to.have.property('name');
      pm.expect(obj.name).to.be.a('string');
      pm.expect(obj).to.have.property('age');
      pm.expect(obj.age).to.be.a('number');
   });

   // Пример 4: Проверка массивов
   pm.test("Array should include 2 and have length of 3", function () {
      let arr = [1, 2, 3];
      pm.expect(arr).to.include(2);
      pm.expect(arr).to.have.lengthOf(3);
   });
   ```
2. should: Этот стиль предоставляет синтаксис, похожий на естественный язык, с использованием ключевого слова "должно". Стиль should добавляет методы утверждения к объектам JavaScript, что позволяет писать утверждения в стиле "должно быть". Обратите внимание, что необходимо вызвать require('chai').should() в начале теста, чтобы инициализировать стиль should.
   ```javascript
   pm.test("Initialize should style", function () {
      pm.expect(pm.response).to.be.an('object');
      require('chai').should();
   });

   pm.test("Value should be 10", function () {
      let value = 10;
      value.should.equal(10);
   });

   pm.test("String should be of type string", function () {
      let str = 'Hello, world!';
      str.should.be.a('string');
   });

   pm.test("Object should have properties name and age", function () {
      let obj = { name: 'John', age: 30 };
      obj.should.have.property('name');
      obj.name.should.be.a('string');
      obj.should.have.property('age');
      obj.age.should.be.a('number');
   });

   pm.test("Array should include 2 and have length of 3", function () {
      let arr = [1, 2, 3];
      arr.should.include(2);
      arr.should.have.lengthOf(3);
   });
   ```
3. **assert**: Стиль assert предоставляет более традиционный способ написания утверждений с использованием методов assert из библиотеки Chai. Этот стиль подходит для тех, кто предпочитает более явное и часто использование методов утверждения. Он не требует инициализации и может использоваться напрямую.
   ```javascript
   const assert = require('chai').assert;

   pm.test("Value should be 10", function () {
      let value = 10;
      assert.equal(value, 10, "Value is 10");
   });

   pm.test("String should be of type string", function () {
      let str = 'Hello, world!';
      assert.typeOf(str, 'string', "String is of type string");
   });

   pm.test("Object should have properties name and age", function () {
      let obj = { name: 'John', age: 30 };
      assert.property(obj, 'name', "Object has property 'name'");
      assert.typeOf(obj.name, 'string', "Property 'name' is of type string");
      assert.property(obj, 'age', "Object has property 'age'");
      assert.typeOf(obj.age, 'number', "Property 'age' is of type number");
   });

   pm.test("Array should include 2 and have length of 3", function () {
      let arr = [1, 2, 3];
      assert.include(arr, 2, "Array includes 2");
      assert.lengthOf(arr, 3, "Array has length of 3");
   });
   ```
##### Snippets
Snippets (фрагменты кода) в Postman  представляют собой готовые шаблоны кода, которые помогают пользователям быстро писать тесты и скрипты. Эти шаблоны могут быть вставлены в тестовые или предпрограммные (pre-request) сценарии и значительно упрощают создание тестов и автоматизацию взаимодействий с API. Например:
  1. Проверка того, что код (статус) ответа равен 200:
      ```javascript
      pm.test("Status code is 200", function () {
         pm.response.to.have.status(200);
      });
      ```
   2. Вывод в консоль: 
      ```javascript
      console.log("After setting:");
      ```
   3. Получить переменную окружения: 
      ```javascript
      pm.environment.get("variable_key");
      ```
   4. Отправить запрос:
      ```javascript
      pm.sendRequest("https://postman-echo.com/get", function (err, response) {
         console.log(response.json());
      });
      ```
   5. Тело ответа содержит строку:
      ```javascript
      pm.test("Body matches string", function () {
         pm.expect(pm.response.text()).to.include("string_you_want_to_search");
      });
      ```
   6. Тело ответа: JSON содержит значение:
      ```javascript
      pm.test("Your test name", function () {
         var jsonData = pm.response.json();
         pm.expect(jsonData.value).to.eql(100);
      });
      ```
   7. В заголовке ответа есть заголовок "Content-Type"
      ```javascript
      pm.test("Content-Type is present", function () {
         pm.response.to.have.header("Content-Type");
      });
      ```
   8. Время ответа меньше 200 мс
      ```javascript
      pm.test("Response time is less than 200ms", function () {
         pm.expect(pm.response.responseTime).to.be.below(200);
      });
      ```
   9.  Код ответа один из...
         ```javascript
         pm.test("Successful POST request", function () {
            pm.expect(pm.response.code).to.be.oneOf([201, 202]);
         });
         ```
   10. Валидация JSON схемы в Postman. Внимание, предполагается, что нам известна JSON схема, которая описывает ожидаемую структуру и типы данных. В примере - это ```const schema = {...```:
         ```javascript
         const schema = {
            "type": "object",
            "properties": {
               "id": { "type": "integer" },
               "name": { "type": "string" },
               "email": { "type": "string", "format": "email" }
            },
            "required": ["id", "name", "email"]
         };

         pm.test("Validate response against JSON Schema", function() {
            pm.response.to.have.jsonSchema(schema);
         });         
         ```   
   11. Конвертировать xml в JSON:
         ```javascript
         var jsonObject = xml2Json(responseBody);
         ```
   12. Конструкция pm.variables.replaceIn() используется в Postman для замены переменных в строке их значениями. Это особенно полезно, когда вы хотите использовать встроенные функции генерации случайных данных или значения переменных окружения и коллекции.:
         ```javascript
         const randomEmail = `${pm.variables.replaceIn('{{$randomUserName}}')}@example.com`;
         ```
#### Postman: Отчеты/Newman
Newman - это инструмент командной строки для запуска и тестирования коллекций Postman. Он позволяет автоматизировать процесс тестирования API и интегрировать его в CI/CD пайплайн (Jenkins, Travis CI, GitLab CI).
1. Предварительное условие - должен стоять Node.js, - среда выполнения JavaScript, которая позволяет запускать JavaScript код за пределами веб-браузера. Она основана на движке Chrome V8, который является быстрым и эффективным движком JavaScript, разработанным Google для браузера Chrome.
2. Установка newman: набрать в командной строке (выполнять от Администратора): ```npm install -g newman```
3. Формирование отчета newman: набрать в командной строке: ```newman run C:\Users\ISV\Desktop\dummyapi.io.postman_collection.json```
4. Если дополнительно установить newman-reporter-htmlextra — расширения для инструмента командной строки Newman, - то будут предоставлены дополнительные функции и улучшения в сравнении с стандартным HTML-репортером (красиво оформленные интерактивные HTML-отчеты о выполнении коллекций тестов, предоставляется дополнительная информация о запросах и ответах, включая тела запросов и ответов, HTTP-статусы, времена выполнения и прочие метрики): ```newman run C:\Users\ISV\Desktop\dummyapi.io.postman_collection.json --reporters htmlextra --reporter-htmlextra-export "C:\Users\ISV\Documents"```

!!! Внимание, в примерах 1 и 7 
[МИНИ-КУРС POSTMAN (API TESTING) от Alex QA](https://www.youtube.com/playlist?list=PLfFgJJ14Z4ZGX5ZCTqR75iLehomRfrO2e)

# 17 Веб-интерфейс пользователя
## Типы пользовательского интерфейса
+ GUI (Graphical User Interface — графический интерфейс пользователя).
+ CLI (Command Line Interface — интерфейс командной строки): текстовый интерфейс.
+ Menu Driven (Интерфейс на основе меню) — этот тип предоставляет списки вариантов на выбор. Такой интерфейс используется, например, в банкоматах. 
+ Form based (Интерфейс на основе форм) — с его помощью пользователь может ввести данные, используя ограниченный набор вариантов. С помощью такого интерфейса, например, выполняется настройка профиля.
+ Touch (Сенсорный интерфейс) — во множестве смартфонов и планшетов для работы пользователя с устройством используются прикосновения к экрану.
+ Voice (Голосовой) — смартфоны, дистанционное управление телевизорами и прочее можно усовершенствовать с помощью голосовых технологий.

Веб-интерфейс - GUI, Menu Driven и Form based интерфейсы.
## Как работает веб-страница
<img src="resources/frontend-backend_NOPROCESS_.png" alt="Архитектура клиент-сервер" width="50%"/>

Архитектура клиент-сервер. Архитектура веб-страницы может быть разной (автономной, микросервисной, бессерверной и т. д.), но наиболее типичный рабочий процесс выглядит следующим образом:
+ Клиент вводит URL-адрес в браузер. 
+ Браузер отправляет запрос в DNS для определения IP-адреса
+ Затем браузер запрашивает у сервера данные и способ отображения страницы.
+ Сервер посылает запрос к хранилищам данных (к базе данных для получения запрошенных данных и к файловой системе для получения дополнительных файлов, описывающих внешний вид страницы) 
+ Если все в порядке, сервер отвечает браузеру запрошенными данными. 
+ На фронтенде отображаются данные и нужный пользовательский интерфейс.
## Компоненты веб-интерфейса
+ HTML
+ CSS
+ JavaScript (JS)
## Макеты (Мокапы, Mockups)
+ Дизайнеры используют прототипы, созданные в специальных программах, так называемых макетах. Суть у всех программ одна: нарисовать прототип страницы и указать на какие-либо числовые значения, размеры, высоту, длину, цвета (в шестнадцатеричных кодах) и т.д.
  + [Figma](https://www.figma.com/) - онлайн-сервис для разработки интерфейсов и прототипирования с возможностью организации совместной работы в режиме реального времени. Сервис доступен по подписке, предусмотрен бесплатный тарифный план для одного пользователя. Имеются офлайн-версии для Windows, macOS
  + [Nicepage](https://nicepage.com/) — простой в использовании конструктор веб-сайтов с функцией перетаскивания, позволяющий создавать профессиональные веб-сайты с использованием высококачественных шаблонов, которые помогут вам развивать свой бизнес.. 
+ Идея тестирования на основе макетов заключается в том, чтобы сравнить элементы, изображенные на прототипе, с реальными элементами страницы, а значения свойств элементов, которые могут встречаться в прототипах, с реальными значениями. Чтобы быть уверенным в абсолютной корректности страницы, необходимо использовать HTML и CSS.
## Тестирование веб-интерфейса: 
### Основные дефекты HTML/CSS
#### Неработающие ссылки
1. Причина: опечатки, удаление ресурсов (внешняя ссылка вела на файл в Интернете, который был удален или перемещен), удаление или перемещение страниц, смена доменных имен без настройки редиректа. 
2. Как локализовать
   1. Использование онлайн-инструментов. Существуют различные онлайн-сервисы, которые позволяют сканировать ваш сайт или документ на наличие битых ссылок:
      1. [Broken Link Checker](https://ahrefs.com/broken-link-checker).
      2. [Dead Link Checker](https://www.deadlinkchecker.com/).
      3. [W3C Link Checker](https://validator.w3.org/checklink).
   2. Использование расширений для браузеров
      1. Check My Links (для Google Chrome).
      2. LinkChecker (для Firefox).
   3. Использование командной строки
      1. С помощью команды ```wget```:
         1. Преимущества
            1. Простота: ```wget``` предоставляет возможность проверки всех ссылок на странице (и на страницах, на которые они ссылаются) с минимальной настройкой.
            2. Рекурсивность: С помощью параметра ```-r``` можно легко проверять ссылки на нескольких уровнях вложенности.
            3. Лог-файл: ```wget``` может записывать подробные логи, которые можно анализировать с помощью ```grep```.
         2. Недостатки:
            1. Избыточные данные: ```wget``` может собирать больше информации, чем нужно, что может замедлить процесс проверки при большом количестве ссылок.
            2. Меньший контроль над отдельными запросами: С ```wget``` сложнее настраивать параметры для каждого запроса (например, тайм-ауты или специфические заголовки).
         3. Пример:			
			```console
			wget --spider -r -nd -nv -H -l 1 -w 1 -o wget.log http://example.com
			grep -B 2 '404 Not Found' wget.log
			```
      		+ ```--spider```: Инструмент ```wget``` действует как "паук" (spider), проверяя доступность ссылок, но не загружая их содержимое.
      		+ ```-r```: Рекурсивный режим. wget будет следовать ссылкам и проверять их.
      		+ ```-nd```: Не создавать директории.
      		+ ```-nv```: Небольшой вывод (не слишком подробный).
      		+ ```-H```: Следовать ссылкам на другие хосты.
      		+ ```-l 1```: Ограничить глубину рекурсии до одного уровня (проверить только ссылки на данной странице и ссылки с первой страницы).
      		+ ```-w 1```: Ждать одну секунду между запросами.
      		+ ```-o wget.log```: Записать вывод в лог-файл wget.log.
      2. С помощью команды ```curl```:
         1. Преимущества
            1. Гибкость: ```curl``` предоставляет больше контроля над отдельными запросами, включая настройку заголовков, методы HTTP, тайм-ауты и т.д.
            2. Легковесность: ```curl``` позволяет проверять ссылки без лишних данных, что может быть быстрее при обработке большого числа ссылок.
            3. Программируемость: Скрипты с использованием ```curl``` легко интегрируются в более сложные сценарии проверки и анализа.
         2. Недостатки:
            1. Сложность: Требуется больше кода и усилий для рекурсивной проверки всех ссылок на странице.
            2. Нет встроенной рекурсивности: curl не поддерживает рекурсивную проверку ссылок, поэтому вам нужно реализовать её самостоятельно.
         3. Пример:
            1. Шаг 1: Создайте скрипт на ```Bash``` для проверки ссылок
               1. Создайте файл скрипта check_links_in_html.sh:
				```console
				#!/bin/bash

				# Файл с HTML-контентом
				HTML_FILE="page.html"

				# Проверка, существует ли файл с HTML-контентом
				if [[ ! -f "$HTML_FILE" ]]; then
				echo "Файл $HTML_FILE не найден!"
				exit 1
				fi

				# Функция для проверки статуса URL
				check_url() {
				local url=$1
				local status_code=$(curl -o /dev/null -s -w "%{http_code}\n" "$url")

				if [[ "$status_code" -ne 200 ]]; then
					echo "Битая ссылка: $url (Статус: $status_code)"
				else
					echo "Ссылка работает: $url (Статус: $status_code)"
				fi
				}

				# Извлечение URL из HTML и проверка каждой ссылки
				grep -oP '(?<=href=")[^"]*' "$HTML_FILE" | while IFS= read -r url; do
				check_url "$url"
				done
				```
            2. Шаг 2: Сделайте скрипт исполняемым и запустите его
               1. Сохраните скрипт в файл, например check_links_in_html.sh.
               2. Сделайте файл исполняемым: ```chmod +x check_links_in_html.sh```
               3. Запустите скрипт: ```./check_links_in_html.sh```
            3. Ожидаемый результат: Скрипт будет извлекать все URL-адреса, указанные в атрибутах href тэгов ```<a>``` в файле page.html, и проверять их
   4. Использование скриптов на Python
   5. Ручная проверка: Иногда может потребоваться вручную проверить ссылки, особенно если их немного. Просто перейдите по каждой ссылке и убедитесь, что она работает.
   6. Автоматизация в CI/CD: Если вы используете систему непрерывной интеграции (CI/CD), вы можете добавить проверку ссылок в ваш pipeline, используя вышеупомянутые инструменты.
3. Исправление битых ссылок:
   1. Обновить ссылку, если ресурс переместился на новый URL.
   2. Удалить ссылку, если ресурс больше не доступен и нет замены.
   3. Использовать веб-архив, такой как [Wayback Machine](https://wayback-api.archive.org/) (с англ. - «Машина времени» - бесплатный онлайн-архив некоммерческой библиотеки «Архив Интернета». С помощью поисковых роботов Wayback Machine архивирует и делает общедоступной бо́льшую часть «открытого» интернета), чтобы найти копию старого ресурса.
#### Кросс-браузерные проблемы
1. Причина:
   1. Различия в движках рендеринга браузеров (например, Blink в Chrome, Gecko в Firefox, WebKit в Safari) обусловленные их неполной поддержкой стандартов, различными интерпретациями этих стандартов, разные CSS-префиксы (некоторые CSS-свойства могут требовать вендорные префиксы -webkit- для WebKit, -moz- для Mozilla и т.д.) могут приводить к различиям в том, как страница отображается.
   2. Ошибки в реализации браузера: Иногда браузеры могут содержать ошибки в их реализации, что приводит к неправильному отображению или поведению веб-страниц.
2. Как локализовать
   1. Тестирование в разных браузерах и устройствах: Для обнаружения кросс-браузерных проблем важно тестировать свой сайт или приложение на различных браузерах (Chrome, Firefox, Safari, Edge, Opera) и на различных устройствах (настольные ПК, ноутбуки, планшеты, мобильные устройства).
   2. Использование инструментов для проверки совместимости, которые позволяют тестировать веб-сайты на различных браузерах и устройствах без необходимости установки каждого браузера отдельно:
      1. [BrowserStack](https://www.browserstack.com/) - платное
      2. [Sauce Labs](https://saucelabs.com/) - платное.
   3. Анализ отчетов и логов: Если кросс-браузерная проблема возникает только в определенных сценариях или на определенных страницах, полезно анализировать отчеты и логи, чтобы понять, какие именно части кода или стили вызывают проблемы.
#### Проблемы Responsive design (отзывчивого дизайна)
Responsive design - концепция и практика, которая фокусируется на создании веб-сайтов, которые адаптируются к различным размерам экранов (мобильные устройства, планшеты, настольные ПК) без потери функциональности и пользовательского опыта. Решения в этой области часто включают использование медиа-запросов, гибкой сетки и адаптивных изображений для обеспечения оптимального отображения на различных устройствах. Риски здесь связаны с трудностями одновременно добиться удобства использования и навигации на разных устройствах без потери функциональности и эстетики.
1. Причина: 
   1. Проблемы, связанные с различными разрешениями или экранами (если разработчик использует неправильный фреймворк для веб-страницы и не адаптирует видео и изображения к Responsive design, веб-страница будет выглядит некрасиво при определенных параметрах экрана).
   2. Некорректное определение или применение медиа-запросов в CSS (механизм, который позволяет адаптировать стили веб-страницы в зависимости от различных характеристик устройства, таких как ширина экрана, тип устройства, разрешение экрана и другие параметры. Они позволяют создавать адаптивный дизайн, который оптимально отображается на различных устройствах и в различных условиях просмотра) может привести к непредсказуемому отображению на различных устройствах. Пример медиа-запроса:
      1. Пример простого медиа-запроса для стандартного устройства с разрешением до 600px:
         ```css
         @media (max-width: 600px) {
         /* Стили, применяемые только если ширина экрана <= 600px */
         body {
            font-size: 14px;
         }
         }
         ```
      2. Пример условия медиа-запросов с включенными различными характеристиками устройств, такими как width (ширина экрана), height (высота экрана), orientation (ориентация устройства), resolution (разрешение экрана) и другие.
         ```css
         /* Применение стилей для устройств с шириной экрана от 768px до 1024px */
         @media (min-width: 768px) and (max-width: 1024px) { 
         /* Стили */
         }

         /* Применение стилей для печати */
         @media print {
         /* Стили */
         }
         ```
   3. Неоптимизированные изображения, скрипты или стили могут существенно замедлить загрузку страницы на мобильных устройствах.
   4. Игнорирование UX/UI принципов
2. Как локализовать: Принцип тот же, что и при кросс-браузерном тестировании. Проверьте внешний вид веб-страницы при разных разрешениях экрана и на разных типах экранов. Особенно это важно для мобильных приложений, которые должны работать на разных устройствах, мобильных телефонах и планшетах.
### Локализация дефектов с помощью объектов DOM-дерева
#### Document Object Model
DOM (Document Object Model) - это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы. По существу, DOM соединяет веб-страницу с языками описания сценариев либо языками программирования..
<img src="resources/DOM_NOPROCESS_.png" alt="Абстрактная схема DOM-дерева" width="50%"/>

Схема DOM-дерева:
+ Объект окна: Window Object - это объект браузера, который всегда находится на вершине иерархии.  Это API, который используется для установки и доступа ко всем свойствам и методам браузера. Он автоматически создается браузером.
+ Объект документа: Когда HTML-документ загружается в окно, он становится объектом документа. Объект document имеет различные свойства, которые ссылаются на другие объекты, позволяющие получать доступ к содержимому веб-страницы и изменять его. Если необходимо получить доступ к какому-либо элементу HTML-страницы, мы всегда начинаем с обращения к объекту document. Объект document является свойством объекта window.
+ Объект формы: Он представлен тегами формы.
+ Объект ссылки: Он представлен тегами ссылок.
+ Объект Anchor: Он представлен тегами ```<a href>```.
+ Элементы управления формой: Форма может содержать множество элементов управления, таких как текстовые поля, кнопки, радиокнопки, флажки и т.д.
#### DevTools - инструмент для локализации проблем с помощью DOM-дерева
##### Назначение DevTools:
+ Инспекция и редактирование HTML/CSS (панель "Elements")
+ Отладка JavaScript
  + Вкладка "Console" позволяет выполнять JavaScript-код в реальном времени, выводить сообщения для отладки, и анализировать ошибки и предупреждения
  + Вкладка "Sources" позволяет устанавливать точки останова (breakpoints) в коде, чтобы остановить выполнение скриптов на определенной строке
+ Анализ производительности
  + Вкладка "Performance" позволяет анализировать сколько времени занимает загрузка, рендеринг и выполнение скриптов
  + Вкладка "Network" показывает все HTTP-запросы, которые отправляются и получаются браузером (статусы, заголовки и время выполнения запросов).
+ Эмуляция устройств и медиа-запросов
  + В панели DevTools вы можете включить режим эмуляции устройства (иконка мобильного устройства в верхней части панели).
  + В режиме эмуляции устройства вы также можете симулировать различные условия сети (например, медленный 3G), чтобы проверить, как ваша страница работает при различных скоростях интернет-соединения.
+ Аудит и анализ доступности
  + Вкладка "Lighthouse" позволяет проводить аудит вашей страницы на предмет производительности, доступности, SEO и лучших практик
##### Шаги локализации дефектов с помощью DOM-дерева
1. Открытие DevTools и вкладки Elements (Элементы):
   1. Откройте веб-страницу в браузере и запустите DevTools (обычно нажатием F12 или правой кнопкой мыши -> "Inspect" или "Инспектировать").
   2. Перейдите на вкладку "Elements" (или "Элементы"), чтобы увидеть DOM-дерево.
2. Поиск нужного элемента:
   1. Найдите элемент на странице, который вызывает проблемы. Вы можете использовать инструмент выделения (иконка курсора в верхнем левом углу DevTools), чтобы выбрать элемент на странице и автоматически найти его в DOM-дереве.
   2. Это поможет вам быстро локализовать нужный элемент в структуре DOM.
3. Инспекция и анализ:
   1. Посмотрите на структуру и атрибуты выбранного элемента в панели "Elements". Убедитесь, что HTML и CSS корректны и соответствуют ожидаемому поведению.
   2. Проверьте наличие ошибок в разметке, таких как отсутствующие или неправильно вложенные теги, неправильно заданные атрибуты или некорректные CSS-классы.
4. Изменение и тестирование в реальном времени:
   1. Вносите изменения в HTML или CSS прямо в DevTools и наблюдайте за результатами в реальном времени. Например, вы можете изменить стиль элемента, добавить или удалить атрибуты, изменить текстовое содержание и сразу увидеть эффект на странице.
5. Использование консоли для отладки JavaScript:
   1. Если проблема связана с поведением элемента, вы можете использовать вкладку "Console" (Консоль) для выполнения JavaScript-кода в реальном времени.
   2. Вы можете вывести информацию о состоянии элемента, использовать команды для изменения его свойств или вызвать функции, связанные с этим элементом, чтобы понять, как они работают.
6. Просмотр событий и слушателей событий:
   1. В DevTools вы можете увидеть все события, связанные с выбранным элементом, и слушатели событий, которые на него назначены.
   2. Это полезно для отладки проблем с интерактивностью и поведением элемента на странице.
7. Анализ стилей и вычисленных стилей:
   1. На панели "Elements" вы также можете увидеть стили, примененные к элементу, и вычисленные стили, которые показывают итоговые значения всех CSS-свойств.
   2. Это помогает понять, какие стили влияют на элемент и как они комбинируются.
8. Проверка ошибок в консоли:
   1. Проверьте вкладку "Console" на наличие ошибок и предупреждений, которые могут указывать на проблемы с выбранным элементом или его поведением.
   2. Ошибки JavaScript или проблемы с загрузкой ресурсов могут влиять на работу и отображение элементов.
##### Примеры использования DevTools локализации дефектов с помощью DOM-дерева
1. Исправление неверного отображения элемента:
   1. Проблема: Элемент отображается неправильно или не на своем месте.
   2. Действие: Используйте DevTools для инспекции элемента. Проверьте стили (CSS) и измените их, чтобы увидеть, какие из них вызывают проблему. Исправьте HTML или CSS, чтобы элемент отображался корректно
2. Исправление проблем с интерактивностью:
   1. Проблема: Кнопка не работает при нажатии.
   2. Действие: Проверьте, назначены ли на кнопку события. Используйте консоль для выполнения JavaScript-функций, связанных с кнопкой, и проверьте, вызываются ли они. Исправьте ошибки в коде, если функции не работают должным образом.
3. Исправление ошибок в структуре HTML:
   1. Проблема: Неправильная структура HTML, из-за чего элементы отображаются некорректно.
   2. Действие: Используйте DevTools для инспекции DOM-дерева. Найдите неправильно вложенные теги или отсутствующие элементы. Внесите исправления в HTML, чтобы структура была правильной.
### Основные дефекты JS (которые может выявить тестирование методом "черного ящика")
#### Проблемы с валидацией
1. Отсутствие валидации на стороне клиента может привести к серьезным проблемам на уровнях API и БД, когда недействительные некорректные значения сохраняются и передаются на более глубокие уровни программы. Симптомами отсутствия валидации являются отсутствие сообщений об ошибках, отсутствие ограничений на поля ввода и отсутствие четкого понимания поддерживаемых типов ввода. 
2. Локализация проблемы с валидацией:
   1. Наряду с наблюдением за симптомами, нужно проверить JS-скрипты, запускаемые при вводе пользователем значения в поле. Скрипт должен проверить значение, подтвердить его и выдать сообщение.
   2. Если сообщение о проверке отображается, не забудьте проверить, соответствует ли оно документации. Даже если смысл не потерян, сообщение, не соответствующее ожидаемому, может быть расценено как дефект.
#### Проблемы с производительностью
1. Большие файлы, слишком большое количество запросов или неправильная архитектура уровня представления могут вызвать проблемы с производительностью, когда страница загружается слишком долго.
2. Локализация проблемы с производительностью:
   1. Если есть подозрение, что страница загружается слишком долго, проверить, какие ресурсы используются и сколько скриптов запущено. Даже функциональные тестировщики могут зарегистрировать такие дефекты и помочь команде избежать проблем с производительностью.
#### Проблемы безопасности
Проблемы безопасности с JS - это так называемые проблемы XSS (Cross-Site Scripting), и они будут подробно рассмотрены в главе о нефункциональном тестировании.

# 18 Веб-интерфейс пользователя — инструменты и тестирование
## Проблемы при тестировании веб-приложений делятся на следующие группы:
+ Элементы интерфейса располагаются в неправильных местах или отображаются некорректно
+ Некорректная работа или полный отказ логики программного клиента
+ Размер и (или) расположение элементов интерфейса сильно зависит от разрешения экрана
+ Приложение работает по-разному в разных веб-браузерах
+ Данные пользователя могут влиять на работу приложения (файлы cookie, локальное веб-хранилище)
+ Проблемы с сетевым соединением могут нарушить работу веб-интерфейса пользователя.
+ Нарушение логики взаимодействия между клиентом и сервером
## Набор инструментов DevTools
### Набор инструментов DevTools
+ Elements (элементы)
+ Console (консоль)
+ Sources (исходные файлы)
+ Network (сеть)
+ Application
+ Lighthouse
#### Elements (элементы)
Время от времени возникает необходимость проверить внешний вид пользовательского интерфейса с другой конфигурацией или с другими элементами, которые уже были добавлены в макеты, но не в тестовую среду. Проверка того, как будут выглядеть эти новые элементы, может помочь оценить правильность гипотезы, предложенной членами вашей команды:
+ на вкладке отображается исходный код HTML страницы в формате DOM
+ на вкладке присутствует указатель для быстрой навигации по дереву.
+ можно редактировать представление DOM: изменять атрибуты элементов, добавлять или удалять элементы и т. д. 
+ на вложенной вкладке Styles можно посмотреть весь применяемый код CSS. Отдельные настройки стиля можно включать, выключать и редактировать
+ можно изменять разрешения экрана, что упрощает такие задачи, как когда нужно выяснить, что произойдёт, если открыть приложение на мобильном устройстве
#### Console (консоль)
1. На вкладке Console есть возможность выполнять код JavaScript.
2. На вкладке Console показаны записи журнала JavaScript (предупреждения, сообщения об ошибках и другие). Записи журнала появляются
   1. если автор кода JavaScript предусмотрел такую возможность (обычно это делается с помощью методов объекта console: console.log(), console.warn(), console.error(), console.info()).
   2. Если во время выполнения кода JavaScript происходит исключение (ошибка), и это исключение не было обработано разработчиком с помощью конструкций try...catch, оно также будет отображено на вкладке Console. В противном случае на вкладке Console сообщения не появятся.
#### Sources (источники данных)
Вкладка Sources похожа на оглавление. В ней отображаются исходные файлы, составляющие веб-страницу. Файлы могут быть следующие: HTML, JavaScript, CSS, изображения и т. д. Есть возможность просматривать исходные файлы и сохранять их для дальнейшего изучения.
#### Network (сеть)
1. На этой вкладке регистрируется сетевая активность (запросы и ответы).
   1. Можно скопировать запрос и самостоятельно повторно отправить его. Например, выполнив Copy -> Copy as cURL и вставив скопированный текст в окно терминала можно выполнить его с помощью cURL. 
   2. На вкладке также показано время выполнения запроса, таким образом, можно обнаружить медленную работу сетевого соединения.
2. На этой вкладке можно изменять скорость связи по сети (дросселирование), чтобы тестировщик мог исследовать работу приложения в условиях «плохого Интернета»
#### Application
##### Cookies (куки) и Cache (кэш)
+ Cookies и Cache нужны для хранения некоторых данных о сайте и пользователе в специальном хранилище на клиенте. 
+ **Кэш** - это специальное хранилище, в котором сайт может сохранять данные (изображения, стили и т. д.), чтобы не загружать их каждый раз. Физически это часть памяти (память быстрого доступа, RAM), куда сайт может обратиться, чтобы получить эти сохраненные ресурсы. 
+ В **cookies** хранится информация о сеансе пользователя (например, сохраненный логин, предпочтения пользователя и т. д.). Сайт отправляет cookie с информацией о пользователе на сервер, а когда пользователь возвращается, сервер отправляет cookie обратно, и у пользователя сохраняется логин, введенный в поле входа, и товар, добавленный в корзину интернет-магазина.
+ Таким образом, основное отличие заключается в том, что в кэше хранятся данные сайта, а в куках - информация о сессии пользователя.
##### Очистка файлов cookie и кэш
Перед проведением большинства тестов полезно очистить куки и кэш (выполнить на вкладке Application -> Storage-> [Clear site data]):
+ Иногда куки и кэш могут вызывать проблемы на сайте. Если была развернута новая версия вашего приложения и изменена информация о сайте, вы не можете увидеть ее в локальном браузере, если сайт читал эти ресурсы из кэша. Таким образом, вы видите неправильную версию, и чтобы исправить это, нужно очистить кэш.
+ То же самое с файлами cookie. Информация о пользователе, сохраненная в cookies, может быть устаревшей (например, пароль был изменен или товар из корзины вашего интернет-магазина больше не существует в БД). Это может привести к проблемам и ложноотрицательным результатам тестирования. 
##### Редактирование локальных данных
На вкладке Application в пункте меню "Storage" пользователь может просматривать и редактировать данные, хранящиеся локально, а также cookies. Например можно изменить региональные настройки на лету или для изменения времени истечения срока файлов cookie, чтобы не пришлось ждать много дней.
## Прокси-серверы
Прокси-сервер (Proxy server) — это инструмент, исполняющий роль шлюза между сервером и клиентом. Все запросы и ответы проходят через прокси-сервер, поэтому можно отслеживать и изменять на лету всё, что отправляется и принимается.

Тестировщику такой «посредник» даёт возможность изучать обмен данными и, например, имитировать недопустимый ответ сервера.

<img src="resources/proxy.png" alt="Схема работы прокси-сервера" width="80%"/>

### Примеры прокси-серверов
+ Charles
+ Fiddler
+ Postman

Для веб-приложений много информации можно получить из DevTools, но это сложно, если клиент веб-мобильный, и невозможно, если клиент - нативное мобильное приложение. В этом случае тестировщик не может анализировать трафик без прокси-сервера. 

### Функции прокси-сервера для тестирования веб-приложений
#### Перехват трафика между веб-приложением и Интернетом. 
Необходим для лучшего понимания работы приложения и локализации дефектов, описанных в главе о веб-интерфейсе приложений. 
#### Посмотреть, какие вызовы API идут и есть ли ошибки (как это можно сделать с помощью Network в DevTools).
Необходим для определения того, какой вызов API был отправлен и потенциально мог привести к ошибке на уровне представления. 
#### Поддержка SSL и HTTPS
Используется для перехвата не только HTTP-запросов, но и HTTPS, защищенных SSL-сертификатами. 
#### Может использоваться в качестве симулятора медленного интернет-соединения.
Необходима для тестирования производительности (в данной главе не рассматривается).
### Postman как прокси-сервер
Должна быть установлена десктопная версия Postman (веб-версия не поддерживает функциональность прокси-сервера). 

На рисунке ниже показано, как Postman работает в качестве прокси-сервера:
<img src="resources/Postman_work_NOPROCESS_.png" alt="Postman в качестве прокси-сервера" width="80%"/>

#### Настройка Postman как прокси-сервера для перехвата HTTP-запросы, исходящие от мобильного приложения
1. Экспорт корневого сертификата Postman
   1. Postman использует встроенный сертификат для перехвата HTTPS-трафика. Чтобы экспорировать и установить этот сертификат, выполните следующие шаги:
      1. Найти корневой сертификат Postman. Postman хранит корневой сертификат по умолчанию в своем каталоге данных. На вашем компьютере, найдите этот файл:
         1. Windows: C:\Users\<ваш_пользователь>\AppData\Roaming\Postman\proxy
         2. macOS: ~/Library/Application Support/Postman/proxy
         3. Linux: ~/.config/Postman/proxy
      2. Файл корневого сертификата будет иметь имя rootCA.pem.
2. Установка корневого сертификата на мобильное устройство
   1. Перенос сертификата:
      1. Перенесите файл rootCA.pem на ваше мобильное устройство с помощью USB, электронной почты или облачного хранилища.
   2. Установка сертификата:
      1. Откройте настройки вашего мобильного устройства.
      2. Найдите раздел "Безопасность" или "Экран блокировки и безопасность" (зависит от устройства).
      3. Выберите "Установить с хранилища" или "Установить сертификат" и найдите файл rootCA.pem.
      4. Следуйте инструкциям для установки сертификата.
3. Установка корневого сертификата в браузере Chrome
   1. Импорт сертификата:
      1. Откройте настройки Chrome.
      2. Прокрутите вниз и нажмите "Дополнительно".
      3. В разделе "Конфиденциальность и безопасность" выберите "Управление сертификатами".
      4. На вкладке "Доверенные корневые центры сертификации" нажмите "Импорт" и выберите rootCA.pem.
      5. Следуйте инструкциям мастера для завершения импорта.
4. Настройка прокси на мобильном устройстве
   1. Настройка Wi-Fi:
      1. Подключите мобильное устройство к той же Wi-Fi сети, что и ваш компьютер.
      2. Откройте настройки Wi-Fi и выберите активную сеть.
      3. В настройках сети выберите "Прокси" и установите его в "Ручной".
      4. Введите IP-адрес вашего компьютера и порт прокси, который вы настроили в Postman (например, 5555).
5. Запуск прокси-сервера в Postman
   1. Включение прокси:
      1. Откройте Postman.
      2. Перейдите в настройки (значок шестеренки) и выберите "Proxy".
      3. Включите опцию "Capture HTTPS traffic" и укажите порт (например, 5555).
6. Перехват запросов
   1. Запуск перехвата:
      1. В Postman откройте вкладку "Capture Requests" и начните захват.
      2. Отправьте запрос с мобильного устройства и проверьте, что запросы отображаются в Postman.
7. Следуя этим шагам, вы сможете настроить перехват HTTPS-запросов с мобильного устройства с использованием Postman.
#### Настройка Postman как прокси-сервера для перехвата HTTP-запросы, исходящие от браузера
Чтобы перехватывать HTTPS-запросы, установите расширение Postman Interceptor Extention для вашего браузера.
### Charles прокси
Charles Web Debugging Proxy - это кроссплатформенное приложение HTTP отладочного прокси-сервера, написанное на Java. Он позволяет пользователю просматривать трафик HTTP, HTTPS, HTTP/2 и разрешенный трафик TCP-портов, передаваемый с локального компьютера, на него или через него. Сюда входят запросы и ответы, включая HTTP-заголовки и метаданные (например, cookies, информация о кэшировании и кодировке), а также функциональность, направленная на помощь разработчикам в анализе соединений и обмена сообщениями.
### Сравнительная характеристика Charles и Postman в части проксирования 
<table>
    <tr>
        <th>Функциональность</th>
        <th>Postman</th>
        <th>Charles</th>
    </tr>
    <tr>
        <td>Проксирование</td>
        <td>Да, базовое</td>
        <td>Да, мощное и гибкое</td>
    </tr>
    <tr>
        <td>Модификация трафика</td>
        <td>Ограниченные возможности</td>
        <td>Широкие возможности модификации "на лету"</td>
    </tr>
    <tr>
        <td>SSL-проксирование</td>
        <td>Да, но требует установки сертификатов</td>
        <td>Да, с глубокой поддержкой и анализом</td>
    </tr>
    <tr>
        <td>Интерфейс</td>
        <td>Интуитивный, удобный</td>
        <td>Более сложный для новичков</td>
    </tr>
    <tr>
        <td>Анализ трафика</td>
        <td>Ограниченный</td>
        <td>Мощные инструменты для детального анализа</td>
    </tr>
    <tr>
        <td>Эмуляция медленных соединений</td>
        <td>Нет</td>
        <td>Да</td>
    </tr>
    <tr>
        <td>Интеграция с API</td>
        <td>Отлично подходит для тестирования и разработки</td>
        <td>Ограниченные возможности</td>
    </tr>
    <tr>
        <td>Совместная работа</td>
        <td>Поддержка совместного использования коллекций</td>
        <td>Нет встроенных возможностей для совместной работы</td>
    </tr>
    <tr>
        <td>Легкость освоения</td>
        <td>Легко освоить</td>
        <td>Может быть сложно для новичков</td>
    </tr>
</table>

## Инструменты для создания снимков экрана
В настоящее время существует множество таких средств, и нет необходимости описывать конкретное из них. Поэтому далее перечислены основные функции, которые должны быть предусмотрены в хорошем инструменте:
1. Создание снимка всего экрана.
2. Создание снимка окна.
3. Создание снимка выбранной области — это одна из наиболее часто используемых функций.
4. Прокрутка веб-страницы при создании снимка экрана. Некоторые страницы очень длинные, поэтому придётся прокручивать их вниз, чтобы добраться до нижней части
5. Добавление текста, заметок, стрелок поверх снимка экрана.

# 19 Архитектура серверного ПО
## 2-звенная архитектура
Большая часть современного ПО поддерживает работу с сетями и может работать как клиент или сервер, а порой выполнять и обе роли.

<img src="resources/client_server_side.png" alt="2-звенная архитектура" width="80%"/>

Серверная часть 2-звенного приложения взаимодействует только с:
+ Клиентами, подключающимися по сети
+ Операционной системой

Если клиентское и серверное приложения установлены на один и тот же хост - общение друг с другом осуществляется через виртуальный интерфейс `loopback` с IP-адресом `127.0.0.1`. Весь трафик, ищущий через этот интерфейс, остается внутри хоста и никогда не выходит во внешние сети.

Вне зависимости от архитектуры серверного приложения (2-х и более звенного) взаимодействие "клиент-сервер" может иметь вид "человек-машина" или "машина-машина". Это зависит от конкретных приложений и даже сценариев использования
### С точки зрения ОС серверные приложения работают со следующими объектами:
1. Файлы: хранение настроек, чтение / запись данных по запросу от пользователей, и т.п.
2. Сокеты: для открытия серверных портов на прослушивание с целью приема запросов от пользователей
3. Процессы: процесс-родитель может запустить дочерние процессы для обработки пользовательских запросов.
### С точки зрения сети, серверные приложения общаются с клиентами с помощью
1. Протоколов прикладного уровня, например HTTP, SMTP, POP3
2. Протоколов транспортного уровня типа TCP или UDP
### С точки зрения пользователя, нужно знать следующее:
1. Адрес сервера, порт и транспортный протокол.
2. Прикладной протокол для общения с сервером.
3. Имя и пароль (или такие учётные данные, как сертификат), если для работы с системой требуется вход и проверка подлинности.
### Примеры 2-звенных серверных приложений:
1. Файловые серверы.
2. FTP-серверы (похожи на файловые, но работают по другому прикладному протоколу).
3. Службы удаленного управления, например SSH и Remote Desktop.
4. Серверы баз данных (можно считать таковыми в простых случаях). Однако в более сложных конфигурациях, например с репликацией с ведущими и ведомыми серверами или распределённым хранилищем, базы данных являются N-звенными серверными приложениями.
### Возможные проблемы 2-звенных серверных приложений <a id=2chaineproblems></a>
#### На уровне операционной системы
ОС и ее настройки - наиболее частые причины возникновения проблем в 2-звенных серверных приложениях.
1. Отсутствующие объекты файловой системы: файлы, каталоги, символьные ссылки…
   1. Если кто-нибудь переместит или удалит их или отключит файловую систему, содержащую необходимые объекты, то приложение может даже не запуститься.
2. Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
   1. Если прав недостаточно, то приложение не сможет получить доступ к этим объектам.
   2. Если же для конфиденциальных файлов (например, содержащих учётные данные) или директорий настроены слишком широкие права, то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.
3. Некорректно настроенные права пользователя для запуска приложения
   1. Например: некоторые приложения не допускают запуск со стороны администратора (root), другие же, наоборот, для запуска требуют права администратора или участие в определённой группе.
4. Ошибочная настройка самого приложения, например: неверный формат файла настройки, указана неподдерживаемая или конфликтующая опция настройки, и т.п.
5. Конфликты, связанные с портами.
   1. Если нужный порт уже используется другим процессом, то приложение не сможет запуститься.
6. Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.
7. Нехватка оперативной памяти: в случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить работу некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.
8. Новые нестабильные компоненты либо конфликтующие компоненты, появившиеся в окружении (обновления ОС, сторонние программные компоненты).
9. Что-либо иное, например временные файлы, оставшиеся от предыдущего аварийного завершения работы приложения.

**PS** *Высокая загрузка центрального процессора или системы ввода-вывода (диски, сеть) не может в большинстве случаев привести к остановке приложения, но наверняка замедлит его работу.*
#### На уровне сети
На уровне сети доступу пользователя к серверному приложению могут помешать:
1. Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.
2. Проблемы, связанные с системой DNS, когда пользователь обращается к серверу посредством полного доменного имени.
3. Межсетевой экран, блокирующий прохождение пакетов (может быть настроен на любом узле: клиент, сервер, маршрутизатор между ними).
4. Перегруженные сегменты сети на стороне клиента или сервера.
#### Проблемы на стороне клиента
1. Неподдерживаемый тип или версия клиентского приложения.
   1. Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.
2. Неподдерживаемое или некорректное действие пользователя.
3. Некоторое ПО, обеспечивающее безопасность, препятствует работе пользователя с сервером.
4. Какие-либо настройки клиентского ПО мешают работе конкретно с этим сервером.
5. Если на сервере необходимо залогиниться, пользователь может ввести неверное имя учетной записи или пароль.
6. Пользователю запрещено что-либо делать на этом сервере.
## 3-звенные приложения
1. Уровень представления (`Presentation Layer`, `Frontend`) включает пользовательские интерфейсы (UI), такие как веб-страницы, мобильные приложения или десктопные приложения:
   + **Отвечает** за взаимодействие с пользователем.
   + **Выполняет** — отображение данных пользователю и обработка ввода пользователя.
2. Уровень логики приложения или уровень бизнес-логики(`Application Logic Layer`, `Backend`, `Business Logic Layer`) является отдельным приложением, написанным на PHP, Java, Python, Node.js или другом языке:
   + **Отвечает** за обработку бизнес-логики приложения.
   + **Выполняет** обработку данных, вычисления, обработку логики принятия решений, управление транзакциями.
   + **Взаимодействует** как с уровнем представления, так и с уровнем данных, но не напрямую с пользователем.
3. Уровень данных (`Data Layer`) обычно является базой данных (NoSQL и реляционной: MySQL, PostgreSQL, Oracle, MS SQL) или другими системами хранения данных:
   + **Отвечает** за хранение, управление и доступ к данным.
   + **Выполняет** операции с данными, такие как запросы, обновления, удаления и их чтение, и предоставляет данные для уровня логики приложения.

<img src="resources/3-tier.png" alt="3-звенная архитектура" width="80%"/>

### Различия между 2-х и 3-звенными приложениями:
1. Несколько серверных приложения вместо одного.
2. Эти серверные приложения можно развернуть на отдельных узлах, связанных через сеть.
   1. При необходимости их можно установить на один компьютер — это распространённый вариант для небольших веб-порталов.
3. Каждый уровень рассматривается как отдельное приложение, для которого возможны соответствующие причины отказа [(см. выше)](#2chaineproblems).
4. У баз данных (БД) могут быть свои собственные точки отказа, описанные ниже.
   1. Второе звено (`Application Logic Layer`, `Backend`, `Business Logic Layer`) подключается к СУБД и проходит проверку подлинности, используя своё отдельное имя пользователя и пароль (или сертификат), указанные в файлах конфигурации, — то есть оно действует как клиент БД. Поэтому оно одновременно исполняет роль сервера для `Presentation Layer`, и клиента для БД (`Data Layer`)
   2. Непосредственно БД недоступна для конечного пользователя, поскольку, во-первых, в этом нет необходимости, а во-вторых, в БД могут содержаться конфиденциальные данные других пользователей, и для таких данных нужна максимально возможная защита. По этой причине с БД должно работать только приложение верхнего уровня.
### Примеры 3-звенных приложений:
+ Большинство интернет-форумов и CMS типа WordPress. Для небольших веб-сайтов оба компонента часто устанавливают на одном хосте.
+ Многие онлайн-игры: игровой клиент отвечает за UI-часть, а сервер производит анализ данных, вычисления, защиту от ботов, а также взаимодействует с СУБД.
+ Сложные серверы электронной почты.
### Возможные проблемы 3-звенных приложени
Каждый из трёх компонентов 3-звенных приложений может столкнуться с проблемами, характерными для 2-звенных приложений [(см. выше)](#2chaineproblems). Ниже приведены дополнительные риски, вызванные усложнением архитектуры:
#### Проблемы на сетевом уровне (подключение верхнего звена к нижнему)
1. Связь между любыми двумя компонентами 3-звенных приложений может нарушиться из-за проблем с маршрутизацией, DNS, межсетевыми экранами *(однако чаще всего они устанавливаются на одном узле или находятся в одной локальной сети)*.
2. Связь между вторым звеном (`Application Logic Layer`, `Backend`, `Business Logic Layer`) и БД (`Data Layer`)может также нарушиться из-за неправильной конфигурации приложения, взаимодействующего с СУБД, например: IP-адрес или полное доменное имя сервера БД, некорректные учётные данные для подключения к БД, неверное название БД и т. д.
#### Проблемы на уровне БД (`Data Layer`)
1. Учётные записи СУБД, применяемые вышестоящим уровнем, могут быть заблокированы.
2. Их пароли могут быть изменены без соответствующей перенастройки приложения верхнего уровня.
3. Права пользователей в отношении приложения верхнего уровня могут быть изменены или аннулированы, и необходимые данные тогда станут недоступны для чтения и (или) записи.
4. Согласованность данных может быть нарушена, например, когда соответствующие таблицы или записи изменяются другими средствами (представьте, что администратор БД допустил ошибку).
### Преимущества 3-х звенной архитектуры перед 2-звенной:
+ Поддержка "тонких клиентов", как следствие - проще поддерживать весь спектр клиентских устройств 
+ Более простая поддержка серверных частей приложения. *Когда нужно лишь немного поправить интерфейс пользователя, то это не затрагивает остальные компоненты.*
+ Большая масштабируемость. *По мере роста компании можно добавлять новые серверы на каждом звене, особенно когда применяется балансировка нагрузки.*
+ Большая защищенность (фильтрация данных от пользователя, не пропуская SQL-инъекции и пр)

<img src="resources/3-tier_balancer.png" alt="Схема 3-звенного корпоративного приложения" width="80%"/>

*Для приложений, работающих с высокой нагрузкой, часто применяются балансировщики нагрузки, которые распределяют входящие запросы между соединёнными серверами, так чтобы каждый новый пользователь направлялся к определённому серверу.*

### Виды клиентского ПО:
#### "Тонкий клиент"
Задача "тонкого клиента" (например, браузера) - отобразить интерфейс, полученный от сервера, и дать пользователю возможность что-то туда ввести: 
1. "Тонкий клиент" чаще всего не умеют работать в оффлайн-режиме.
2. "Тонкие клиенты" гораздо проще в реализации, что дает возможность сравнительно легко поддержать множество видов клиентских устройств и операционных систем.
#### "Толстый клиент"
"Толстый клиент" - приложения с функциональностью гораздо большей, чем может быть реализовано в "тонком клиенте".
1. "Толстый клиент" не является универсальным (как браузер) и умеет работать только с определенной серверной частью, всего по одному или нескольким прикладным протоколам.
2. Классические примеры:  клиенты онлайн-игр, почтовые клиенты (MS Outlook, Mozilla Thunderbird). Что касается последних: доступ к почте можно получить и через браузер (применив "тонкий клиент") или с помощью Outlook / Thunderbird ("толстый клиент").

*Чаще оказывается проще и дешевле создать более сложное 3-звенное серверное приложение с поддержкой множества тонких клиентов, чем иметь 2-звенное серверное приложение и разрабатывать соответствующие "толстые" клиенты для каждого типа клиентских узлов и ОС.*

В зависимости от архитектуры И клиентского, И серверного ПО, термины "Тонкий клиент" и "Толстый клиент" могут иметь различное значение:

1. **Фронтэнд**: приложение, отвечающее за пользовательский интерфейс (UI). "Толстые клиенты" реализуют эту функциональность самостоятельно, однако "тонкие клиенты" требуют наличия серверного Фронтэнд-компонента.
2. **Бэкэнд**: часто этим словом называют ВСЮ серверную часть (независимо от количества звеньев). Однако для 3-звенной архитектуры этот термин имеет специальное более узкое значение, что поясняется ниже.

**Тестирование Фронтэнд-компонентов**: в основном включает в себя только тестирование *UI*, *usability testing*, плюс *регрессионное тестирование* - рутинными задачами, в основном связанными с пошаговым исполнением тест-кейсов.

**Тестирование Бэкэнд-компонентов**:  состоит из задач, связанных с логикой приложения, взаимодействием компонентов и обработкой данных. Часто за тестирование Бэкэнда отвечают только разработчики, что приводит к большому количеству долго живущих и сложно выявляемых багов. Поэтому, тестирование бэкэнда - отличный способ улучшить качество всего продукта.
### Защита данных 
1. Пользователи не должны иметь прямого доступа к СУБД. Хорошая практика - ограничение внешнего доступа к СУБД с помощью межсетевого экрана, разрешив его только с бэкэнд-сервера и рабочих мест администраторов БД.
2. Фронтэнд 3- и N-звенных приложений не должен иметь прямого доступа к СУБД. (Для его задач это просто не нужно).
3. Пользователи не должны иметь прямого доступа к бэкэнд N-звенных приложений (Пользователи должны работать только с компонентом фронтэнда).
## Журналы событий
**Журналирование** ("логирование") - функциональность, позволяющая отслеживать поведение и состояние приложения (как штатные операции, так и возникающие по ходу работы ПО ошибки). Назначение журналирования:
1. Идентификация проблем.
2. Поиск причины неисправности (`Root Cause Analysis`): на основе текста сообщений об ошибках, метки времени (`timestamps`) и прочей информации в журналах.
3. Создание качественных тест-кейсов: при написании тест-кейсов, особенно для серверного ПО, полезно указывать, какие события стоит ожидать в журналах при проведении той или иной операции. Такие подробности также очень сильно облегчают автоматизацию тестирования.
4. Интеграционное тестирование: понимание событий из журналов заметно упрощает интеграционное тестирование системы, состоящей из множества  взаимодействующих компонентов.
5. Мониторинг и тестирование производительности: получение метрик быстродействия производится на основании журналов событий ПО.
6. Совместная работа с техническими специалистами ПО (разработчиками, техподдержкой): повышают эффективность взаимодействия с техническими специалистами, как за счет точного определения причин возникновения багов на основе информации журналов, как и благодаря возможности получения точной информации про успешное устранение проблемы.
7. Тестирование безопасности: зачастую журналы событий ПО содержат крайне ценную информацию о различных событиях безопасности (например, вход пользователя в систему), которая не может быть получена откуда-либо еще.
### Уровни событий (log level / severity) <a id="eventslevel"></a>
Ниже приведены уровни событий стандарта системы логирования `Syslog`, используемой в `Unix`-подобных операционных системах *(Уровни событий указаны по убыванию важности)*
#### Emergency (emerg)
Уровень **Emergency** указывает на наиболее критичные события, которые означают, что система или приложение находятся в крайне нерабочем состоянии. Сообщения этого уровня свидетельствуют о фатальных проблемах, которые требуют немедленного вмешательства для восстановления нормального функционирования системы или приложения. В большинстве случаев такие события требуют незамедлительного реагирования, так как они могут привести к полной остановке или серьезному нарушению работы.
##### В операционных системах:
В Unix-подобных системах (например, Linux, BSD), уровень **Emergency** предназначен для записи чрезвычайно критичных событий, которые делают систему непригодной для использования или требуют немедленных действий:
+ Критические сбои ядра операционной системы.
+ Потерю важных системных ресурсов (например, сбой файловой системы).
+ Неустранимые ошибки в системных службах, которые приводят к остановке их работы или всей системы.

В таких случаях сообщения с уровнем Emergency обычно записываются в системные журналы (например, `/var/log/syslog` или `/var/log/messages` в Linux) и могут быть переданы на консоль администратора или даже инициировать автоматические действия (например, перезагрузку системы).
##### В программном обеспечении:
В программном обеспечении уровень **Emergency** используется для указания на критические ситуации, которые требуют немедленного внимания и действий:
+ Серверные приложения: В веб-серверах, базах данных и других критически важных серверных приложениях уровень **Emergency** используется для записи событий, которые могут привести к полному выходу из строя приложения или к непредвиденным сбоям. Например, если сервер теряет доступ к критически важным ресурсам, таким как сеть или база данных, это может быть зарегистрировано как событие **Emergency**.
+ Встроенные системы и системы реального времени (RTOS): В таких системах уровень Emergency может указывать на события, которые требуют немедленной остановки системы для предотвращения повреждения оборудования или безопасности пользователя. Например, в авионике или медицинских устройствах.
+ Бизнес-приложения и фреймворки: В корпоративных приложениях, таких как системы управления предприятием (ERP) или системы обработки транзакций (например, банковские системы), уровень **Emergency** может использоваться для сигнализации о серьезных сбоях в обработке данных или потерях данных, которые могут повлиять на бизнес-операции.
#### Alert
Уровень логирования **Alert** используется для указания на серьезные события, которые требуют немедленного внимания, но не обязательно означают, что система или приложение находятся в нерабочем состоянии. Уровень **Alert** находится чуть ниже **Emergency** и указывает на события, которые могут привести к критическим проблемам, если не будут быстро устранены. Этот уровень используется как в операционных системах, так и в программном обеспечении.
##### В операционных системах:
В операционных системах уровень **Alert** применяется для регистрации событий, которые требуют немедленного вмешательства, но не приводят к немедленному выходу системы из строя:
+ Угрозы безопасности: Например, обнаружение попыток несанкционированного доступа или использования уязвимостей.
+ Неожиданное поведение критических системных процессов: Системные демоны или службы, которые начинают работать нестабильно, но система в целом еще работает.
+ Истощение важных ресурсов: Например, нехватка свободного места на критически важном разделе диска или исчерпание оперативной памяти, что может привести к отказу работы системы, если не будет решено.

*Операционные системы могут автоматически уведомлять администратора или инициировать скрипты или процессы восстановления для устранения ситуации.*
##### В программном обеспечении:
В программном обеспечении уровень **Alert** также используется для сигнализации о событиях, которые требуют немедленного вмешательства, чтобы предотвратить потенциальные сбои или проблемы:
+ Серверные приложения: Например, если веб-сервер не может подключиться к необходимой внешней службе (например, к базе данных), это может быть зарегистрировано как событие уровня **Alert**. Сервер может продолжать работу, но без быстрого восстановления могут возникнуть более серьезные проблемы.
+ Встраиваемые системы и системы реального времени (RTOS): Если один из сенсоров обнаруживает аномальные данные, но система еще работает стабильно, это может быть зафиксировано как **Alert**. Это позволит оператору или системе принять превентивные меры.
+ Бизнес-приложения и фреймворки: Например, в финансовых приложениях событие уровня **Alert** может быть зафиксировано, если обнаружен сбой в процессе обработки платежей, что требует немедленного вмешательства, чтобы избежать нарушений обслуживания.
#### Critical (crit)
Уровень логирования **Critical** предназначен для указания на критические события, которые сильно влияют на функциональность системы или приложения, но не обязательно делают их полностью неработоспособными. Эти события требуют немедленного внимания, так как могут привести к серьезным последствиям, если не будут устранены вовремя.
##### В операционных системах:
В операционных системах уровень **Critical** используется для регистрации событий, которые серьезно нарушают работу системы, но не останавливают её полностью:
+ Серьезные сбои подсистемы: Например, сбой в работе подсистемы ввода-вывода или драйвера, что вызывает нарушение в работе определенного компонента, но не приводит к остановке всей системы.
+ Отказ критически важного сервиса или службы: Например, отказ службы DNS или DHCP, что влияет на сеть, но не полностью останавливает работу сервера.
+ Проблемы с безопасностью: Обнаружение серьезной уязвимости или инцидента безопасности, который требует немедленного исправления, чтобы предотвратить возможные атаки или утечки данных.

*События уровня **Critical** могут быть зарегистрированы в системных журналах (например, `/var/log/syslog` или `/var/log/messages` в Linux) и обычно требуют вмешательства системного администратора для устранения проблемы.*
##### В программном обеспечении:
В программном обеспечении уровень **Critical** используется для указания на события, которые серьезно нарушают работу приложения или сервиса и требуют немедленного вмешательства:
+ Отказ в критических функциях приложения: Например, в веб-приложении отказ основного компонента аутентификации или базы данных, что делает невозможным выполнение важных операций, но само приложение продолжает работать.
+ Серьезные ошибки обработки данных: Например, в приложении для финансовой отчетности ошибка в расчете, которая может привести к неверным данным, что требует немедленного исправления.
+ Нарушение целостности данных: Например, повреждение файлов или базы данных, что угрожает целостности данных и требует немедленных мер для восстановления или предотвращения потерь.
#### Error (err)
Уровень логирования **Error** используется для указания на ошибки или проблемы, которые препятствуют нормальной работе системы или приложения, но не являются фатальными. Ошибки, зарегистрированные на этом уровне, требуют внимания, поскольку они могут повлиять на функциональность, производительность или стабильность системы, но обычно не приводят к немедленному прекращению работы.
##### В операционных системах:
В операционных системах уровень **Error** используется для регистрации событий, которые указывают на сбои или проблемы, требующие внимания администратора, но не приводят к немедленному выходу системы из строя:
+ Отказ или сбой периферийного оборудования: Например, ошибка в работе драйвера принтера или сканера, которая мешает их нормальной работе, но не влияет на основные функции операционной системы.
+ Сбой при выполнении команды или процесса: Например, ошибка при запуске пользовательского процесса, который завершился с ошибкой, или сбой при загрузке модуля ядра.
+ Ошибки в файловой системе: Например, неудачное удаление файла или невозможность монтирования файловой системы, что требует вмешательства для восстановления нормальной работы.

*Эти события обычно записываются в системные журналы (например, `/var/log/syslog` в Linux или Event Viewer в Windows) и требуют вмешательства администратора для устранения проблемы.*
##### В программном обеспечении:
В программном обеспечении уровень **Error** используется для регистрации ошибок, которые препятствуют нормальному функционированию приложения или компонента, но не приводят к его полной неработоспособности:
+ Ошибки при обработке данных: Например, неудачная попытка выполнения транзакции в базе данных или ошибка парсинга данных, которая приводит к неполной обработке, но не останавливает работу всего приложения.
+ Ошибка при подключении к внешнему сервису: Например, ошибка подключения к API или внешнему серверу, что приводит к сбою в выполнении определенной функции, но не останавливает приложение.
+ Невозможность выполнения операции из-за нехватки ресурсов: Например, ошибка при попытке выделения памяти, которая приводит к сбою выполнения конкретной задачи, но не завершает работу программы.
#### Warning (warn)
Уровень логирования **Warning** используется для регистрации предупреждений о потенциальных проблемах или аномалиях, которые не являются непосредственными ошибками, но могут указывать на возможные проблемы в будущем. Сообщения уровня **Warning** сигнализируют о событиях, которые требуют внимания, но не блокируют или не нарушают текущую работу системы или приложения.
##### В операционных системах:
В операционных системах уровень **Warning** используется для регистрации событий, которые могут указывать на потенциальные проблемы, но не приводят к непосредственному сбою или нарушению работы системы:
+ Истощение ресурсов: Например, предупреждение о нехватке свободного места на диске или низком уровне свободной памяти, что может повлиять на производительность, но не вызывает немедленных сбоев.
+ Доступ к устаревшим компонентам: Например, использование устаревших или устаревающих API, что может быть исправлено в будущем обновлении.
+ Проблемы с конфигурацией: Например, предупреждение о неполной или некорректной конфигурации системного параметра, который не мешает текущей работе, но может вызвать проблемы в будущем.

*Эти предупреждения обычно записываются в системные журналы (например, `/var/log/syslog` в Linux или Event Viewer в Windows) и помогают системным администраторам предугадывать и предотвращать потенциальные проблемы.*
##### В программном обеспечении:
В программном обеспечении уровень **Warning** используется для регистрации событий, которые могут указывать на проблемы или нестабильность, но не являются критическими:
+ Предупреждения о неправильных данных: Например, если приложение получает данные в неожиданном формате, это может быть зарегистрировано как предупреждение, чтобы разработчики могли исправить формат данных.
+ Использование устаревших функций: Например, использование функций или методов, которые будут удалены в будущих версиях библиотеки или фреймворка, что сигнализирует о необходимости обновления кода.
+ Проблемы с производительностью: Например, предупреждение о снижении производительности из-за высокой нагрузки или неоптимальных операций, что требует внимания для предотвращения ухудшения производительности.
#### Notice
Уровень логирования **Notice** используется для регистрации событий, которые представляют собой информацию о значимых, но не критичных событиях в системе или приложении. Эти события не указывают на ошибки или проблемы, но могут быть полезны для мониторинга и анализа работы системы.
##### В операционных системах:
В операционных системах уровень **Notice** используется для записи информации о событиях, которые являются значимыми, но не указывают на ошибки или проблемы:
+ Изменения конфигурации: Например, успешное применение новых конфигурационных параметров или обновлений.
+ Запуск или остановка служб: Например, уведомление о запуске новой службы или успешном завершении работы службы.
+ Системные события: Например, информация о регулярных задачах, таких как выполнение плановых резервных копий или обновлений системы.

*Эти уведомления обычно записываются в системные журналы (например, `/var/log/syslog` в Linux) и предоставляют информацию, полезную для администраторов и пользователей.*
##### В программном обеспечении:
В программном обеспечении уровень **Notice** используется для регистрации значимых информационных событий, которые могут быть полезны для мониторинга или отладки, но не указывают на проблему:
+ Обновления и изменения в приложении: Например, успешное обновление или изменение состояния приложения, которое не требует немедленного вмешательства.
+ Информация о выполнении задач: Например, уведомление о завершении длительной операции или обработке данных, которая успешно выполнена.
+ Статус выполнения операций: Например, информация о том, что операция выполнена успешно, но не требует дальнейшего действия или проверки.
#### Informational (info)
Уровень логирования **Informational** используется для записи общих информационных сообщений, которые предоставляют сведения о нормальной работе системы или приложения. Эти сообщения не указывают на проблемы или ошибки, а просто документируют выполнение стандартных операций или предоставляют контекстную информацию, полезную для мониторинга и анализа.
##### В операционных системах:
В операционных системах уровень **Informational** используется для записи событий, которые являются частью нормального функционирования системы:
+ Запуск и завершение задач: Например, успешный запуск или завершение задач планировщика или служб.
+ Статус обновлений: Например, информация о выполнении обновлений системы или установке новых пакетов.
+ Информационные сообщения от системы: Например, информация о системных ресурсах, таких как загрузка процессора или использование памяти, если эти данные предоставляются для мониторинга.

*Эти сообщения обычно записываются в системные журналы (например, `/var/log/syslog` в Linux) и помогают администраторам и пользователям отслеживать обычные операции и состояние системы.*
##### В программном обеспечении:
В программном обеспечении уровень **Informational** используется для регистрации сообщений, которые предоставляют контекстуальную информацию о работе приложения, но не указывают на проблемы:
+ Информация о выполнении операций: Например, сообщение о том, что пользователь успешно вошел в систему или завершил выполнение определенной операции.
+ Статистика и метрики: Например, информация о времени выполнения задачи или объеме обработанных данных.
+ Стандартные уведомления: Например, информация о том, что приложение успешно запустилось или завершило работу без ошибок.
#### Debug
Уровень логирования **Debug** предназначен для записи подробной информации, которая используется в основном для отладки и анализа системы или приложения. Эти сообщения предоставляют детализированные данные о внутреннем состоянии и поведении системы или приложения, что может помочь разработчикам и администраторам в идентификации и устранении проблем.
##### В операционных системах:
В операционных системах уровень **Debug** используется для записи детализированных сообщений, которые могут помочь в диагностике и отладке проблем:
+ Подробные данные о процессах и задачах: Например, информация о внутреннем состоянии процессов, их потоках и ресурсах, которые они используют.
+ Информация о системных вызовах: Например, детализированные записи о системных вызовах и их результатах, что может помочь в отладке взаимодействия между приложениями и ядром операционной системы.
+ Отладочные сообщения от драйверов и модулей: Например, информация от драйверов устройств или системных модулей, которая помогает в выявлении проблем с оборудованием или взаимодействием.

*Эти сообщения часто записываются в системные журналы (например, `/var/log/syslog` в Linux), но могут быть включены только в режиме отладки или для конкретных разработческих целей.*
##### В программном обеспечении:
В программном обеспечении уровень **Debug** используется для записи информации, которая помогает разработчикам и администраторам понять внутренние процессы и поведение приложения:
+ Трассировка выполнения кода: Например, запись о входе и выходе из функций, выполнении циклов и условных операторов.
+ Значения переменных и состояния: Например, информация о значениях переменных в разные моменты времени, что помогает выявить проблемы в логике программы.
+ Пошаговое выполнение: Например, запись о каждом шаге выполнения определенных алгоритмов или операций, что позволяет детально отслеживать их выполнение.

*Примечание:*
1. Почти всегда у современного ПО есть события уровней `DEBUG` и `TRACE` (часто используется в других системах логирования и отладки, таких как `Log4j` или `SLF4J` в `Java`, где он обозначает еще более детализированные сообщения, чем `DEBUG`), которые не сохраняются в журналы при настройках по умолчанию. Их включение на продуктивных высоконагруженных системах  может привести к замедлению работы ПО и гигантским размерам журналов, однако это окажется крайне полезным при установлении причин возникновения бага.
2. `Windows` использует `Event Logs`, которые разделены на несколько категорий: `Application`, `Security, System`, и другие. Каждый из этих журналов хранит соответствующие записи о событиях с различными уровнями серьезности (`Critical`, `Error`, `Warning`, `Information`, `Verbose`).
3. `macOS` использует `Unified Logging System` (Объединенная система журналирования), которая была представлена в `macOS` `Sierra`. Уровни событий в `macOS` `Unified Logging`: `Fault`, `Error`, `Default`, `Info`, `Debug`. macO`S поддерживает логи на разных уровнях детализации, что позволяет системным администраторам и разработчикам более точно контролировать, какие сообщения записываются.
### Формат событий
Формат событий зависит от конкретного приложения, но считается хорошей практикой указывать в событиях следующие ключевые поля:
1. Метку времени (`timestamp`) - когда конкретно произошло это событие.
2. Уровень (`log level` / `severity`) - насколько это событие было важно, см. уровни [`Emergency` ... `Debug` из описания выше](#eventslevel). Помогает найти и отфильтровать нужные события в журналах.
3. Источник события - "как зовут" тот компонент, который отправил это сообщение. В сообщениях `syslog`, относящихся к работе ОС (не прикладного ПО) эту сущность обычно называют `facility` (категория). `facility` используется для классификации сообщений журнала на основе их источников или назначения. Это помогает различать сообщения, поступающие от различных компонентов системы. Вот некоторые примеры фасилити в Syslog:
   1. `kern`: сообщения от ядра
   2. `user`: сообщения от пользовательских приложений
   3. `mail`: сообщения от почтовой системы
   4. `daemon`: сообщения от системных демонов
   5. `auth`: сообщения об аутентификации и безопасности
   6. `syslog`: сообщения, сгенерированные самим демоном syslog
   7. `cron`: сообщения от планировщика задач (cron)
   8. `local0-local7`: локально определенные `facility` для пользовательских нужд
4. Сообщение: текст, описывающий суть события. Должно быть достаточно подробным для понимания теми, кому оно предназначено.
5. События могут включать в себя множество иной информации, например: ID транзакций; идентификаторы процессов ОС; имена пользователей, от лица которых была инициирована соответствующая операция; сведения о системе - как клиента (ОС, версия клиентского ПО, ...), так и сервера; текст HTTP-запросов и их заголовки; коды ответа сервера (если применимо); иные метрики.
### Место хранения журналов событий
Вся логика работы с событиями (какие из них записывать, а какие нет, куда их сохранять), специфична для каждого конкретного приложения:
1. В самом простом случае приложение может писать свои события прямо в терминал. Многие серверные приложения также можно запустить со специальными отладочными опциями командной строки для отображения событий в терминал, однако в продуктивных (НЕ тестовых) средах такое не встречается.
2. В самом часто встречаемом случае события записываются в определенный файл(-ы). Файл, чаще всего, представляет собой простой текст.
3. В более сложных случаях ПО передает свои события "под запись" компонентам операционной системы. Для Linux такими компонентами ОС могут быть:
   1. `syslog` и его разновидности. События чаще всего сохраняются в простые текстовые файлы, хотя бывают и исключения из этого правила.
   2. `journald` - подсистема журналирования сервисов `systemd`. Для получения событий применяется команда `journalctl`. Такой пример приведен ниже.
4. В самых сложных случаях события передаются в централизованное хранилище и хранятся в специальных "местах", например в отдельной базе данных.
### Что еще важно знать о журналах событий:
1. И клиентские, и серверные приложения могут писать журналы событий.
2. Приложения, как правило, позволяют настраивать уровни сообщений, которые пишутся в логи. Так, в продуктивных системах из-за проблем быстродействия и размеров логов чаще всего записываются только важные события, т.е. начиная с уровня `Notice` или даже `Warning`. В тестовых средах не редкость сохранение всех событий, т.е. начиная с `Debug`.
3. Логи подвергаются т.н. "ротации": старые файлы удаляются по прошествии какого-то времени, новые записываются. Предельный размер каждого лог-файла чаще всего можно настроить.
4. Приложение пишет свои логи в том формате, в котором считает нужным. Иногда этот формат можно настроить.
5. Как конкретно настраиваются уровень, ротация и (если возможно) формат событий, зависит от каждого конкретного приложения. Более того, в многозвенном приложении каждый его компонент может писать логи в своем формате, в свои отдельные файлы, с различными параметрами ротации. Информацию о настройках журналирования стоит выяснить у разработчиков / аналитиков / команды DevOps.
### Примеры работы с журналами событий
#### Пример 1. 
Получить ВСЕ про события некоего приложения FTB

`journalctl -u java-ftb.$USER --utc --all`, где:

+ `journalctl`: утилита для просмотра журналов и сообщений, собранных системой `systemd`.
+ `-u `: указывает на конкретный юнит (службу), логи которой вы хотите посмотреть. В данном случае это `java-ftb.$USER`, где `$USER` — переменная, которая заменяется на имя текущего пользователя.
+ `--utc`: выводит время в логах в формате UTC (координированное всемирное время).
+ `--all`: выводит все данные, включая возможные длинные строки, которые могли быть обрезаны.

Пример ответа на запрос:

<img src="resources/log-01_NOPROCESS_.png" alt="Часть событий приложения FTB" width="80%"/>

Часть событий приложения FTB

<img src="resources/log-02_NOPROCESS_.png" alt="Более поздние события приложения FTB с ошибками" width="80%"/>

Более поздние события приложения FTB с ошибками

#### Пример 2.

Далеко не всегда проблему можно установить только по сообщениям уровня WARN, ERROR или CRITICAL.

```console
boat-reskin-1    | 2023-11-29 13:02:24,239 INFO Set uid to user 0 succeeded
boat-reskin-1    | 2023-11-29 13:02:24,241 INFO supervisord started with pid 1017
boat-wtp-1       | The compiled services file has been removed.
boat-reskin-1    | 2023-11-29 13:02:25,249 INFO spawned: 'php' with pid 1019
boat-wtp-1       | 2023-11-29 13:02:25,400 INFO Set uid to user 0 succeeded
boat-wtp-1       | 2023-11-29 13:02:25,405 INFO supervisord started with pid 1049
boat-mysql-1     | 2023-11-29T13:02:25.821375Z 8 [Note] Access denied for user 'boat'@'%' to database 'reskin'
boat-mysql-1     | 2023-11-29T13:02:25.839037Z 9 [Note] Access denied for user 'boat'@'%' to database 'reskin'
```

Здесь нет ни одного сообщения уровня ERROR или выше, однако при внимательном просмотре можно обратить внимание на следующее: `Access denied for user 'boat'@'%' to database 'reskin'`. Такое событие говорит о том, что пользователь "boat" не может войти в базу данных "reskin". Возможно, это ошибка настройки СУБД. При составлении баг-репорта в него необходимо включить это сообщение.
## *Примечание. Software-инженер*
Понимание архитектуры приложений и всех сопутствующих технологий серверного ПО - одно из ключевых отличий между "типичным" тестировщиком и Software-инженером.

**Software-инженеры** хорошо понимают каждый участок разрабатываемого ПО и могут эффективно работать не только с UI. Они могут заметно улучшить существующие тест-кейсы, документацию, и качество продукта в целом.

# 20 Принципы локализации дефектов
## Первопричина (Root cause)
**Первопричина** (**Root cause**): точная причина, которая привела к возникновению ошибки. Точное определение первопричины — непростая задача, поскольку она может считаться выполненной, только когда дефект полностью исправлен. Если дефект больше не проявляется, значит, первопричина определена верно. Поэтому в большинстве случаев у тестировщика нет возможности найти первопричину, и вместо этого выполняется локализация дефекта.
## Локализация (Localization)
**Локализация** (**Localization**): процесс поиска возможной первопричины. Верно выполненная локализация кардинально сокращает время, затрачиваемое на устранение дефекта, поскольку: 
+ устранение дефекта поручается именно той команде разработчиков, которая и должна заниматься этим типом дефектов; 
+ команда получает нужную информацию и поэтому знает, что нужно сделать. 
## Поиск неисправностей (Troubleshooting)
**Поиск неисправностей**  (**Troubleshooting**): конкретные методики локализации дефектов.
## Алгоритм локализации дефектов
Выполнять шаги ниже нужно строго в заданной последовательности:
1. Декомпозируйте приложение на части
2. Предложите гипотезы о первопричинах для каждой части
3. Подберите надлежащие инструменты и методики для проверки каждой гипотезы
4. Примените эти инструменты для каждой гипотезы, чтобы отклонить или подтвердить ее. Подтверждённые гипотезы показывают возможные первопричины
### Декомпозиция
Для начала, любое клиент-серверное приложение можно разделить на три крупных компонента:
+ Узел клиента (клиентский хост): ОС (тип, версия), приложение (версия, язык, другие настройки), параметры ОС и системы (сеть, безопасность,...), интернет-провайдер (страна, пропускная способность,...), текущая нагрузка (процессор, память, диски, сеть), дополнительный софт по безопасности;
+ Узел сервера (серверный хост): Серверное приложение (процессы, сервисы, открытые порты, логи), конфигурация ОС (сетевые настройки, межсетевой экран,...), текущая нагрузка (процессор, память, диск, сеть), архитектура приложения (standalone, 2-звенное, 3-звенное), если не standalone - как взаимодействует со следующим компонентом
+ Сеть между ними: доступность (роутинг), межсетевой экран, DNS. Учетные записи пользователей
#### Источник идей для декомпозиции (по убыванию):
+ Документация продукта;
+ лица, хорошо знающим ПО (аналитики, разработчики, DevOps-инженеры, администраторы и др)
+ общий здравый смысл, ваши технические навыки и опыт
### Гипотезы
#### Гипотезы для стороны клиента
Приблизительный список вопросов для выработки гипотез *(курсивом пример гипотезы)*:
1. Какие события зафиксированы в журналах приложения?
2. Что сделал пользователь?:
   1. *Изучить журналы приложения*
   2. *Выполнить сбор сетевого трафика, чтобы изучить запросы и ответы.*
3. Какое клиентское ПО используется? *Оно может быть неподдерживаемым.*
4. Как сконфигурировано клиентское ПО? *Его настройки могут конфликтовать с серверным приложением.*:
   1. *Изучить настройки клиентского приложения и сравните их с настройками сервера (если они доступны)*
   2. *Попытаться выполнить сбор сетевых пакетов и поискать конфликты, связанные с протоколами прикладного уровня*.
5. Какая используется операционная система на стороне клиента? *Она также может оказаться неподдерживаемой.*
6. Какая учётная запись пользователя используется для подключения? *Может быть, что-то не так с этой учётной записью, например пароль с истёкшим сроком действия или недостаточно прав для доступа к этому файлу.*
7. Что насчёт свободного дискового пространства? *Может быть, файл слишком большой для сохранения, и клиентское ПО не может записать его на диск или даже не пытается скачать его.*
8. Может быть, какое-либо системное ПО препятствует этой операции? *Нередко ПО, предназначенное для защиты, например антивирус, блокирует обычные операции.*
#### Гипотезы для сети
Компонент сети также можно разделить на несколько следующих частей:
+ Сегмент на стороне клиента, в т.ч. интернет-провайдер.
+ Сегмент на стороне сервера, в т.ч. каким образом сервер подключён к Интернету.
+ Промежуточный сегмент - сеть между клиентом и сервером

Приблизительный список вопросов для выработки гипотез:
1. Сервер недостижим со стороны клиента, хотя обе стороны подключены к сети.
2. FQDN (доменное имя) сервера некорректно преобразуется в IP-адрес.
3. Серверное приложение скрыто за межсетевым экраном.
4. На стороне узла клиента и (или) узла сервера возникли проблемы с сетевыми интерфейсами (неподсоединённые кабели, слишком слабый сигнал Wi-Fi, неисправные устройства, сбой драйверов).
5. Узел клиента и (или) узел сервера отключены от Интернета из-за неоплаты.
6. Интернет-провайдер клиента, или сервера, или единственный связывающий элемент между ними потеряли соединение из-за обрыва кабеля или другой аварийной ситуации.
#### Гипотезы для стороны сервера
Приблизительный список вопросов для выработки гипотез:
1. Сам сервер как узел целиком (физический, виртуальный - неважно) выключен.
2. Серверное ПО остановлено по какой-либо причине.
3. Серверное ПО попыталось запуститься, но потерпело неудачу из-за проблем с окружением, например следующих:
   1. Конфликты, связанные с портами, когда кто-то другой уже занял нужный порт.
   2. Временные файлы (особенно так называемые файлы блокировки) препятствуют запуску.
   3. Другие проблемы, связанные, возможно, с нештатным завершением работы приложения.
4. Серверное ПО работает нормально, но его настройки не позволяют этому пользователю получить доступ к запрашиваемому файлу.
5. Серверное ПО работает нормально, но не может получить доступ к запрашиваемому файлу из-за некорректно настроенных прав доступа к файлу.
6. Некоторое ПО, обеспечивающее безопасность, которое установлено на сервере, нарушает нормальную работу.
7. Запрашиваемый файл отсутствует, но либо клиентское, либо серверное ПО не может обработать эту ситуацию и не сообщает об этом пользователю.
### Инструменты и методики
1. Перед тем как приступать к запуску каких-либо инструментов, команд или проверкам, необходимо сначала перечислить гипотезы и только после этого применять конкретные инструменты и методики.
2. Если клиентская или серверная части не полностью нами контролируются, то мы будет ограничены в выполнении на них определённых проверок, некоторые инструменты и методики окажутся неприменимы.
#### Инструменты
<table>
	<thead>
		<tr>
			<th>Инструмент / команда</th>
			<th>Описание</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<code>df</code>
			</td>
			<td>свободное дисковое пространство</td>
		</tr>
		<tr>
			<td><code>top</code>, <code>iostat</code></td>
			<td>загрузка системы (процессор, оперативная память, система ввода-вывода)</td>
		</tr>
		<tr>
			<td><code>dig</code>, <code>host</code>, <code>nslookup</code></td>
			<td>преобразование доменного имени в IP-адрес</td>
		</tr>
		<tr>
			<td><code>traceroute -U -p 53  target_ip_or_dns_srv</code>,</br>
		<code>nmap -sU -p 53 target_ip_or_dns_srv</code></td>
			<td>проверка доступности «резолверы» DNS и возможного присутствия межсетевого экрана</td>
		</tr>
		<tr>
			<td><code>ping</code>,</br><code>traceroute</code></td>
			<td>проверка доступности узла</td>
		</tr>
		<tr>
			<td><code>nc -vz target_ip port<code>,</br></code>nmap</code>,</br><code>traceroute</code></td>
			<td>проверка доступности серверного приложения (использующего TCP)</td>
		</tr>
		<tr>
			<td><code>nmap</code>,</br><code>traceroute</code></td>
			<td>проверка доступности серверного приложения (использующего UDP)</td>
		</tr>
		<tr>
			<td>VPN</td>
			<td>проверка доступности серверного приложения при блокировке межсетевым экраном на основе страны</td>
		</tr>
		<tr>
			<td><code>ping адрес_шлюза</code></td>
			<td>проверка доступности шлюза на стороне узла клиента и (или) узла сервера</td>
		</tr>
		<tr>
			<td><code>ping 8.8.8.8</code></td>
			<td>проверка оплаты Интернете</td>
		</tr>
		<tr>
			<td><code>traceroute</code>,</br>смена провайдера</td>
			<td>проверка соединения из-за обрыва кабели или другой аварийной ситуации в Интернете</td>
		</tr>
		<tr>
			<td><code>iptraf-ng</code></td>
			<td>проверка уровня использования пропускной способности</td>
		</tr>
		<tr>
			<td><code>ps</code> или <code>systemctl</code></td>
			<td>проверка состояние серверного приложения</td>
		</tr>
		<tr>
			<td>команды <code>uptime</code>,</br><code>last</code>,</br><code>dmesg</code>,</br>файлы в <code>/var/log</code></td>
			<td>проверка состояние серверного приложения в файлах журналов операционной системы, где:</br>а)<code>uptime</code> позволяет узнать текущее время работы системы и нагрузку на процессор</br>б)<code>last</code> отображает список последних входов и выходов пользователей</br>в)	<code>dmesg</code> выводит сообщения ядра, включая информацию о железе, ошибки и другие важные события</td>
		</tr>
		<tr>
			<td><code>ss</code> или <code>netstat</code></td>
			<td>проверка состояния портов сервера</td>
		</tr>
		<tr>
			<td><code>curl</code>, <code>wget</code></td>
			<td>проверка взаимодействия между фронтендом и бэкендом</td>
		</tr>
		<tr>
			<td><code>journalctl -f -u имя_службы</code></br>
			или <code>journalctl -e -u имя_службы</code></td>
			<td>отслеживания журнала системных сообщений (<code>systemd</code>) для службы имя_службы в режиме live mode(<code>-f</code>), который отображает новые сообщения по мере их появления или в режиме pager-end (<code>-e</code>),вывод	перемещается к концу журнала</td>
		</tr>
		<tr>
			<td><code>iptables -vnL</code></td>
			<td>выводит подробный список всех правил фильтрации пакетов (<code>DROP/REJECT</code>) в текущей таблице (обычно это таблица <code>filter</code>):</BR>
			<code>-v</code>: Показать подробную информацию (verbose).</BR>
			<code>-n</code>: Использовать числовой формат (не резолвить имена хостов).</BR>
			<code>-L</code>: Список всех правил (list).</td>
		</tr>
	</tbody>
</table>

Пример `iptables`:

```console
iptables -vnL
Chain INPUT (policy ACCEPT 22467 packets, 4408K bytes)
 pkts bytes target     prot opt in     out     source               destination         
31745   95M DROP       tcp  --  *      *       192.168.40.14        0.0.0.0/0            tcp dpt:22 statistic mode random probability 0.10000000009
 1067  196K DROP       icmp --  *      *       192.168.40.14        0.0.0.0/0            statistic mode random probability 0.25000000000

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT 27119 packets, 4824K bytes)
 pkts bytes target     prot opt in     out     source               destination         
28589 1606K DROP       tcp  --  *      *       0.0.0.0/0            192.168.40.14        tcp spt:22 statistic mode random probability 0.10000000009
 1796  110K DROP       tcp  --  *      *       0.0.0.0/0            192.168.40.150            tcp dpt:3306 owner UID match 2000
```
Здесь блокировка происходит из-за последней таблицы `OUTPUT` (исходящие), в которой отбрасываются (`DROP`) все пакеты TCP, идущие на узел 192.168.40.150 и порт 3306 от всех процессов с UID = 2000 (а это идентификатор пользователя st00).
## Поиск неисправностей на практике

<img src="resources/localization.png" alt="Алгоритм локализации дефектов" width="80%"/>

Алгоритм локализации дефектов

*!!!**Первая подтверждённая гипотеза** не всегда ведёт к первопричине. При некоторых обстоятельствах, например если у вас есть время, или если критичность дефекта очень высокая (и поэтому ему необходимо особое внимание), есть смысл проверить все выявленные гипотезы.*
#### Методы сокращения количества шагов, необходимых, чтобы найти возможную первопричину
Не все шаги и полноценные проверки нужны в каждом случае, так как:
1. Когда подтверждается какое-либо предположение, локализация завершается.
2. Есть несколько методов упрощения и, возможно, ускорения всего процесса.

Ниже приведены способы сокращения количества шагов, необходимых, чтобы найти возможную первопричину

<table style="width:100%;">
	<thead>
		<tr>
			<th style="width:37.2647%;background-color:rgb(255, 99, 30);"><span style="font-size:17px;"><span style="color:rgb(255, 255, 255);font-weight:bold;">Подход</span></span></th>
			<th style="width:29.267%;background-color:rgb(255, 99, 30);"><span style="font-size:17px;"><span style="color:rgb(255, 255, 255);font-weight:bold;">Условия применения</span></span></th>
			<th style="width:33.3352%;background-color:rgb(255, 99, 30);"><span style="font-size:17px;"><span style="color:rgb(255, 255, 255);font-weight:bold;">Польза</span><br></span></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="text-align:center;width:37.2647%;"><span style="font-size:17px;"><strong>Сначала самые простые:&nbsp;</strong>Все применимые проверки располагаются от самых простых (например, журналы) до самых сложных (например, анализаторы сетевых пакетов), а затем выполняются в этом порядке<br></span></td>
			<td style="text-align:center;width:29.267%;"><span style="font-size:17px;">У вас есть достаточный опыт в применении нужных инструментов и методик, чтобы заранее оценить их сложность<br></span></td>
			<td style="text-align:center;width:33.3352%;"><span style="font-size:17px;">Потенциальная экономия времени. &nbsp;Метод может быть полезен, если продвинутые способы проверки или инструменты недоступны. Этот метод проще других объяснить лицам, не связанным с IT<br></span></td>
		</tr>
		<tr>
			<td style="text-align:center;width:37.2647%;"><span style="font-size:17px;"><strong>Сначала самые вероятные:&nbsp;</strong>Расположите предположения так, чтобы вначале шли наиболее вероятные предположения, а затем проверьте их в этом&nbsp;порядке<br></span></td>
			<td style="text-align:center;width:29.267%;"><span style="font-size:17px;">Вы хорошо знакомы с этим приложением или у вас есть достаточный опыт с аналогичными приложениями</span></td>
			<td style="text-align:center;width:33.3352%;"><span style="font-size:17px;">Потенциальная экономия большого количества времени; методика также может быть полезна, если некоторые проверки недоступны<br></span></td>
		</tr>
		<tr>
			<td style="text-align:center;width:37.2647%;"><p><span style="font-size:17px;"><strong>Сверху вниз:</strong> <br>«Классический» алгоритм, описанный в предыдущем разделе. Все проверки проводятся, начиная со стороны клиента, шаг за шагом продвигаясь по направлению к внутренним элементам сервера<br></span></p></td>
			<td style="text-align:center;width:29.267%;"><span style="font-size:17px;">Вы не знакомы ни с приложением, ни с подходящими инструментами проверки<br></span></td>
			<td style="text-align:center;width:33.3352%;"><p><span style="font-size:17px;">В любом случае это НАМНОГО лучше хаотичного перебора проверок.&nbsp;</span><span style="font-size:17px;">Кроме того, углублённые проверки (например, для внутренних элементов бэкенда) не всегда доступны, в таком случае их явно стоит отложить.</span><span style="font-size:17px;"><br></span></p></td>
		</tr>
	</tbody>
</table>

# 21 Локализация дефектов в трёхзвенных приложениях
## Распространенные проблемы 3 звенных приложений <a id="3chaneproblem"></a>
### Сторона клиента:
- Некорректное или неподдерживаемое действие пользователя.
- Неподдерживаемый тип или версия клиентского приложения.
- Некоторое ПО, обеспечивающее безопасность, препятствует доступу пользователя к серверу.
- Некоторые настройки клиентского программного обеспечения неким образом конфликтуют с конфигурацией сервера.
- Неверные учётные данные для доступа к серверу.
- Пользователь может запросить что-либо неразрешённое или запрещённое для его роли.
### Сторона сервера:
- Отсутствующие объекты файловой системы.
- Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
- Проблема с правами пользователя для запуска приложения.
- Конфликты, связанные с портами.
- Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.
- Нехватка памяти может привести к завершению работы некоторых приложений или отказу выделить запрошенную приложением память.
### Сторона сетевая (между всеми соседними компонентами).
- Проблемы с маршрутизацией.
- Проблемы, связанные с DNS.
- Межсетевые экраны, блокирующие прохождение пакетов.
- Неправильная настройка компонентов верхнего уровня (например, неверный IP-адрес или FQDN сервера БД, некорректные учётные данные для подключения к БД, неверное название БД и т. д.).
### Сторона базы данных:
- Учётная запись в БД, используемая бэкендом, заблокирована.
- Пароль учётной записи изменён без соответствующей перенастройки бэкенд-приложения.
- Права пользователей, настроенные для бэкенд-приложения, изменены или аннулированы.
- Согласованность данных (в таблицах, пр.) нарушена.
## Пример руководства по развертыванию (Deployment guid)
### Руководство по развёртыванию (Deployment guid): фронтенд
<table>
	<tbody>
		<tr>
			<td><p>Расположение</p></td>
			<td><p>192.168.40.14</p></td>
		</tr>
		<tr>
			<td><p>Серверный TCP-порт</p></td>
			<td><p>90XY, где XY — это две последние цифры UID каждого студента в операционной системе (UID показывается командой id)</p></td>
		</tr>
		<tr>
			<td><p>Стек технологий</p></td>
			<td><p>nodejs express bootstrap</p></td>
		</tr>
		<tr>
			<td><p>Директория приложения</p></td>
			<td><p>/apps/nodejs/$USER</p></td>
		</tr>
		<tr>
			<td><p>Название службы в системе</p></td>
			<td><p>nodejs-auth.$USER</p></td>
		</tr>
		<tr>
			<td><p>Шаги для запуска</p></td>
			<td><p>sudo systemctl start nodejs-auth.$USER</p></td>
		</tr>
		<tr>
			<td><p>Основные файлы конфигурации</p></td>
			<td>
				<p>Адреса и порты бэкенда указаны в файле &nbsp;/apps/nodejs/$USER/config/default.json</p>
				<p>Порт сервера фронтенда указан в файле &nbsp;/apps/nodejs/$USER/bin/www</p>
			</td>
		</tr>
		<tr>
			<td><p>Журналы</p></td>
			<td>
				<ol>
					<li aria-level="1"><p>Можно просмотреть посредством команды journalctl.</p></li>
					<li aria-level="1"><p>Не содержит какого-либо подробного описания проблем, за исключением ошибок соединения с приложением бэкенда.</p></li>
				</ol>
				<p>journalctl -u nodejs-auth.$USER.service</p>
			</td>
		</tr>
		<tr>
			<td><p>URL</p></td>
			<td><p>http://192.168.40.14:90XY</p></td>
		</tr>
	</tbody>
</table>

### Руководство по развёртыванию (Deployment guid): бэкенд
<table>
	<tbody>
		<tr>
			<td><p>Местоположение</p></td>
			<td><p>192.168.40.100</p></td>
		</tr>
		<tr>
			<td><p>Порт TCP сервера</p></td>
			<td><p>70XY, где XY — это две последние цифры UID студента в операционной системе (UID показывается командой id)</p></td>
		</tr>
		<tr>
			<td><p>Стек технологий</p></td>
			<td><p>java springboot</p></td>
		</tr>
		<tr>
			<td><p>Директория приложения</p></td>
			<td><p>/apps/java/auth/$USER</p></td>
		</tr>
		<tr>
			<td><p>Название службы в системе</p></td>
			<td><p>java-auth.$USER</p></td>
		</tr>
		<tr>
			<td><p>Шаги для запуска</p></td>
			<td><p>sudo systemctl start java-auth.$USER</p></td>
		</tr>
		<tr>
			<td><p>Основные файлы конфигурации</p></td>
			<td><p>/apps/java/auth/$USER/application.properties</p></td>
		</tr>
		<tr>
			<td><p>Журналы</p></td>
			<td>
				<ol>
					<li aria-level="1"><p>Можно просмотреть посредством команды journalctl.</p></li>
					<li aria-level="1"><p>Заполняются при запуске приложения.</p></li>
					<li aria-level="1"><p>Корректные операции (например, вход в систему) не порождают новых записей журналов. В ходе работы приложения в журналы заносятся только ошибки.</p></li>
					<li aria-level="1"><p>Ключевые слова для поиска ошибок: ERR, WARN, SQL.</p></li>
				</ol>
				<p>journalctl -u java-auth.$USER.service</p>
			</td>
		</tr>
		<tr>
			<td><p>URL</p></td>
			<td><p>http://192.168.40.100:70XY</p></td>
		</tr>
	</tbody>
</table>

## Локализация дефектов в трёхзвенном приложении
1. Выполняется базовая проверка надлежащей работы всех наших серверных приложений
2. Выдвигаются гипотезы, исходя из [распространенных проблем 3-звенных приложений](#3chaneproblem)
3. Проводиться углубленная проверка (знание внутреннего устройства приложения и соответствующих технологиях позволит оптимизировать процесс локализации за счет снижения количества проверок и экономии времени. С помощью некоторых инструментов и методик можно **опосредованно** проверить несколько гипотез за раз. Например, зная, какой запрос отправить бэкенду, чтобы он обратился к БД, и сделав это посредством фронтенда, то одним действием можно проверить сразу множество гипотез).
