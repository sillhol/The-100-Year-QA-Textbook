# 19 Архитектура серверного ПО: Теория

## Software-инженер
Понимание архитектуры приложений и всех сопутствующих технологий серверного ПО - одно из ключевых отличий между "типичным" тестировщиком и Software-инженером.

**Software-инженеры** хорошо понимают каждый участок разрабатываемого ПО и могут эффективно работать не только с UI. Они могут заметно улучшить существующие тест-кейсы, документацию, и качество продукта в целом.
## 2-звенная архитектура
Большая часть современного ПО поддерживает работу с сетями и может работать как клиент или сервер, а порой выполнять и обе роли.

<img src="resources/client_server_side.png" alt="2-звенная архитектура" width="80%"/>

Серверная часть 2-звенного приложения взаимодействует только с:
+ Операционной системой
+ Клиентами, подключающимися по сети

Если клиентское и серверное приложения установлены на один и тот же хост, им проще всего "общаться" друг с другом через заранее известный виртуальный интерфейс `loopback`, всегда имеющий один и тот же IP-адрес `127.0.0.1`. Весь трафик, ищущий через этот интерфейс, остается внутри хоста и никогда не выходит во внешние сети.

Вне зависимости от архитектуры серверного приложения (2-х и более звенного) взаимодействие "клиент-сервер" может иметь вид "человек-машина" или "машина-машина". Это зависит от конкретных приложений и даже сценариев использования
### С точки зрения ОС серверные приложения работают со следующими объектами:
1. Файлы: хранение настроек, чтение / запись данных по запросу от пользователей, и т.п.
2. Сокеты: для открытия серверных портов на прослушивание с целью приема запросов от пользователей
3. Процессы: процесс-родитель может запустить дочерние процессы для обработки пользовательских запросов.
### С точки зрения сети, серверные приложения общаются с клиентами с помощью
1. Протоколов прикладного уровня, например HTTP, SMTP, POP3
2. Протоколов транспортного уровня типа TCP или UDP
### С точки зрения пользователя, нужно знать следующее:
1. Адрес сервера, порт и транспортный протокол. Например, веб-серверы могут прослушивать порт 443/TCP по умолчанию, однако другие порты могут настраиваться администраторами.
2. Прикладной протокол для общения с сервером. Например, сегодня веб-серверы, как правило, используют HTTPS, но некоторые всё ещё поддерживают HTTP.
3. Имя и пароль (или такие учётные данные, как сертификат), когда для работы с системой требуется вход и проверка подлинности.
### Примеры 2-звенных серверных приложений:
1. Файловые серверы.
2. FTP-серверы. Похожи на файловые, но работают по другому прикладному протоколу.
3. Службы удаленного управления, например SSH и Remote Desktop.
4. Серверы баз данных можно считать таковыми в простых случаях. Однако в более сложных конфигурациях, например с репликацией с ведущими и ведомыми серверами или распределённым хранилищем, базы данных являются N-звенными серверными приложениями.
### Возможные проблемы {#trouble}
#### Операционная система
ОС и ее настройки - наиболее частые причины возникновения проблем в 2-звенных серверных приложениях.
1. Отсутствующие объекты файловой системы: файлы, каталоги, символьные ссылки…
   1. Если кто-нибудь переместит или удалит их или отключит файловую систему, содержащую необходимые объекты, то приложение может даже не запуститься.
2. Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
   1. Если прав недостаточно, то приложение не сможет получить доступ к этим объектам.
   2. Если же для конфиденциальных файлов (например, содержащих учётные данные) или директорий настроены слишком широкие права, то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.
3. Некорректно настроенные права пользователя для запуска приложения
   1. Например: некоторые приложения не допускают запуск со стороны администратора (root), другие же, наоборот, для запуска требуют права администратора или участие в определённой группе.
4. Ошибочная настройка самого приложения, например: неверный формат файла настройки, указана неподдерживаемая или конфликтующая опция настройки, и т.п.
5. Конфликты, связанные с портами.
   1. Если нужный порт уже используется другим процессом, то приложение не сможет запуститься.
6. Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.
7. Нехватка оперативной памяти: в случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить работу некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.
8. Новые нестабильные компоненты либо конфликтующие компоненты, появившиеся в окружении (обновления ОС, сторонние программные компоненты).
9. Что-либо иное, например временные файлы, оставшиеся от предыдущего аварийного завершения работы приложения.

**PS** *Высокая загрузка центрального процессора или системы ввода-вывода (диски, сеть) не может в большинстве случаев привести к остановке приложения, но наверняка замедлит его работу.*
#### Сеть
На уровне сети может доступу пользователя к серверному приложению могут помешать:
1. Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.
2. Проблемы, связанные с системой DNS, когда пользователь обращается к серверу посредством полного доменного имени.
3. Межсетевой экран, блокирующий прохождение пакетов (может быть настроен на любом узле: клиент, сервер, маршрутизатор между ними).
4. Перегруженные сегменты сети на стороне клиента или сервера.
#### Проблемы на стороне клиента
1. Неподдерживаемый тип или версия клиентского приложения.
   1. Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.
2. Неподдерживаемое или некорректное действие пользователя.
3. Некоторое ПО, обеспечивающее безопасность, препятствует работе пользователя с сервером.
4. Какие-либо настройки клиентского ПО мешают работе конкретно с этим сервером.
5. Если на сервере необходимо залогиниться, пользователь может ввести неверное имя учетной записи или пароль.
6. Пользователю запрещено что-либо делать на этом сервере.
## 3-звенные приложения
1. Уровень представления (`Presentation Layer`, `Frontend`) включает пользовательские интерфейсы (UI), такие как веб-страницы, мобильные приложения или десктопные приложения:
   + **Отвечает** за взаимодействие с пользователем.
   + **Выполняет** — отображение данных пользователю и обработка ввода пользователя.
2. Уровень логики приложения (`Application Logic Layer`, `Backend`, `Business Logic Layer`) или уровень бизнес-логики (Business Logic Layer) является отдельным приложением, написанным на PHP, Java, Python, Node.js или другом языке:
   + **Отвечает** за обработку бизнес-логики приложения.
   + **Выполняет** операции, такие как обработка данных, выполнение вычислений, логика принятия решений и управление транзакциями.
   + **Взаимодействует** как с уровнем представления, так и с уровнем данных, но не напрямую с пользователем.
3. Уровень данных (`Data Layer`) обычно базой данных (NoSQL и реляционной: MySQL, PostgreSQL, Oracle, MS SQL) или другими системами хранения данных:
   + **Отвечает** за хранение, управление и доступ к данным.
   + **Выполняет** операции с данными, такие как запросы, обновления, удаления и их чтение, и предоставляет данные для уровня логики приложения.

<img src="resources/3-tier.png" alt="3-звенная архитектура" width="80%"/>

### Различия между 2-х и 3-звенными приложениями:
1. Несколько серверных приложения вместо одного.
2. Эти серверные приложения можно развернуть на отдельных узлах, связанных через сеть.
   1. При необходимости их можно установить на один компьютер — это распространённый вариант для небольших веб-порталов.
3. Каждый уровень рассматривается как отдельное приложение, для которого возможны соответствующие причины отказа (см. выше).
4. У баз данных (БД) могут быть свои собственные точки отказа, описанные ниже.
   1. Второе звено подключается к СУБД и проходит проверку подлинности, используя своё отдельное имя пользователя и пароль (или сертификат), указанные в файлах конфигурации, — то есть оно действует как клиент БД. Поэтому оно одновременно исполняет роль и сервера для `Presentation Layer`, и клиента для БД (`Data Layer`)
   2. Непосредственно БД недоступна для конечного пользователя, поскольку, во-первых, в этом нет необходимости, а во-вторых, в БД могут содержаться конфиденциальные данные других пользователей, и для таких данных нужна максимально возможная защита. По этой причине с БД должно работать только приложение верхнего уровня.
### Примеры 3-звенных приложений:
+ Большинство интернет-форумов и CMS типа WordPress. Для небольших веб-сайтов оба компонента часто устанавливают на одном хосте.
+ Многие онлайн-игры: игровой клиент отвечает за UI-часть, а сервер производит анализ данных, вычисления, защиту от ботов, а также взаимодействует с СУБД.
+ Сложные серверы электронной почты.
### Возможные проблемы
Каждый из трёх компонентов 3-звенных приложений может столкнуться с проблемами, характерными для 2-звенных приложений [(см. выше)](#trouble). Ниже приведены дополнительные риски, вызванные усложнением архитектуры:
#### Сеть: подключение верхнего звена к уровню данных
1. Неправильная конфигурация приложения, взаимодействующего с СУБД, например: IP-адрес или полное доменное имя сервера БД, некорректные учётные данные для подключения к БД, неверное название БД и т. д.
2. Связь между этими двумя компонентами может нарушиться из-за проблем с маршрутизацией, DNS, межсетевыми экранами (однако чаще всего они устанавливаются на одном узле или находятся в одной локальной сети).
#### Уровень данных
Базы данных - достаточно сложные приложения, проблемы с которыми возможны в первую очередь из-за появления отдельных учетных записей СУБД.
1. Учётные записи СУБД, применяемые вышестоящим уровнем, могут быть заблокированы.
2. Их пароли могут быть изменены без соответствующей перенастройки приложения верхнего уровня.
3. Права пользователей в отношении приложения верхнего уровня могут быть изменены или аннулированы, и необходимые данные тогда станут недоступны для чтения и (или) записи.
4. Согласованность данных может быть нарушена, например, когда соответствующие таблицы или записи изменяются другими средствами (представьте, что администратор БД допустил ошибку).

### Преимущества 3-х звенной архитектуры перед 2-звенной:
+ Поддержка "тонких клиентов", как следствие - проще поддерживать весь спектр клиентских устройств 
+ Более простая поддержка серверных частей приложения. *Когда нужно лишь немного поправить интерфейс пользователя, то это не затрагивает остальные компоненты.*
+ Большая масштабируемость. *По мере роста компании можно добавлять новые серверы на каждом звене, особенно когда применяется балансировка нагрузки.*
+ Большая защищенность (фильтрация данных от пользователя, не пропуская SQL-инъекции и пр)

<img src="resources/3-tier_balancer.png" alt="Схема 3-звенного корпоративного приложения" width="80%"/>

*Для приложений, работающих с высокой нагрузкой, часто применяются балансировщики нагрузки, которые распределяют входящие запросы между соединёнными серверами, так чтобы каждый новый пользователь направлялся к определённому серверу.*

#### Виды клиентского ПО:
##### "Тонкий клиент"
Задача "тонкого клиента" (например, браузера) - отобразить интерфейс, полученный от сервера, и дать пользователю возможность что-то туда ввести: 
1. "Тонкий клиент" чаще всего не умеют работать в оффлайн-режиме.
2. "Тонкие клиенты" гораздо проще в реализации, что дает возможность сравнительно легко поддержать множество видов клиентских устройств и операционных систем.
##### "Толстый клиент"
"Толстый клиент" - приложения с функциональностью гораздо большей, чем может быть реализовано в "тонком клиенте".
1. "Толстый клиент" не является универсальным (как браузер) и умеет работать только с определенной серверной частью, всего по одному или нескольким прикладным протоколам.
2. Классические примеры:  клиенты онлайн-игр, почтовые клиенты (MS Outlook, Mozilla Thunderbird). Что касается последних: доступ к почте чаще всего можно получить и через браузер (применив "тонкий клиент") или с помощью Outlook / Thunderbird ("толстый клиент").

*Чаще оказывается проще и дешевле создать более сложное 3-звенное серверное приложение с поддержкой множества тонких клиентов, чем иметь 2-звенное серверное приложение и разрабатывать соответствующие "толстые" клиенты для каждого типа клиентских узлов и ОС.*

В зависимости от архитектуры И клиентского, И серверного ПО, термины "Тонкий клиент" и "Толстый клиент" могут иметь различное значение:

1. **Фронтэнд**: приложение, отвечающее за пользовательский интерфейс (UI). "Толстые клиенты" реализуют эту функциональность самостоятельно, однако "тонкие клиенты" требуют наличия серверного Фронтэнд-компонента.
2. **Бэкэнд**: часто этим словом называют ВСЮ серверную часть (независимо от количества звеньев). Однако для 3-звенной архитектуры этот термин имеет специальное более узкое значение, что поясняется ниже.

**Тестирование Фронтэнд-компонентов**: в основном включает в себя только тестирование *UI*, *usability testing*, плюс *регрессионное тестирование*. Задачи в основном рутинные, связанные с пошаговым исполнением тест-кейсов.

**Тестирование Бэкэнд-компонентов**:  состоит из задач, связанных с логикой приложения, взаимодействием компонентов и обработкой данных. Часто за тестирование Бэкэнда отвечают только разработчики, что приводит к большому количеству долго живущих и сложно выявляемых багов. Поэтому, тестирование бэкэнда - отличный способ улучшить качество всего продукта.
### Защита данных 
1. У пользователей никогда не должно быть доступа к СУБД напрямую. Считается хорошей практикой ограничить внешний доступ к СУБД с помощью межсетевого экрана, разрешив его только с бэкэнд-сервера и рабочих мест администраторов БД.
2. Для 3- и N-звенных приложений: фронтэнд не имеет прямого доступа к СУБД. (Для его задач это просто не нужно).
3. Для N-звенных приложений: бэкэнд не должен быть доступен напрямую пользователям. Пользователи должны работать только с компонентом фронтэнда и не иметь возможности отправлять запросы на бэкэнд напрямую.
## Журналы событий
**Журналирование** ("логирование") - важная часть функциональности приложения, позволяющая отслеживать его поведение и состояние. Под "событиями" понимаются как штатные операции, так и ошибки, возникающие по ходу работы ПО.

Понимание того, как устроено журналирование внутри приложений, полезно для следующего:
1. Идентификация проблем: с чем связан найденный баг? Что еще известно о поведении системы в тот момент, когда в ней произошел сбой? События уровня `DEBUG` или `TRACE` помогают собрать заметно больше информации для дальнейшего разбора и установки причины сбоя.
2. Поиск причины неисправности (`Root Cause Analysis`): в чем конкретно причина найденного бага? Текст сообщений об ошибках, метки времени (`timestamps`) и прочая полезная информация из журналов крайне полезны для этих целей.
3. Создание качественных тест-кейсов: при написании тест-кейсов, особенно для серверного ПО, очень полезно также указывать, какие события стоит ожидать в журналах при проведении той или иной операции. Помимо прочего, такие подробности также очень сильно облегчают автоматизацию тестирования.
4. Интеграционное тестирование: когда система состоит из множества  взаимодействующих компонентов, т.е. начиная от 3-звенной архитектуры, понимание событий из журналов заметно упрощает интеграционное тестирование.
5. Мониторинг и тестирование производительности: журналы событий являются неотъемлемой частью всего этого, т.к. контроль состояния приложения и получение метрик быстродействия производится на основании журналов событий ПО.
6. Совместная работа с разработчиками ПО: при общении с разработчиками (и любыми другими техническими специалистами, например техподдержкой) крайне необходимо глубоко работать с журналами событий, чтобы точно  определять причины возникновения багов и убедиться в их успешном устранении.
7. Тестирование безопасности: зачастую журналы событий ПО содержат крайне ценную информацию о различных событиях безопасности (например, вход пользователя в систему), которая не может быть получена откуда-либо еще.
8. Постоянное улучшение качества: журналы событий часто позволяют снимать различные метрики, полезные для обеспечения постоянного роста качества ПО и минимизации количества сбоев в дальнейшем.
### Уровни событий (log level / severity)
*Уровни событий указаны по убыванию важности.*
Emergency (emerg)
♦	Полный отказ системы
♦	Это наивысший уровень события, указывающий на катастрофичный сбой, который требует немед елейных действий
♦	Пример: в Ы-звенном приложении стала недоступна СУБД
Alert
♦	Требуются незамедлительные действия
♦	В чем-то похоже на emergency, однако система пока еще остается частично рабочей
Critical (crit)
♦	Критические условия работы системы
♦	Вся система еще не отказала, однако на эту ошибку стоит обратить внимание как можно быстрее и предпринять соответствующие действия.
♦	Пример: отказ одного из жестких дисков в отказоустойчивом дисковом массиве - система в принципе может работать, но нужно заменить диск как можно быстрее.
Error (err)
♦	В работе ПО или связанных компонентов произошла какая-то ошибка
♦	Вся система остается рабочей, однако на ошибку все равно стоит обратить внимание
♦	Пример: пользователь не может залогиниться в систему по каким-то временным причинам на стороне сервера
Warning (warn)
♦	При таком сообщении система остается полностью работоспособной
♦	Указывает на потенциальную проблему, которая может повлечь дальнейшую ошибку в работе системы; чтобы это предотвратить, стоит разобраться с вызвавшей ее причиной
♦	Пример: при запуске ПО выяснилось, что используется устаревшая функциональность внутри ОС, которая может быть исключена из следующих версий ОС - т.е. пока что наше ПО работает, но вскоре может "сломаться"
Notice
♦	Нормальное событие, представляющее интерес в рамках работы всей системы
♦	Скорее всего, не связано с какими-то рисками в работе системы
♦	Пример: пользователь залогинился удаленно в систему
Informational (info)
♦	Сообщения о штатных операциях внутри системы
♦	В основном не требуют внимания
♦	Пример: пользователь сформировал заказ
Debug
•	Наиболее подробный уровень сообщений
•	Включает информацию обо всех деталях происходящего
•	Пример: какая была версия браузера у пользователя, который вошел в систему

*Почти всегда у современного ПО есть события уровней DEBUG иTRACE, которые не сохраняются в журналы при настройках по умолчанию. На продуктивных высоконагруженных системах их включение может привести к замедлению работы ПО и гигантским размерам журналов, однако это окажется крайне полезным при установлении причин возникновения бага.*

Как правило, формат событий зависит от конкретного приложения, но считается хорошей практикой указывать в событиях следующие ключевые поля:

1. Метку времени (timestamp) - когда конкретно произошло это событие.
2. Уровень (severity / loglevel) - насколько это событие было важно, см. уровни Emergency ... Debug из описания выше. Помогает найти и отфильтровать нужные события в журналах.
3. Источник события - "как зовут" тот компонент, который отправил это сообщение. В сообщениях syslog, относящихся к работе ОС (не прикладного ПО) эту сущность обычно называют facility (категория).
4. Сообщение: текст, описывающий суть события. Должно быть достаточно подробным для понимания теми, кому оно предназначено.

*События могут включать в себя множество иной информации, например: ID транзакций; идентификаторы процессов ОС; имена пользователей, от лица которых была инициирована соответствующая операция; сведения о системе - как клиента (ОС, версия клиентского ПО, ...), так и сервера; текст HTTP-запросов и их заголовки; коды ответа сервера (если применимо); иные метрики. Все эти подробности должны помочь тестировщикам, разработчикам и администраторам точно идентифицировать проблему, добиться ее скорейшего устранения, и повысить качество ПО в будущем.*
### Где хранятся журналы событий
Вся логика работы с событиями, в том числе какие из них записывать (а какие нет) и куда их сохранять, специфична для каждого конкретного приложения. Однако стоит отметить наиболее общие моменты.
1. В самом простом случае приложение может писать свои события прямо в терминал. Многие серверные приложения также можно запустить со специальными отладочными опциями командной строки для отображения событий в терминал, однако в продуктивных (НЕ тестовых) средах такое не встречается.
2. В самом часто встречаемом случае события записываются в определенный файл(-ы). Файл, чаще всего, представляет собой простой текст.
3. В более сложных случаях ПО передает свои события "под запись" компонентам операционной системы. Для Linux такими компонентами ОС могут быть:
   1. syslog и его разновидности. События чаще всего сохраняются в простые текстовые файлы, хотя бывают и исключения из этого правила.
   2. journald - подсистема журналирования сервисов systemd. Для получения событий применяется команда journalctl. Такой пример приведен ниже.
4. В самых сложных случаях события передаются в централизованное хранилище и хранятся в специальных "местах", например в отдельной базе данных.
### Что еще важно знать о журналах событий:
1. И клиентские, и серверные приложения могут писать журналы событий.
2. Приложения, как правило, позволяют настраивать уровни сообщений, которые пишутся в логи. Так, в продуктивных системах из-за проблем быстродействия и размеров логов чаще всего записываются только важные события, т.е. начиная с уровня Notice или даже Warning. В тестовых средах не редкость сохранение всех событий, т.е. начиная с Debug.
3. Невозможно хранить события за все время работы приложения, поэтому чаще всего логи подвергаются т.н. "ротации", которую проще всего пояснить на примере обычных текстовых файлов: старые файлы удаляются по прошествии какого-то времени, новые записываются. Предельный размер каждого лог-файла чаще всего можно настроить.
4. Приложение пишет свои логи в том формате, в котором считает нужным. Иногда этот формат можно настроить.
5. Как конкретно настраиваются уровень, ротация и (если возможно) формат событий, зависит от каждого конкретного приложения. Более того, в многозвенном приложении каждый его компонент может писать логи в своем формате, в свои отдельные файлы, с различными параметрами ротации. Информацию о настройках журналирования стоит выяснить у разработчиков / аналитиков / команды ДевОпс.
