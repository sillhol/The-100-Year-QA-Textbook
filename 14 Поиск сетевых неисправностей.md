# 14 Поиск сетевых неисправностей
## Проблемы на сетевом уровне
### ICMP — Internet Control Message Protocol
**ICMP** - протокол транспортного уровня. Служит для пересылка сообщений о состоянии узлов и сетевых проблемах от одного узла к другому (не для передачи данных).

<img src="resources/ts_1.png" alt="Структура пакета ICMP" width="70%"/>, где:

+ Type (Тип) - поле, определяющее тип сообщения ICMP, например, ошибки в сети, запросы эха (ping) и другие управляющие сообщения.
  + "Echo Request"(Эхо-запрос) (Type=8) и “Echo Reply” (Type=0). Эти типы используются утилитой ping, а также программой traceroute в режиме ICMP
  + "Destination Unreachable" (Type=3) - используя этот тип сообщения, шлюзы уведомляют, что они не могут достичь узла назначения текущего IP-пакета.
  + "Time Exceeded" (Type=11). Если на шлюз пришел пакетом с нулевым полем TTL в заголовке IP (Time to live — время существования, то есть количество промежуточных узлов, до исчерпания которого пакет существует в сети, а затем отбрасывается маршрутизатором), то он пошлёт отправителю сообщение «Время истекло». Именно на основе этого принципа работает утилита traceroute
+ Code (Код) - дополнительное поле, которое дополняет тип сообщения и может уточнять его. Например, для сообщений об ошибке этот код может указывать на конкретный тип ошибки.
  + "Destination port unreachable" (Code=3) добавляется в некоторых случаях удалённым узел в ответ на попытку подключения по протоколу UDP к закрытому порту в дополнение к "Destination Unreachable" (Type=3) (так как у самого UDP нет способа реакции на такое событие)
  + "Time to live exceeded in transit" (Code=0) при Time Exceeded (Type=11) обычно используется для указания причины превышения времени
+ Checksum (Контрольная сумма): Это поле содержит контрольную сумму заголовка ICMP-сообщения, помогая обнаруживать ошибки в передаче данных.
+ Content (Содержание) - содержимое самого сообщения ICMP, которое может варьироваться в зависимости от его типа и кода. Например, для сообщений об ошибках содержание может включать дополнительную информацию о характере ошибки, а для запросов эха - данные для проверки доступности хоста.

*ICMP не предполагает использование портов.*
### ping
ping -  сетевая утилита, используемая для диагностики сетевых подключений.
#### Функции 
+ Проверка достижимости удалённого узла.
+ Измерение суммарного времени, потраченного на передачу и подтверждение пакета (параметр RTT, round-trip time). Высокие значения RTT указывают на высокую задержку, что может повлиять на производительность сетевых приложений. *Постоянно высокие или резко изменяющиеся значения RTT могут свидетельствовать о проблемах со стабильностью сети, таких как нестабильные маршруты или перегруженные сетевые устройства*
#### Принцип работы
1. Удалённому узлу отправляется эхо-запрос протокола ICMP;
2. Если удалённый узел настроен надлежащим образом, то он отправит пакет с “Echo Reply” (Type=0) протокола ICMP
#### Полезные опции ping для ОС Linux и macOS
```ping [options] <remote_host>```
+ ```-c <N>```: остановиться после N пакетов
+ ```-s <N>```: отправлять пакеты размером N байт. Отправка очень больших пакетов (например, 65000 байт) может использоваться для тестирования, но также может вызвать проблемы, такие как фрагментация пакетов, нагрузка на сеть или на целевой узел, что может привести к потерям пакетов или другим проблемам. Многие сети и устройства могут блокировать или ограничивать размер пакетов, чтобы предотвратить атаки и перегрузки. Такие большие пакеты могут быть отброшены или ограничены
+ ```-t <N>```: установить значение поля TTL IP-пакета в N. Установив -t 1 можно получить IP-адрес шлюза, используемого по умолчанию, т.к. при значении TTL = 1 пакет будет отброшен ближайшим промежуточным узлом (то есть вашим шлюзом, используемым по умолчанию) с отправкой сообщения «Время истекло»
+ ```-A```: включает адаптивный режим, который автоматически завершает команду ping, если ответы становятся стабильными. Это может помочь предотвратить бесконечный пинг, если узел стабильно отвечает на запросы.

#### Примеры
+ ```ping example.com```
+ ```ping -c 10 example.com``` (по умолчанию ```ping``` работает до нажатия клавиш Ctrl+C)
+ ```sudo ping -A -s 65000 192.168.100.1```
+ ```ping -t 1 example.com```

*вывод ping:*
```console
[user@host]$ ping -c 3 example.com
PING example.com (93.184.216.34): 56 data bytes
64 bytes from 93.184.216.34: icmp_seq=0 ttl=50 time=129.329 ms
64 bytes from 93.184.216.34: icmp_seq=1 ttl=50 time=128.532 ms
64 bytes from 93.184.216.34: icmp_seq=2 ttl=50 time=128.729 ms


--- example.com ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 128.532/128.863/129.329/0.339 ms
```
#### ВАЖНО
1. ```ping``` **не измеряет пропускную способность соединения (bandwitch)**. Могут быть соединения с низкой задержкой (т. е. параметром RTT) и одновременно с низкой пропускной способностью («скоростью»), а также с высоким RTT и высокой пропускной способностью.
2. ```ping``` **нельзя использовать для проверки доступности удалённого ПОРТА**. Это распространённая ошибка новичков: на вопрос «как вы будете проверять, открыт удалённый порт или нет?», некоторые отвечают «я буду использовать ping». В протоколе ICMP нет портов, и он не относится к протоколам TCP и UDP, поэтому его нельзя применить для такой проверки. Вместо этого используйте программы nc или nmap (о них поговорим позже).
3. **Протокол ICMP может быть заблокирован в настройках межсетевых экранов или серверов**. По этой причине не будет эхо-ответа даже от доступных корректно работающих узлов. Отсутствие эхо-ответа от удалённого узла может означать всего лишь работу межсетевого экрана.

*Примечание: Значения TTL в выводе ping — работающий способ приблизительно определить тип ОС удалённого узла*
### traceroute
**traceroute** — это сетевая утилита, показывающая маршрут, по которому пакеты проходят от исходного хоста до целевого узла в IP-сети, позволяя выявить узкие места, задержки или точки отказа в сети.

```traceroute [options] destination```
#### Алгоритм работы 
Программа отправляет пакеты с TTL = 1, TTL = 2…, пока не достигнет удалённого узла и не получит ожидаемый ответ. Все промежуточные узлы отклоняют пакеты, когда параметр TTL достигает нуля, а в каждом ответе этих узлов содержится их IP-адрес.
#### Функции
+ показывает все промежуточные узлы (маршрутизаторы), через которые проходят пакеты до достижения целевого хоста.
+ показывает время обратного хода (RTT) для каждого хопа, что позволяет оценить задержку на каждом этапе маршрута
+ помогает определить, на каком участке сети возникают задержки или потери пакетов
#### Опции
1. ```-U``` - в UNIX (Linux, macOS) ```traceroute``` по умолчанию применяет пакеты UDP (```traceroute -n yandex.ru``` = ```traceroute -n -U yandex.ru```), отправляемыми вовне на случайные порты серверов. Поэтому он часто блокируется межсетевыми экранами, и ```traceroute``` в таком случае не покажет некоторые промежуточные узлы, расположенные между вами и удалёнными узлами (```traceroute -n -U yandex.ru```).
2. ```-T``` - ```traceroute``` поддерживает протокол TCP. В Этом случае будут отправляться пакеты с флагом SYN
3. ```-I``` - использовать ICMP пакеты вместо UDP;
4. ```-p``` - указать порт вместо порта по умолчанию;
5. ```-g``` - передавать пакет через указанный шлюз;
6. ```-i``` - передавать пакет через указанный интерфейс;
7. ```-P``` - протокол, доступны такие значения: raw, dccp, udplite, udp, tcpconn, tcp, icmp
8. ```-n``` - указывает traceroute не преобразовывать IP-адреса в имена хостов. Это ускоряет выполнение команды, так как не требуется обратное разрешение DNS для каждого узла.
9. ```-m``` - задает максимальное количество переходов пакета до пункта назначения. По умолчанию максимальное значение TTL установлено на 30.

*Алгоритм работы ```traceroute``` не зависит от используемого протокола*

*```tracert``` (аналог ```traceroute``` в Windows) по умолчанию применяет протокол ICMP*
#### Примеры
+ ```traceroute -n yandex.ru```
+ ```traceroute -nI yandex.ru```
+ ```traceroute -nT yandex.ru```
+ ```traceroute -nU yandex.ru``` = ```traceroute -n yandex.ru```

*Пример вывода*
```console
traceroute to example.com (93.184.216.34), 30 hops max, 60 byte packets
 1  192.168.1.1 (192.168.1.1)  1.098 ms  1.045 ms  1.014 ms
 2  10.0.0.1 (10.0.0.1)  2.123 ms  2.096 ms  2.071 ms
 3  172.16.0.1 (172.16.0.1)  3.245 ms  3.221 ms  3.201 ms
 4  192.0.2.1 (192.0.2.1)  4.367 ms  4.344 ms  4.321 ms
 5  203.0.113.1 (203.0.113.1)  5.493 ms  5.470 ms  5.447 ms
 6  198.51.100.1 (198.51.100.1)  6.613 ms  6.589 ms  6.567 ms
 7  93.184.216.34 (93.184.216.34)  7.789 ms  7.766 ms  7.744 ms
```
### Проблемы с маршрутизацией и узлами, отключенными от сети
<!-- HTML для объединения ячеек -->
<table>
  <thead>
    <tr>
      <th>Текст ICMP-сообщения</th>
      <th>Причины</th>
    </tr>
  </thead>
  <tbody>
    <tr>
	  <td rowspan="3">"No route to host"</td>
	  <td>Это сообщение генерируется ОС узла-отправителя (в т.ч. маршрутизатора), когда в его таблице маршрутизации отсутствует соответствующий маршрут для доставки пакета к указанному IP-адресу. Причины:</td>
    </tr>
     <tr>
      <td>- нет ни одного правила в вашей таблице маршрутизации</td>
    </tr>
    <tr>
      <td>- в настройках узла не указан маршрутизатор, используемый по умолчанию</td>
    </tr>
    <tr>
      <td rowspan="4">"Destination host unreachable"</td>
      <td>Это сообщение генерируется маршрутизатором или шлюзом, когда они не могут доставить пакет до целевого узла (устройство достигло хоста назначения, но не может установить с ним соединение). Причины:</td>
    <tr>
      <td>- сетевые проблемы, такие как перегрузка сети, сбои оборудования или проблемы с кабелем</td>
    </tr>
    </tr>
    <tr>
      <td>- узел назначения не в сети (выключен, не подключен к сети или фильтруется межсетевым экраном)</td>
    </tr>
    <tr>
      <td>- протокол ICMP отключён на промежуточных межсетевых экранах или узле назначения</td>
    </tr>
  </tbody>
</table>

При необходимости проверить доступность узла при отключенном на промежуточных межсетевых экранах или на самом узле назначения протокола ICMP  (```ping``` возвращает «Destination host unreachable») достаточно удалённо проверить TCP или UDP порты узла с помощью:
+ ```nc -vz адрес_узла №_порта``` или
+ ```traceroute -U -p 25 mx1.ptsecurity.com``` (однако, важно понимать, что ```traceroute``` и ```nc``` (```netcat```) имеют разные цели. nc проверяет доступность конкретного порта на целевом узле, пытаясь установить соединение, в то время как traceroute показывает маршрут пакетов и может использоваться для диагностики проблем с сетевой связью на каждом шаге маршрута)
### Проблемы с системой DNS
<table>
	<thead>
		<tr>
			<th>Текст ICMP-сообщения</th>
			<th>Причины</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td rowspan="5">"Name or service not known"</td>
			<td>Это сообщение обычно генерируется утилитами, которые пытаются разрешить имя хоста в IP-адрес, когда DNS (Domain Name System) не может найти указанный домен. Причины:</td>
		</tr>
		<tr>
			<td>- узел не существует</td>
		</tr>
		<tr>
			<td>- доменное имя существует, но у него нет IP-адреса (доменное имя зарегистрировали, но при не настроили доменную зону). Чтобы определить существование доменного имени можно использовать инструмент командной строки <code>whois</code> в ОС Linux /</td>
		</tr>
		<tr>
			<td>- на клиентском узле ошибка в настройке «DNS-резолвера» (следует проверить /etc/resolv.conf)</td>
		</tr>
		<tr>
			<td>- не работает «резолвер» (проверить можно с помощью публичных «резолверов»: <code>host badhostname.com 8.8.8.8</code> или <code>dig badhostname.com @8.8.8.8</code>)</td>
		</tr>
	</tbody>
</table>

*DNS-резолвер (или DNS-клиент) — это компонент программного или аппаратного обеспечения, отвечающий за выполнение DNS-запросов. Его основная задача — преобразование человекочитаемых доменных имен в соответствующие IP-адреса и наоборот*
### Потеря пакетов
#### Признаки
+ слишком медленное соединение;
+ передача данных застопорилась;
+ имеют место неожиданные сбросы соединения TCP.
#### Причина
Перегрузка интерфейса одного из узлов (включая шлюзы) или проблемы с физическим каналом. 
#### Диагностика
1. Выполните проверку связи с удалённым узлом с помощью пакетов размером примерно 1 КБ и опции "-s" (Использование маленького размера пакета (1 байт) может быть полезным для минимизации влияния самой команды ping на сеть, что иногда важно для высоконагруженных сетей или для получения более точных измерений времени задержки без учета дополнительной нагрузки) и посмотрите статистику. Если доля потерянных пакетов (packet loss при выводе с помощью ping) > 5 %, то дело может быть в потере пакетов: ```ping -s 1 example.com```
2. Создайте файл PCAP с образцом потока пакетов между клиентом и удалёнными узлами, используя программу ```tcpdump``` с фильтрами для узлов и портов. Если есть такая возможность, выполните то же самое на узле назначения. Откройте сохранённый файл в программе Wireshark и поищите красные и (или) чёрные метки. *Красный цвет обычно обозначает критические ошибки или сбои. Это могут быть пакеты с ошибками, такие как неправильные контрольные суммы, повреждённые данные или др.*. Чёрный цвет часто указывает на менее критичные проблемы или предупреждения. Эти сообщения могут быть полезными для диагностики, но они не обязательно указывают на серьёзные сбои, например, сообщения о проблемах с производительностью "Slow Acknowledgment"
## Проблемы на транспортном уровне
+ Для удалённой проверки (при отсутствии доступа к интересующему узлу по протоколу ```SSH```) использовать утилиты: ```nc``` и ``nmap``
+ Для локальной проверки открытых портов (при наличии доступа к интересующему узлу посредством протокола ```SSH```) использовать программы [netstat](13%20Транспортный%20уровень%20и%20анализаторы%20трафика.md#netstat%20подробно) или ```ss```. Продвинутые пользователи ОС Linux могут также использовать программу lsof (если она установлена).
### nc
nc - инструмент для чтения и записи данных через сетевые соединения с использованием протоколов TCP или UDP. Он часто применяется в сетевом администрировании и тестировании, в т.ч. для диагностики на транспортном и прикладном уровне стека TCP/IP *(т.к. при поиске неисправностей некоторые реализации ```nc``` не очень хорошо работают с UDP, поэтому в этом случае рекомендуют применять ```nmap```). 

+ проверить только один порт: ```nc -vz server_address port```
+ проверить диапазон портов: ```nc -z server_address 1000-2000```, здесь:
  + ```-v``` для получения подробного вывода (т.е. будут показаны и неудачные попытки)
  + ```-z``` для проверки доступности порта	

Результатом команды nc может быть следующим: 
1. Порт открыт и доступен.
```console
[st00@c7-backend ~]$ nc -vz 127.0.0.1 22
Connection to 127.0.0.1 22 port [tcp/ssh] succeeded!
```
2. Порт закрыт, т. е. ни одно из приложений сервера не прослушивает этот порт.
```console
[st00@c7-backend ~]$ nc -vz 127.0.0.1 23
nc: connect to 127.0.0.1 port 23 (tcp) failed: Connection refused
```
3. Время ожидания истекло, поскольку узел не в сети (физически или логически отключен от сети) или недостижим (узел физически подключен к сети, но нет маршрута к узлу из-за проблем в маршрутизации; пакеты заблокированы межсетевыми экранами или системами предотвращения вторжений (IPS) для конкретного источника или типа трафика; проблемы в сети - обрывы кабелей, проблемы на маршрутизаторах и т.д., - которые делают узел недостижимым). 
```console
[st00@c7-backend ~]$ time nc -vz 87.250.250.242 22
nc: connect to 87.250.250.242 port 22 (tcp) failed: Connection timed out

real    2m7.336s
user    0m0.003s
sys     0m0.005s
```
*Примечание к п.3*
1. Команда ```time``` добавляет только информацию о времени выполнения команды, но не изменяет её поведение. Сообщение Connection timed out появилось бы в любом случае, если соединение не удалось установить из-за тайм-аута
2. В фоновом режиме могут также происходить дополнительные обмены, такие как отправка ICMP сообщений "Destination Unreachable" от промежуточных узлов или целевого узла, если они не могут доставить пакет (можно перехватить сниффером tcpdump, Wireshark и др.,если только ICMP сообщения не отключены/заблокированы
### nmap		
nmap - сетевой сканер. Его задача:
+ находить сетевые узлы;
+ сканировать открытые порты с целью сбора информации о сети (это часто делается непосредственно перед атакой);
+ определять работающие на этих портах службы.

1. Сканирование портов TCP в диапазоне от A до B на определённом узле, аналогично программе nc (т.е. с установкой соединения TCP посредством «рукопожатия»). Опция -sT означает режим сканирования — «рукопожатие TCP»		
```console
nmap -sT -pA-B адрес_узла
```
2. То же самое, но намного быстрее (посредством отправки только пакетов TCP SYN, без установки соединения); требуются права пользователя root. -sS означает режим сканирования — SYN:
```console
sudo nmap -sS -pA-B адрес_узла
```
3. Для сканирования портов UDP; эта операция по сути своей намного медленнее, даже чем режим с опцией -sT. -sU означает режим сканирования — UDP. Также нужны права root:
```console
sudo nmap -sU -pA-B адрес_узла
```
4. Для поиска доступных в сети узлов,-sP означает режим сканирования — ping (хотя, на самое деле, сам ping для сканирования используется не всегда, в локальных сетях вместо этого применяется протокол ARP):
```console
nmap -sP адрес_сети/маска
```
5. Для сканирование списка портов заданного узла:
```console
nmap -Pn -sT -p22,9099,10000 адрес_узла 
```
```-Pn``` (No Ping) - отключает этап пинга перед сканированием портов. Nmap по умолчанию пытается определить, активен ли целевой узел, отправляя пинг (ICMP echo request) и другие типы запросов. Если узел не отвечает на пинг, Nmap предполагает, что он недоступен, и завершает сканирование. Параметр -Pn указывает Nmap не выполнять этот предварительный шаг и продолжать сканирование портов, даже если узел не отвечает на пинг. Полезно, если целевой хост блокирует ICMP или другие пакеты обнаружения

*Пример вывода:*
```console
[st00@c7-sandbox ~]$ nmap -sT -p9000-9100 192.168.40.150
Starting Nmap 6.40 ( http://nmap.org ) at 2022-08-01 00:42 MSK
Nmap scan report for 192.168.40.150
Host is up (0.029s latency).
Not shown: 86 closed ports
PORT STATE SERVICE
9000/tcp open cslistener
9011/tcp open unknown
...
9031/tcp open unknown
Nmap done: 1 IP address (1 host up) scanned in 0.14 seconds
```

```nmap``` выводит: номер порта (PORT), его состояние (STATE) и службу, его слушающую (SERVICE)

#### Список состояний просканированных Nmap портов:
+ open - доступен для клиентов, не заблокирован межсетевым экраном, прослушивается неким приложением на серверной стороне;
+ closed - доступен для клиентов и не заблокирован межсетевым экраном, не прослушивается ни одним приложением;
+ filtered - заблокирован межсетевым экраном, все пакеты, отправленные на этот порт, были отброшены. Неизвестно, прослушивается ли этот порт каким-либо приложением;
+ unfiltered (нефильтрован) - Порт доступен, но Nmap не может определить, открыт он или закрыт. Этот статус может возникнуть при некоторых типах сканирования, таких как ACK scan - в отличие от других типов сканирования, таких как SYN scan, ACK scan не определяет, открыт ли порт, а выявляет, какие порты фильтруются фаерволом. Этот метод используется для обхода некоторых типов фильтров и получения информации о настройках сети;
+ open|filtered (открыт или фильтрован) - Nmap не может определить, открыт порт или фильтрован. Это может случиться, если пакет не возвращает явного ответа. Такое состояние часто возникает при UDP сканировании;
+ closed|filtered (закрыт или фильтрован) - Nmap не может определить, закрыт порт или фильтрован. Такое состояние может появиться при сканировании IP ID
### Connection refused
Ошибка “Connection refused” ("в подключении отказано") обычно возникает при попытке соединения с закрытым портом и формируется на уровне TCP/IP стека операционной системы (вне зависимости от того, какая команда используется - nc, telnet, curl, ssh и т. д.). Причины:	
+ остановка сетевого приложения на удаленном сервере, которое должно было прослушивать порт назначения
+ указание неверного порта
+ работа межсетевого экрана

*Протокол TCP:* Если настроить сниффер во время выполнения команды ```sudo nmap -sS -pA-B адрес_узла``` или ```nmap -sT -pA-B адрес_узла```, то при ошибке "Connection refused" в сетевом потоке также будет пакет RST

*Протокол UDP:* Сообщение "Connection refused" выдается только для TCP сканирования и указывает на то, что на целевом порте нет приложения, которое слушает соединения. Это сообщение не используется в контексте UDP сканирования, поскольку UDP — это протокол без установки соединения, и закрытие порта обычно определяется через ICMP сообщения, а не через отказ в соединении. Если настроить сниффер во время выполнения команды ```sudo nmap -sU -pA-B адрес_узла```, то хотя при протоколе UDP механизм сообщения о закрытых портах не предусмотрен (пакет с установленным флагом RST, как для TCP-запроса, в ответ не шлется), но, как сказано в стандарте протокола ICMP может (но обязательно) от удалённой ОС быть получено сообщение ICMP "Destination Unreachable" с кодом "Port Unreachable" и в этом случае это указывает на то, что порт закрыт и не прослушивается ни одним приложением.
### Connection timeout
Хотя сообщения "Connection timeout" чаще ассоциируется с TCP, таймауты также могут возникать и при UDP сканировании. Nmap интерпретирует отсутствие ответа (таймаут) для обоих протоколов (TCP и UDP) и использует это для определения состояния порта, выводя соответствующие состояния, такие как "filtered" или "open|filtered" для UDP и "filtered" для TCP.

Ошибка "Connection timeout" как и "Connection refused" является стандартным сообщением, которое выводят различные команды при неудачной попытке установить соединение с удаленным сервером. Независимо от того, какая команда используется (nc, telnet, curl, ssh и т. д.), если удаленный сервер не отвечает в течение определенного времени (тайм-аут), вы получите сообщение "Connection timed out":
+ при попытке соединиться с недоступным удалённым узлом;
+ при блокировании порта назначения со стороны межсетевого экрана (в т.ч. при отсутствии ответа на пакет SYN для TCP-протокола).

Чтобы уточнить причину нужно:
1. Определить, находится ли этот удалённый узел в сети с помощью других способов, например следующих:
   1. ```ping``` / ```traceroute``` с использованием протокола ICMP.
   2. ```nc -z``` с использованием других (возможно, открытых) портов.
   3. ```nmap``` со сканированием диапазона портов (только если у вас есть на это разрешение).
2. Если узел обнаружен в сети, но не отвечает на определённые запросы и вы получаете сообщения об ошибке «Connection timeout», значит, этот порт и (или) протокол блокируются межсетевым экраном.
### Конфликты портов
#### Address already in use
При запуске приложения, работающего с портом X, который уже используется другим приложением, вы получите ошибку «Address already in use» (адрес уже используется). При обнаружении этой ошибки (в журнале приложения или в выводе команды) список открытых портов необходимо проверить с помощью программы ```netstat``` или ```ss``` локально. Пример:
```console
[st00@c7-sandbox ~]$ nc -l 15672
nc: Address already in use

[st00@c7-sandbox ~]$ netstat -ntl | egrep :15672
tcp        0      0 0.0.0.0:15672           0.0.0.0:*               LISTEN
```

*Примечание 1: При наличии прав администратора root выполнить ```netstat -nptl``` (добавили опцию -p) для получения информации про процесс, использующий в текущий момент этот порт.*

*Примечание 2: ```nc -l №_порта``` - запуск программы ```nc``` в режиме сервера, прослушивающего TCP-порт, а ```nc -u -l №_порта``` - в режиме сервера, прослушивающего UDP-порт*

#### Permission denied
В UNIX открытие портов TCP и UDP с номерами меньше 1024 разрешено только пользователю root. Если процесс, запущенный от имени простого пользователя, попытается открыть один из таких портов, то получит ошибку «Permission denied»
## Проблемы прикладного уровня
Здесь речь не о логических дефектах, а о том, что у похожих программных продуктов могут быть отличающиеся реализации протоколов прикладного уровня (HTTP в том числе). 

*Например, в официальном описании протокола HTTP говорится следующее:*
+ *Каждая строка в запросе клиента должна заканчиваться символами CRLF.*
+ *Но лучше, если серверное приложение также сможет работать и с одним символом LF на конце строки.*
## Основы работы межсетевых экранов
Межсетевой экран — это программное обеспечение или сетевое устройство, блокирующее или пропускающее определённые сетевые пакеты согласно настроенным правилам.
### Состояния и правила межсетевых экранов
+ **Отключён**. Часто встречается на клиентских компьютерах. Например, на узлах, работающих на ОС Windows, могут присутствовать отключённые межсетевые экраны.
+ **"Allow All" ("Allow by Default")**. Включён с правилами по умолчанию, означающими разрешение всего трафика и блокировку только явно указанного. Такую конфигурацию часто можно встретить на клиентских узлах, серверах и сетевом оборудовании во внутренних сетях компаний.
+ **"Deny All" ("Deny by Default")**. Включён с правилами по умолчанию, означающими блокировку всего трафика и разрешение только явно указанных пакетов. Такая конфигурация типична для корпоративного окружения, которому характерны высокие требования к безопасности, и для серверов, доступных из глобальной сети Интернет, которым нужна защита от атак злоумышленников.

![Варианты межсетевых экранов, сконфигурированных на клиентских компьютерах, серверах и сетевых устройствах](resources/lot-of-firewalls-to-publish.drawio.png)

Варианты межсетевых экранов, сконфигурированных на клиентских компьютерах, серверах и сетевых устройствах

### Элементы типичного правила межсетевого экрана
+ Описание пакетов, в которое могут входить следующие сведения:
  + IP-адрес(а) назначения и (или) источника.
  + протокол транспортного уровня.
  + номер(а) порта(ов) назначения и (или) источника.
  + сетевой интерфейс, используемый в ходе этого сетевого взаимодействия.
+ Действия для этих пакетов, например, следующие:
  + Блокировать (**block**) (также могут использоваться термины: отбросить (**drop**), запретить (**deny**) и т. п.). Соответствующие пакеты молча отбрасываются так, что ни клиент, ни сервер не узнают о блокировке.
    + Когда межсетевой экран применяет правило "block" к определенному трафику, он просто отбрасывает этот трафик, не предоставляя ответа отправителю.
    + Для отправителя это может выглядеть так, как если целевой хост не отвечает на запрос или как недостижимость хоста. Он не получит подтверждения доставки пакета.
    + В случае TCP/UDP-соединения это может привести к тому, что отправитель будет ждать ответа (Connection timeout) и попытается повторно отправить пакеты или завершить соединение.
  + Разрешить (**allow**) (также могут использоваться термины: принимать (**accept**), пропустить (**pass**) и т. п.).
  + В некоторых случаях: выполнить ещё что-либо, согласно функциям межсетевого экрана. Например, в межсетевом экране ОС Linux предусмотрено также действие **REJECT** (отклонить), означающее отбрасывание входящих пакетов и имитацию закрытого порта назначения.
    + Когда применяется правило "reject", межсетевой экран отправляет ICMP сообщение о недоступности порта или хоста обратно к отправителю.
    + Для отправителя это выглядит как явное сообщение о том, что порт или хост недоступен, и отправитель получит это сообщение в качестве ответа на свой запрос.
    + В случае TCP/UDP-соединений, это сообщение может содержать информацию, указывающую на то, что порт закрыт (ICMP сообщение типа 3, код 3 - Port Unreachable).

![Пример правил межсетевого экрана, применяемых к входящему трафику](resources/14_2.png)

Расшифровка примера. Каждая строка расшифровки соответствует строке на рисунке с соответствующим номером в колонке num:
1. Разрешено всё приходящее на интерфейс lo (вспомните предыдущие главы — lo означает loopback, т е. механизм «обратной петли», с адресом 127.0.0.1). Это необходимо некоторым управляющим приложениям, которые работают на этом сервере.
2. Разрешены пакеты, идущие на порт TCP 22 от любых отправителей и получателей.
3. Разрешены пакеты с а) состоянием RELATED (связанный), т. е. это ответы SYN-ACK от удалённых серверов - это "почти что" установленное соединение, или б) состоянием ESTABLISHED (установлено), т. е. это пакеты установленного соединения.
4. Разрешены пакеты, идущие на порты TCP с номерами между 9000 и 9100.
5. Разрешены все пакеты из сети 192.168.40.0/24.
6. Разрешены пакеты протокола ICMP от любых отправителей и получателей.
7. Пакеты TCP на порты 111, 4369, 15672, 25672 разрешены, если IP-адрес получателя — 192.168.40.14.

Все остальные пакеты блокируются, как указано в первой строке вывода: «policy DROP» (запрещающая политика). *Конфигурация межсетевого экрана, показанная в этом примере, характерна для корпоративных серверов и серверов Интернета.*
### Другие способы обнаружения межсетевого экрана (кроме Nmap)
Если недоступен Nmap, то существуют альтернативные способы обнаружения сетевого экрана:
+ [nc](#nc)
+ tcpdump. Если в вашем рабочем окружении нет возможности использовать nc или nmap, то могут помочь анализаторы сетевых пакетов, наподобие tcpdump. В примере ниже мы видим серию пакетов TCP SYN (отмеченных буквой «S», означающей флаг SYN), отправленных на удалённый сервер от клиента 192.168.40.100 во время показанного выше запуска программы nc, но ответов сервера не наблюдается. Это может означать, что этот порт скрыт за межсетевым экраном (но предварительно надо убедиться с помощью ping или nc, например, что узел доступен).
```console
[st00@c7-backend ~]$ tcpdump -vnn -ttt -i eth0 tcp and port 22
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
 00:00:00.000000 IP (tos 0x0, ttl 64, id 60589, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xd6ea), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297328130 ecr 0,nop,wscale 7], length 0
 00:00:01.001736 IP (tos 0x0, ttl 64, id 60590, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xd300), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297329132 ecr 0,nop,wscale 7], length 0
 00:00:02.003947 IP (tos 0x0, ttl 64, id 60591, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42332 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xcb2c), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297331136 ecr 0,nop,wscale 7], length 0
 00:00:06.084977 IP (tos 0x0, ttl 64, id 48874, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.40.100.42340 > 5.255.255.242.22: Flags [S], cksum 0xef2c (incorrect -> 0xa0dc), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297337221 ecr 0,nop,wscale 7], length 0
 00:00:01.003010 IP (tos 0x0, ttl 64, id 48875, offset 0, flags [DF], proto TCP (6), length 60)
[ ... more similar packets below ... ]
```
+ traceroute можно использовать для определения возможного адреса межсетевого экрана, блокирующего сетевой поток:
1. Сначала нужно определить маршрут между узлами клиента и сервера, используя любой протокол (ICMP, TCP,UDP), принимаемый сервером и не блокируемый межсетевым экраном
```console
[st00@c7-backend ~]$ traceroute -nI 5.255.255.242
traceroute to 5.255.255.242 (5.255.255.242), 30 hops max, 60 byte packets
 1  192.168.40.2  0.213 ms  0.203 ms  0.196 ms
 2  5.200.37.73  0.300 ms  0.315 ms  0.313 ms
 3  81.27.241.116  0.676 ms  0.738 ms  0.736 ms
 4  * * *
 5  81.27.254.74  12.071 ms  12.079 ms  12.078 ms
 6  * * *
 7  5.255.255.242  12.215 ms  12.194 ms  12.169 ms
```
2. Теперь нужно определить маршрут, используя именно те протокол и порт, которые нас интересуют (например, TCP и 22).
```console
[st00@c7-backend ~]$ traceroute -n -T -p 22 5.255.255.242
traceroute to 5.255.255.242 (5.255.255.242), 30 hops max, 60 byte packets
 1  192.168.40.2  0.155 ms  0.108 ms  0.060 ms
 2  5.200.37.73  0.367 ms  0.323 ms  0.288 ms
 3  81.27.241.116  0.775 ms  0.741 ms  0.711 ms
 4  * * *
 5  81.27.254.74  9.475 ms  8.185 ms  8.152 ms
 6  93.158.172.23  18.989 ms 93.158.160.113  28.479 ms 93.158.160.151  26.504 ms
 7  * * *
 8  * * *
[ ... all lines below are * * * ... ]
```
+ сравним два варианта и поразмыслим логически:
1. Пакеты для порта TCP 22 передаются успешно на шагах от 1 до 6.
2. Согласно маршрута, построенного с помощью ICMP, сервером назначения должен быть 7-й узел.
3. Если программа traceroute непрерывно показывает символы «* * *» до остановки своей работы, значит, пакеты где-то блокируются межсетевым экраном.
4. Во время второй ничего не видно, начиная с 7-го промежуточного узла.
5. Поэтому наиболее вероятно, что ограничительные правила межсетевого экрана установлены на узле № 7 (узел назначения 5.255.255.242).