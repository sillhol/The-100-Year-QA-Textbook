# 15 HTTP, URL, JSON, API
## HTTP
### HTTP/1.1
HyperText Transfer Protocol - это протокол прикладного уровня для передачи гипертекста (например, веб-страниц) по сети. Он является основой для обмена данными в Интернете, обеспечивая коммуникацию между веб-браузерами и веб-серверами. Особенности:
+ HTTP-сообщение отправляется открытым текстом, передаваемая информация может быть легко перехвачена и расшифрована.
+ По умолчанию HTTP-запросы отправляются на порт 80.
### HTTPS
HyperText Transfer Protocol Secure - расширение HTTP, использующее шифрование для повышения уровня безопасности передачи данных:
+ Сообщения HTTPS шифруются.
+ Шифрование требует времени и вычислительных ресурсов, поэтому HTTPS обычно работает медленнее, чем HTTP.
+ HTTPS-запросы по умолчанию отправляются на порт 443.
#### Шифрование при передаче данных
Для шифрования информации, передаваемой по протоколу HTTPS, на сервере должен быть установлен так называемый сертификат SSL (Secure Sockets Layer) или TLS (Transport Layer Security, улучшенная версия SSL). Сертификат SSL/TLS состоит из двух частей: открытого ключа, используемого для шифрования данных, и закрытого ключа, используемого для их расшифровки и видимого только для вашего сайта. Практически, ключи представляют собой пару уникальных текстовых файлов, созданных вместе и выглядящих для пользователя как набор непонятных символов. Чтобы сгенерировать такую пару, необходимо отправить запрос на подписание сертификата (CSR) в специальную организацию - центр сертификации (CA), сообщив ему о назначении вашего сайта, названии организации и т. д. Запрос имеет специальный формат и может быть автоматически сгенерирован специальными программами.
##### Процедура шифрования данных
1. *Инициация соединения*: Клиент отправляет запрос на сервер для установления соединения по HTTPS, обычно указывая URL, начинающийся с "https://".
2. *TLS/SSL Handshake* (рукопожатие)
   1. *Client Hello*: Клиент отправляет сообщение "Client Hello", содержащее:
      1. Версию протокола TLS/SSL, которую поддерживает клиент.
      2. Список шифров (алгоритмов шифрования), поддерживаемых клиентом.
      3. Случайное число (random number), которое будет использоваться для создания сессионного ключа.
   2. *Server Hello*: Сервер отвечает сообщением "Server Hello", содержащее:
      1. Выбранную версию протокола TLS/SSL.
      2. Выбранный шифр из списка, предложенного клиентом.
      3. Случайное число от сервера.
3. *Аутентификация и передача сертификата*
   1. *Сертификат сервера*: Сервер отправляет свой цифровой сертификат, выданный доверенным центром сертификации (CA). Этот сертификат содержит:
      1. Публичный ключ сервера.
      2. Информацию о сервере и о центре сертификации.
      3. Подпись центра сертификации, подтверждающую подлинность сертификата.
   2. *Проверка сертификата*: Клиент проверяет сертификат сервера, чтобы убедиться, что он:
      1. Выдан доверенным центром сертификации.
      2. Не просрочен и не отозван.
      3. Соответствует имени сервера (имя хоста в URL).
4. *Генерация сессионного ключа*
   1. *Client Key Exchange*: Клиент создает премастер-секрет (pre-master secret), шифрует его публичным ключом сервера и отправляет на сервер. Только сервер может расшифровать этот премастер-секрет своим приватным ключом.
   2. *Создание мастер-секрета*: Клиент и сервер используют премастер-секрет и случайные числа, обменянные ранее, для создания мастер-секрета. Мастер-секрет используется для генерации сессионных ключей, которые будут использоваться для симметричного шифрования данных.
5. *Завершение рукопожатия*
   1. *Client Finished*: Клиент отправляет сообщение "Finished", зашифрованное сессионным ключом. Это сообщение содержит хэш всех предыдущих сообщений рукопожатия, чтобы сервер мог подтвердить целостность процесса.
   2. *Server Finished*: Сервер отвечает аналогичным образом, отправляя сообщение "Finished", также зашифрованное сессионным ключом.
6. *Передача данных*: После успешного завершения рукопожатия клиент и сервер начинают передавать данные по зашифрованному каналу, используя симметричное шифрование с сессионными ключами.
### HTTP/1.1 vs HTTP/2 vs HTTP/3 vs HTTPS
#### HTTP/1.1
+ Год выпуска: 1997
+ Характеристики:
  + Поддерживает постоянные соединения (keep-alive), что позволяет использовать одно соединение для передачи нескольких запросов и ответов.
  + Ограничение на количество одновременных соединений с одним сервером (обычно 6-8).
  + Серверы не могут инициировать передачу данных без запроса клиента (односторонняя связь).
  + Заголовки передаются в виде текста, что может привести к избыточности и большим объемам данных.
#### HTTP/2
+ Год выпуска: 2015
+ Характеристики:
  + Мультиплексирование: позволяет отправлять несколько запросов и получать несколько ответов одновременно по одному TCP-соединению.
  + Сжатие заголовков: заголовки сжимаются, уменьшая объем передаваемых данных.
  + Сервер может инициировать передачу данных (Server Push), что позволяет отправлять данные клиенту до того, как он их запросит.
  + Бинарный протокол, что улучшает производительность и снижает задержки по сравнению с текстовым HTTP/1.1.
#### HTTP/3
+ Год выпуска: 2020 (экспериментальная реализация), 2022 (RFC 9114)
+ Характеристики:
  + Основан на протоколе QUIC, который работает поверх UDP вместо TCP.
  + Быстрое восстановление после потери пакетов благодаря встроенным механизмам контроля потока и восстановления данных.
  + Мультиплексирование без блокировки: позволяет избежать проблем с задержками и блокировками, связанных с HTTP/2.
  + Уменьшенные задержки и улучшенная производительность, особенно в мобильных сетях и сетях с высоким уровнем потерь.
#### HTTPS
+ Описание:
  + HTTPS — это расширение HTTP, использующее SSL/TLS для шифрования данных.
  + Обеспечивает защиту передаваемых данных от перехвата и подделки.
  + Поддерживается всеми версиями HTTP (HTTP/1.1, HTTP/2, HTTP/3).
  + Включает механизмы аутентификации сервера и иногда клиента.
  + Использование HTTPS обязательно для защиты чувствительных данных и рекомендуется для всех веб-сайтов.
#### Основные различия и преимущества
+ HTTP/1.1: Стандартный, простой в реализации, но ограничен в производительности из-за последовательной передачи данных.
+ HTTP/2: Улучшенная производительность за счет мультиплексирования и сжатия заголовков, позволяет быстрее загружать веб-страницы.
+ HTTP/3: Еще более быстрая и эффективная передача данных благодаря использованию QUIC и работы поверх UDP, лучше подходит для современных сетей с высокой задержкой.
+ HTTPS: Обеспечивает безопасность передачи данных, защищает от атак типа "человек посередине" и обеспечивает конфиденциальность и целостность данных.
#### Выбор протокола
+ Для безопасности и конфиденциальности данных: Используйте HTTPS.
+ Для максимальной производительности и уменьшения задержек: Используйте HTTP/2 или HTTP/3, если они поддерживаются сервером и клиентом.
+ Для совместимости со старыми системами: Используйте HTTP/1.1.
#### stateless protocol
HTTP (HTTP/1.1, HTTP/2, HTTP/3), HTTPS - протоколы без состояния (stateless protocol). С точки зрения сервера, каждый новый запрос как будто поступает от совершенно нового клиента (сервер не помнит, что вы только что были на предыдущей странице или авторизовались). Чтобы обеспечить и согласованность запросов, используются:
+ Cookies (куки): Маленькие файлы, которые сервер отправляет браузеру клиента, и которые затем отправляются обратно серверу с каждым последующим запросом. Таким образом, сервер может "узнавать" клиента и отслеживать его действия.
+ Сессии (sessions): Сервер может создавать уникальные идентификаторы сессий для каждого пользователя, которые сохраняются в куки или в URL. Эти идентификаторы позволяют серверу связывать текущий запрос с предыдущими запросами от того же клиента.
+ Заголовки HTTP (HTTP headers): В HTTP-заголовках могут передаваться дополнительные данные, которые помогают серверу идентифицировать и отслеживать клиента. Например, заголовок Authorization может содержать токен, который сервер использует для проверки прав доступа клиента.
## URL, URN, URI
Цель HTTP-запроса - ресурс. Существует 3 типа идентификаторов ресурса в Интернете:
1. URL (Uniform Resource Locator): Протокол + хост + порт + путь к сайту
2. URI (Uniform Resource Identifier): URL + указатель на конкретный ресурс на сайте
3. Термин URN (Uniform Resource Name) имеет два значения:
   1. Иногда URN означает URL без протокола.
   2. Чаще - это уникальная идентификация ресурса в определенном пространстве (книги, RFC и т.д.), в специальном пространстве, начинающемся с urn: ```urn:ietf:rfc:7230``` (серверы реализуют mapping между представлением URN и URL)

Приведенная ниже схема иллюстрирует связь между URI, URL и URN в первом понимании.

<img src="resources/url_NOPROCESS_.png" alt="связь между URI, URL и URN" width="70%"/>

### Структура URL
<img src="resources/url_NOPROCESS1_.png" alt="Структура URL" width="70%"/>

1. Протокол (protocol) - набор правил, которые необходимо использовать для доступа к ресурсу. Это может быть:
   1. HTTP
   2. HTTPS
   3. FTP и другие
2. Хост (host) - Адрес сервера - www.nexus.oy...- - это как строка "город-улица-здание" в физическом адресе. Он может быть представлен в виде:
   1. слов, разделенных точками (например, mentorpiece.education или nexus.oy.defects.tst) - каждое слово является уровнем домена
   2. цифр, разделенные точками, в данном случае это IP-адрес (например, 192.168.40.100/)
   3. localhost (означает локальный компьютер, IP-адрес по умолчанию - 127.0.0.1)
4. Порт (port)- Целевое приложение "слушает" этот порт и обрабатывает соответствующие запросы - 8079 - это как номер квартиры внутри здания
   1. Порт по умолчанию для протокола HTTP - 80
   2. Порт по умолчанию для протокола HTTPS - 443
   3. Порт по умолчанию для протокола FTP (opens in a new tab) - 21
   4. Порт по умолчанию для почтового протокола (SMTP)  - 587
5. Путь (path)- путь к ресурсу - /service/rest/v1/search - рассматривайте его как путь к комнате внутри этой квартиры. Это может быть:
   1. Ресурс в Интернете
   2. Сигнатура API-метода /api/v0/airports
6. Параметры (parameters) - некоторые значения для модификации запроса - ?sort=version и ?direction=desc - воспринимайте это как вопрос типа "Есть ли у вас в комнате такая книга?".

*Примечание:*
+ URL чаще встречаются в повседневной работе в Интернете, поскольку они используются для доступа к веб-ресурсам
+ URN встречаются реже, но служат конкретной цели обеспечения постоянных и независимых от местоположения идентификаторов ресурсов, что делает их ценными в некоторых специализированных областях, где стабильность и уникальность ресурсов имеют первостепенное значение.
### Методы HTTP
HTTP определяет типы запросов, которые могут быть отправлены от клиента к серверу. Эти типы называются HTTP-методами:
+ ``GET`` - используется для чтения данных с сервера
+ ```POST``` - используется для создания чего-либо на стороне сервера. Например, создать новую учетную запись пользователя.
+ ```PUT``` - используется для полного обновления ресурса (клиент должен отправить полный набор данных ресурса, даже если необходимо изменить только одну часть ресурса). Он заменяет весь текущий ресурс на сервере новыми данными, переданными в запросе. ```PUT``` является идемпотентным методом. Это означает, что повторный вызов PUT с одинаковыми данными приведет к одному и тому же результату, не изменяя ресурс повторно
+ ```DELETE``` - что-то удалить.
+ ```PATCH``` - используется для частичного обновления ресурса. Он вносит изменения только в те части ресурса, которые указаны в запросе. ```PATCH``` может быть неидемпотентным, что означает, что повторные вызовы могут привести к различным результатам
+ ```HEAD``` - аналогично ```GET```, но возвращаются только заголовки ответа (некоторая метаинформация) (без данных).
+ ```OPTIONS``` - метод не выполняет никаких изменений и не возвращает данные ресурса; вместо этого он возвращает информацию о том, какие методы HTTP и другие параметры коммуникации поддерживаются. Метод ```OPTIONS``` широко используется в механизме CORS для выполнения предварительных запросов (preflight requests). Когда браузер делает запрос к ресурсу на другом домене, сначала отправляется запрос OPTIONS для проверки разрешений. Ответ на этот запрос включает информацию о том, разрешен ли доступ и какие методы и заголовки допустимы. Пример предварительного запроса (preflight request):
```console
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: http://www.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header
```
Пример ответа на предварительный запрос:
```console
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://www.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-Custom-Header
```
+ ```CONNECT``` - используется для установления туннеля связи между клиентом и целевым сервером через промежуточный сервер (создание туннелей для HTTPS, для создания туннелей для VPN-соединений и других туннельных протоколов, где требуется передача данных через защищенный канал).
+ ```TRACE``` - используется для диагностики, отладки сетевых соединений, отладка прокси-серверов и шлюзов, проверка целостности запроса. Он позволяет клиенту отправить запрос на сервер и получить в ответе точную копию этого запроса. Это помогает определить, какие изменения или модификации были внесены в запрос при его прохождении через различные промежуточные узлы (прокси-серверы, шлюзы и т.д.). Метод TRACE может представлять угрозу безопасности, так как он возвращает клиенту всю информацию запроса, включая возможные конфиденциальные данные и заголовки. Это может быть использовано злоумышленниками для проведения атак, таких как Cross-Site Tracing (XST). Многие веб-серверы и прокси-серверы по умолчанию отключают поддержку метода TRACE или ограничивают его использование для повышения безопасности.
#### CRUD
Четыре метода (```GET```, ```POST```, ```PUT```, ``DELETE``) называют ``CRUD``: CREATE-READ-UPDATE-DELETE (где READ относится к GET).
### HTTP Запрос/Ответ
<img src="resources/Req_resp_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

### Коды состояния HTTP
+ 200 OK. Все в порядке, вот содержимое запрашиваемой страницы.
+ 201 Created (201 Создано). Запрашиваемый ресурс успешно создан.
+ 301 Moved Permanently. (301 Перемещено навсегда) Ресурс с этим URI навсегда перемещен по адресу, указанному в заголовках на стороне сервера.
+ 302 Moved Temporarily. (301 Перемещено временно) Аналогично, но перемещено временно. Часто 301 и 302 означают одно и то же, это зависит от настроек веб-сервера (или веб-приложения). Так что основная идея кодов
+ 301/302 - "эй, просто возьмите новый адрес и перейдите туда".
+ 304 Not Modified. (304 Не изменен) Если был использован заголовок клиента "If-Modified-Since" (если изменен, то...) и ресурс не был изменен, то нет необходимости получать его снова.
+ 400 Bad Request. (400 Ошибочный запрос) Что-то не так с вашим запросом.
+ 401 Unauthorized. (401 Неавторизованный) Вы должны быть авторизованы, чтобы открыть этот URI. Когда сервер отвечает этим кодом, он также показывает вам форму авторизации для ввода логина и пароля.
+ 403 Forbidden. (403 Запрещено) Доступ запрещен. Показывается, например, когда введены неправильные логин и/или пароль.
+ 404 Not found. (404 Не найдено) Ресурс с таким URI не существует (или сервер хочет, чтобы вы так думали).
+ 418 I’m a teapot. (418 Я чайник) Код из первоапрельской шутки, на самом деле не должен работать.
+ 500 Internal Server Error. (500 Внутренняя ошибка сервера) Что-то не так с сервером.
+ 502 Bad Gateway. (502 Неудачное перенаправление) Сервер попытался перенаправить ваш запрос на другой сервер, но не преуспел в этом.
+ 503 Service Unavailable. (503 Сервер недоступен) По сути, то же самое, что 500.
+ 504 Gateway Timeout. (504 Таймаут шлюза) То же самое, что и 502, но в случае ошибки тайм-аута.
### Заголовки HTTP
Вторая часть HTTP-запроса или ответа - раздел заголовков.
#### Заголовки запросов
##### General Headers (Общие заголовки):
+ ```Host```: Указывает доменное имя и порт сервера, к которому обращается клиент.
+ ```Connection```: Управляет параметрами текущего соединения. Например, ```Connection: keep-alive``` сохраняет соединение открытым для последующих запросов.
+ ```Cache-Control```: Управляет кешированием запросов. Например, ```Cache-Control: no-cache```.
##### Request Headers (Заголовки запросов):
+ ```Accept```: Указывает типы медиа, которые клиент может обработать. Например, ```Accept: text/html```.
+ ```User-Agent```: Идентифицирует клиентское приложение. Например, ```User-Agent: Mozilla/5.0```.
+ ```Accept-Language```: Указывает предпочтительные языки. Например, ```Accept-Language: en-US```.
+ ```Authorization```: Передает учетные данные для аутентификации. Например, ```Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела запроса. Например, ```Content-Type: application/json```.
+ ```Content-Length```: Указывает длину тела запроса в байтах. Например, ```Content-Length: 348```.
#### Заголовки ответов
##### General Headers (Общие заголовки):
+ ```Date```: Указывает дату и время, когда сервер сгенерировал ответ. Например, ```Date: Wed, 12 Jun 2024 15:00:00 GMT```.
##### Response Headers (Заголовки ответов):
+ ```Server```: Идентифицирует серверное программное обеспечение. Например, ```Server: Apache/2.4.1 (Unix)```.
+ ```Set-Cookie```: Устанавливает cookie в браузере. Например, ```Set-Cookie: sessionId=abc123; Path=/; Secure; HttpOnly```.
+ ```WWW-Authenticate```: Указывает метод аутентификации, требуемый для доступа к ресурсу. Например, ```WWW-Authenticate: Basic realm="Access to the site"```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела ответа. Например, ```Content-Type: text/html; charset=UTF-8```.
+ ```Content-Length```: Указывает длину тела ответа в байтах. Например, ```Content-Length: 348```.
+ ```Content-Encoding```: Указывает кодировку, использованную для сжатия тела. Например, ```Content-Encoding: gzip```.
#### Другие важные заголовки
+ ```Referer```: Указывает URL, с которого был сделан запрос. Например, ```Referer: https://www.example.com```.
+ ```Location```: Используется для перенаправлений, указывает новый URL. Например, ```Location: https://www.example.com/newpage```.
+ ```Transfer-Encoding```: Управляет фрагментацией тела сообщения. Например, ```Transfer-Encoding: chunked```.
+ ```X-Content-Type-Options```: Указывает браузеру не изменять MIME-тип. Например, ```X-Content-Type-Options: nosniff```.
+ ```Strict-Transport-Security```: Указывает политику безопасности для HTTPS. Например, ```Strict-Transport-Security: max-age=31536000```.

*Примечание:*
Существуют пользовательские заголовки, поддерживаемые только конкретным приложением. Например, вы можете отправить в запросе заголовок x-correlation-id, и ваш сервер должен знать, как обработать этот заголовок.
### Тело HTTP-запроса/ответа
HTTP-запрос/ответ может содержать полезную нагрузку, которая помещается в часть Request или Response Body. Тело ответа может содержать:
+ исходный код веб-страницы или только что созданные 
+ данные учетной записи пользователя, например, в формате JSON
+ различные типы данных (медиатипы в соответствии со стандартом): аудио, изображение, текст и так далее. При выполнении запроса (PUT, POST) тип данных задается с помощью заголовка ```Content-type```:
  + ```Content-Type: text/html; charset=utf-8```
## JSON
JSON (JavaScript Object Notation) - это легковесный формат обмена данными, широко использующийся в веб-разработке для обмена данными между веб-сервером и клиентом (например, веб-браузером или мобильным приложением). Это фундаментальный формат для создания современных веб-приложений и API (используется как для передачи данных между сервером и веб-приложением, так и в файлах конфигурации и хранения данных).

JSON:
+ стандартизирован: имеет согласованные структуры и форматы данных, хорошо документирован и обладаетширокой инструментальной поддержкой. Всё это облегчают работу по  межсистемному тестированию (созданию тестовых данных, обработке ошибок и сотрудничеству с командами разработчиков);
+ независим от языка программирования (хотя в названии JSON присутствует JavaScript), что делает его универсальным и подходящим для широкого спектра приложений.

JSON:
+ представляет данные в виде набора пар ключ-значение. Каждый ключ - это строка, а значения могут быть строками, числами, булевыми функциями, объектами, массивами или null. Эти наборы пар заключены в фигурные скобки {}
+ игнорирует пробельные символы (пробелы, табуляции, переносы строк) вне строк, что облегчает форматирование для удобства чтения
### Типы данных
1. **Строка**: Строка - это последовательность символов, заключенных в двойные кавычки. Строки используются для представления текста и могут включать буквы, цифры, символы и пробелы. То же самое, что char, varchar, nvarchar в SQL.
2. **Число**: JSON поддерживает как целые числа, так и числа с плавающей точкой. Числа не заключаются в кавычки и могут быть положительными или отрицательными. То же, что и int в SQL.
3. **Булево**: В JSON есть два булевых значения: true (истина) и false (ложь). Эти значения представляют собой логические состояния, такие как true или false, включить или выключить, да или нет. То же самое, что и boolean в SQL.
4. **Объект**: Объект - это неупорядоченная коллекция пар ключ-значение, заключенная в фигурные скобки {}. Ключи - это строки, а значения могут быть любого типа данных JSON, включая другие объекты или массивы. Прямого аналога в SQL нет, но можно просто сказать, что объект - это элемент в списке некоторых вещей, например, каждый аэропорт в списке аэропортов, когда мы выполняем GET /airport без конкретного ID, является объектом.
5. **Массив**: Массив - это упорядоченный список значений, заключенный в квадратные скобки []. Массивы могут содержать значения любого типа данных JSON, включая строки, числа, булевы, объекты и другие массивы. Прямого аналога в SQL также нет, но это список некоторых вещей, заключенных в скобки []. Это может быть что угодно, от объектов до чисел, например, "координаты":[100, 500].
6. **Null**: Специальное значение null означает отсутствие данных или пустое значение. Оно часто используется для обозначения того, что значение намеренно отсутствует или не определено.

<img src="resources/json-introduction_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

## API
API (Application Programming Interface) - это набор правил и инструментов, которые позволяют различным программным приложениям взаимодействовать друг с другом. API определяет методы, которые одно программное приложение может использовать для взаимодействия с другим. Он служит интерфейсом, через который программы могут запрашивать и обмениваться данными и функциональностью. Существуют различные API:
+ Аппаратное обеспечение (например, интерфейс жесткого диска)
+ Операционная система (доступ к файловой системе, доступ к пользовательскому интерфейсу)
+ Относящееся к Web (SOAP, REST, GraphQL)
+ gRPC для микросервисов и высоконагруженных систем
### SOAP
API SOAP (Simple Object Access Protocol) были популярны в начале 2000-х годов, и вы все еще можете найти их в некоторых устаревших приложениях.
#### Основные характеристики SOAP API:
1. XML-формат: SOAP использует XML (eXtensible Markup Language) для форматирования запросов и ответов. XML является гибким и стандартизированным языком разметки, который позволяет точно описывать данные.
2. SOAP обычно работает поверх прикладных протоколов, таких как HTTP и HTTPS. Эти прикладные протоколы в свою очередь используют транспортные протоколы, такие как TCP. SOAP также может работать поверх других прикладных протоколов, таких как SMTP.
3. Сообщения SOAP: Сообщения SOAP состоят из трех основных частей:
   1. Envelope (Конверт): Обертка сообщения, которая определяет, что содержимое является SOAP-сообщением и предоставляет пространство имен.
   2. Header (Заголовок): Необязательная часть, содержащая информацию для маршрутизации и обработки сообщения.
   3. Body (Тело): Основная часть сообщения, содержащая запрос или ответ.
4. Расширяемость: SOAP поддерживает расширяемые архитектуры, позволяя добавлять новые функциональные возможности через заголовки и модули.
5. Стандарты безопасности: SOAP поддерживает WS-Security, что обеспечивает безопасную передачу сообщений через сети.
#### Преимущества SOAP API:
1. Платформенная независимость: SOAP может использоваться на различных платформах и с различными языками программирования благодаря использованию стандартного XML-формата.
2. Безопасность: SOAP включает в себя расширения безопасности, такие как WS-Security, для обеспечения конфиденциальности и целостности данных.
3. Междоменная связь: SOAP легко проходит через междоменные политики и файрволы, так как часто использует HTTP/HTTPS.
4. Формальная спецификация: SOAP имеет четко определенные стандарты и спецификации, что делает его надежным и хорошо документированным протоколом.
#### Примеры использования SOAP API:
1. Банковские и финансовые системы: SOAP часто используется в финансовых приложениях, где важна безопасность и надежность передачи данных.
2. Корпоративные системы: Большие предприятия используют SOAP для интеграции различных систем и приложений внутри организации.
3. Услуги правительственных организаций: SOAP применяется для передачи данных между государственными учреждениями и сервисами, требующими высокой степени безопасности и согласованности.
#### Пример SOAP-сообщения:
```htm
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:m="http://www.example.org/stock">
   <soap:Header>
      <m:Trans>234</m:Trans>
   </soap:Header>
   <soap:Body>
      <m:GetStockPrice>
         <m:StockName>IBM</m:StockName>
      </m:GetStockPrice>
   </soap:Body>
</soap:Envelope>
```
В этом примере SOAP-сообщения запрос отправляется для получения цены акции компании IBM. Конверт оборачивает все сообщение, заголовок содержит идентификатор транзакции, а тело содержит сам запрос.
#### Недостатки SOAP API:
SOAP имеет несколько недостатков по сравнению с другими протоколами обмена сообщениями, такими как REST:
##### Сложность
1. Сложность протокола: SOAP имеет сложную спецификацию, которая включает множество стандартов и расширений (например, WS-Security, WS-AtomicTransaction), что делает его трудным для освоения и реализации.
XML-формат:
2. SOAP использует XML для форматирования сообщений, что добавляет дополнительную нагрузку на парсинг и генерацию данных по сравнению с более легковесными форматами, такими как JSON.
##### Производительность
1. Высокий оверхед: Из-за использования XML и дополнительных заголовков SOAP сообщения могут быть довольно большими, что увеличивает сетевой трафик и время обработки.
2. Скорость выполнения: Процесс сериализации и десериализации XML медленнее по сравнению с JSON, что может замедлить выполнение запросов.
##### Ограниченная совместимость
1. Ограниченная поддержка браузеров: В отличие от REST, который легко интегрируется с AJAX-запросами в веб-браузерах, SOAP требует дополнительной поддержки для работы с JavaScript.
2. Междоменные ограничения: SOAP часто сталкивается с проблемами междоменного обмена данными (cross-origin requests), что требует дополнительных настроек и обходных путей, таких как использование прокси-серверов.
##### Ориентированность на спецификации
1. Строгая структура сообщений: SOAP требует строго соблюдения спецификаций и стандартов, что может быть обременительно для разработчиков и увеличивать время разработки и тестирования.
##### Совместимость с REST
1. Меньшая гибкость: SOAP менее гибок по сравнению с REST, который позволяет использовать различные форматы данных (JSON, XML, HTML) и имеет более простой и интуитивно понятный интерфейс.
##### Инструменты и экосистема
1. Необходимость использования специализированных инструментов: Для работы с SOAP часто требуются специализированные инструменты и библиотеки, что может усложнять разработку и поддержку приложений.
2. `Меньшая популярность: SOAP теряет популярность в пользу REST и других легковесных протоколов, что может ограничить доступность ресурсов, документации и сообщества разработчиков.
### gRPC
gRPC (gRPC Remote Procedure Calls) — современный, высокопроизводительный RPC (Remote Procedure Call) фреймворк, разработанный Google. Он использует HTTP/2 для транспорта и Protocol Buffers (protobuf) для сериализации данных.
#### Преимущества gRPC
1. Высокая производительность: 
   1. gRPC использует HTTP/2, что обеспечивает эффективную передачу данных, мультиплексирование запросов, компрессию заголовков и поддержку server push.
   2. Protocol Buffers обеспечивают более компактное и быстрое кодирование/декодирование данных по сравнению с JSON или XML.
2. Сильная типизация:
   1. gRPC использует строго типизированные контракты, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает лучшее автодополнение и рефакторинг в IDE.
3. Мультиплатформенность:
   1. gRPC поддерживает множество языков программирования, включая C++, Java, Python, Go, Ruby, C#, Node.js и другие, что позволяет использовать его в различных экосистемах.
4. Двусторонний стриминг:
   1. gRPC поддерживает не только одноразовые запросы-ответы, но и потоковые взаимодействия (как клиент-сервер, так и двусторонние), что делает его идеальным для приложений реального времени.
5. Интероперабельность:
   1. Благодаря использованию Protocol Buffers и стандартов HTTP/2, gRPC обеспечивает высокую степень совместимости между различными системами и сервисами.
#### Недостатки gRPC
1. Сложность настройки:
   1. В отличие от REST, который часто используется в веб-разработке и имеет большое количество документации и инструментов, gRPC может потребовать больше усилий для настройки и интеграции, особенно для разработчиков, незнакомых с Protocol Buffers и HTTP/2.
2. Ограниченная поддержка браузеров:
   1. Веб-браузеры не поддерживают HTTP/2 напрямую для gRPC, что требует использования gRPC-Web, дополнительного прокси или промежуточного слоя для взаимодействия с клиентскими веб-приложениями.
3. Изучение новых технологий:
   1. Разработчикам, привыкшим к REST и JSON, может потребоваться время на освоение Protocol Buffers и принципов работы gRPC, что может замедлить начальную разработку.
4. Необходимость в gRPC-специфичных инструментах:
   1. Для генерации клиентских и серверных кодов необходимо использовать специфические инструменты gRPC, что может добавить сложности в процессы сборки и развертывания.
5. Командное управление версиями:
   1. Управление версиями и обновление контрактов может быть сложнее в gRPC из-за строгой типизации и необходимости синхронизации между клиентами и серверами.
#### Примеры использования gRPC
1. Микросервисная архитектура:
   1. gRPC идеально подходит для внутреннего взаимодействия микросервисов благодаря своей высокой производительности и поддержке различных языков программирования.
2. Системы реального времени:
   1. Потоковые возможности gRPC делают его отличным выбором для чатов, видеоконференций, игр и других приложений, требующих низкой задержки и высокой пропускной способности.
3. Интерфейсы для мобильных и IoT-устройств:
   1. Благодаря компактному формату Protocol Buffers, gRPC может эффективно использоваться на устройствах с ограниченными ресурсами, таких как мобильные и IoT-устройства.
#### Заключение
gRPC предоставляет мощные возможности для создания производительных и масштабируемых распределенных систем. Однако, он может быть сложнее в настройке и использовании по сравнению с REST, особенно для разработчиков, привыкших к традиционным веб-технологиям. Выбор между gRPC и другими протоколами, такими как REST, зависит от конкретных требований проекта, включая производительность, сложность, поддерживаемые платформы и тип взаимодействия.
### GraphQL
GraphQL (Graph Query Language) — это язык запросов для API, разработанный Facebook в 2012 году и выпущенный в открытый доступ в 2015 году. GraphQL предоставляет гибкий и эффективный способ взаимодействия с сервером, позволяя клиенту запрашивать именно те данные, которые ему необходимы, и ничего лишнего. Давайте рассмотрим его преимущества и недостатки.
#### Преимущества GraphQL
1. Запрос только необходимых данных:
   1. Клиенты могут запрашивать ровно те поля, которые им нужны, что снижает объем передаваемых данных и повышает производительность.
2. Гибкость запросов:
   1. Клиенты могут комбинировать несколько запросов в одном вызове, что позволяет уменьшить количество сетевых запросов.
3. Типизированная система:
   1. GraphQL использует строгую типизацию схемы, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает автодополнение и документацию прямо в редакторе.
4. Единый эндпоинт:
   1. Все запросы обрабатываются через один эндпоинт, что упрощает архитектуру API и управление запросами.
5. Реализация вложенных запросов:
   1. GraphQL позволяет клиентам делать вложенные запросы, получая связанные данные в одном запросе. Это особенно полезно для сложных данных с вложенными отношениями.
6. Инструменты для разработки:
   1. GraphQL имеет отличные инструменты для разработки и отладки, такие как GraphiQL и Apollo Client, которые помогают разработчикам быстро и эффективно работать с API.
#### Недостатки GraphQL
1. Сложность настройки и обучения:
   1. Первоначальная настройка и обучение GraphQL может быть более сложной по сравнению с REST, особенно для разработчиков, незнакомых с концепцией схем и типизаций.
2. Производительность на сервере:
   1. Обработка запросов GraphQL может потребовать больше ресурсов на сервере, так как сервер должен динамически разбирать запросы и формировать ответ. Особенно это заметно при сложных или неоптимизированных запросах.
3. Кеширование:
   1. Кеширование в GraphQL сложнее реализовать по сравнению с REST. В REST можно использовать кеширование на уровне HTTP, тогда как в GraphQL запросы могут быть более сложными и динамическими, что затрудняет кеширование на уровне сети.
4. Ограничения в инструментах мониторинга и безопасности:
   1. Традиционные инструменты мониторинга и безопасности, которые хорошо работают с REST, могут быть несовместимы с GraphQL или требовать дополнительной настройки.
5. Избыточные данные:
   1. Хотя клиенты могут запрашивать только необходимые данные, неправильное использование GraphQL может привести к запросу избыточных данных, что может негативно сказаться на производительности.
#### Примеры использования GraphQL
1. Facebook: Facebook использует GraphQL для своего мобильного приложения, обеспечивая эффективный и гибкий доступ к данным.
2. GitHub: GitHub предлагает GraphQL API, позволяя разработчикам запрашивать только необходимые данные и получать их в одном запросе.
3. Shopify: Shopify использует GraphQL для своего Storefront API, что позволяет разработчикам создавать гибкие и производительные интерфейсы для интернет-магазинов.
#### Заключение
GraphQL предоставляет мощные и гибкие возможности для разработки API, позволяя клиентам запрашивать только необходимые данные и улучшая производительность и эффективность взаимодействия с сервером. Однако, он требует более сложной настройки и обучения, а также может потребовать дополнительных ресурсов на сервере. Выбор между GraphQL и другими протоколами, такими как REST или gRPC, зависит от конкретных требований проекта, включая гибкость, производительность и сложность реализации.
### Endpoint API<a name="endpoint-api"></a>
Endpoint (конечная точка) в API — это конкретный URL-адрес, по которому можно получить доступ к ресурсу или выполнить определенное действие в рамках API. Endpoint определяет путь, по которому клиент отправляет запрос на сервер для выполнения операции, такой как получение данных, создание ресурса, обновление или удаление.
#### Основные аспекты Endpoint в API:
1. URL-адрес: URL (Uniform Resource Locator) включает в себя доменное имя, путь и, возможно, параметры запроса. Например, в REST API URL может выглядеть так: ```https://api.example.com/users/123```.
2. Метод HTTP: Эндпоинт обычно ассоциируется с одним из HTTP-методов, таких как GET, POST, PUT, DELETE, которые определяют тип операции, которую клиент хочет выполнить.
+ GET: Получение данных.
+ POST: Создание нового ресурса.
+ PUT: Обновление существующего ресурса.
+ DELETE: Удаление ресурса.
3. Ресурсы и действия: Эндпоинты связаны с конкретными ресурсами или действиями. Например:
+ GET /users: Получить список пользователей.
+ POST /users: Создать нового пользователя.
+ GET /users/123: Получить информацию о пользователе с ID 123.
+ PUT /users/123: Обновить информацию о пользователе с ID 123.
+ DELETE /users/123: Удалить пользователя с ID 123.
4. Параметры: Эндпоинты могут включать параметры пути (path parameters) и параметры запроса (query parameters), которые уточняют запрос.
+ Параметры пути: /users/{id}
+ Параметры запроса: /users?sort=asc&limit=10
#### Примеры
##### REST API:
В REST API эндпоинты представляют собой URL-адреса, которые соответствуют ресурсам и действиям над ними. Например:
+ GET /api/products: Получить список продуктов.
+ POST /api/products: Создать новый продукт.
+ GET /api/products/123: Получить информацию о продукте с ID 123.
+ PUT /api/products/123: Обновить продукт с ID 123.
+ DELETE /api/products/123: Удалить продукт с ID 123.
+ GET /api/products?category=electronics: Фильтрация результатов
+ GET /api/posts?page=2&pageSize=10: Пагинация результатов
+ GET /api/articles/456/details: Получение подробностей о ресурсе
+ GET /api/countries/usa/cities/new-york: Получение ресурса с использованием путей
+ GET /api/articles/123/comments: Получение коллекции связанных ресурсов
##### GraphQL API:
В GraphQL API обычно есть один эндпоинт для всех запросов и мутаций, например:
```POST /graphql```: Все запросы и мутации отправляются на этот эндпоинт, а данные и операции указываются в теле запроса.
##### SOAP API:
В SOAP API эндпоинты представляют собой URL-адреса, к которым отправляются SOAP-сообщения. Например:
```POST /service.asmx```: SOAP-запросы отправляются на этот URL-адрес.
##### Заключение
Эндпоинт в API играет ключевую роль в определении того, как клиент взаимодействует с сервером. Он включает URL-адрес, HTTP-метод, ресурсы и параметры, которые вместе определяют конкретное действие, которое должно быть выполнено. Эффективное и понятное определение эндпоинтов является важной частью разработки API, так как оно влияет на удобство использования и производительность системы.
### Документация по API
Документация по API содержит подробную информацию и инструкции о том, как эффективно использовать API и взаимодействовать с ним.

Пример открытого API Petstore на языке Swagger
<img src="resources/petstoreSwaggerList_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

<img src="resources/petstoreSwagger_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

#### Обычно документация по API должна содержать:
1. Обзор:
   + объясняет, что делает API, какие данные или функциональные возможности он предоставляет и почему он полезен.
2. Endpoint'ы: 
   + в документации по API перечислены все доступные [endpoint'ы](#endpoint-api), в которых указано, к каким данным или действиям можно получить доступ через API.
3. Методы запроса: 
   + Эта часть объясняет, какие "действия" вы можете выполнять с каждым endpoint'ом. В мире API эти действия обычно представлены HTTP-методами GET, POST, PUT и DELETE.
4. Параметры: 
   + в документации API подробно описаны параметры, которые можно использовать при выполнении запросов API.
5. Формат ответа: 
   + документация по API подсказывает, какого рода ответ следует ожидать при использовании endpoint’а, объясняя формат данных, которые возвращает API.
6. Обработка ошибок:
   + В документации по API приводятся инструкции о том, как API обрабатывает ошибки, реагируя на недействительные или неожиданные входные данные.
7. Примеры: 
   + Документация по API может содержать примеры использования API, пригодные для тестирования сценариев.
8. Аутентификация:
   + документация по API объясняет, как аутентифицировать себя для безопасного использования API.
9. Ограничения и квоты:
    + документация к API содержит подробную информация об ограничениях API, например, по частоте использования.
#### Существующую документацию можно условно разделить на два блока:
+ классическая документация (веб-страница, полная статичных таблиц и параграфов). Она проста для чтения и понимания, но основным недостатком классического подхода является то, что такая документация может быть устаревшей;
+ динамическая. В большинстве случаев генерируется на лету. Инструменты и спецификации: Swagger , OpenAPI. Пример динамической документации: https://petstore.swagger.io/. Динамическая документация является наиболее актуальной и в некоторых случаях может использоваться для выполнения запросов или даже генерации программного кода (например, генерации исходного кода для клиента API).
### Примеры
1. Репозиторий [Public APIs](https://github.com/public-api-lists/public-api-lists) - это ресурс для разработчиков и широкой общественности. Он служит курируемой коллекцией публичных API из различных областей, облегчая разработчикам поиск и доступ к широкому спектру данных и сервисов. 
2. Документация по API на [GitHub](https://docs.github.com/en/rest) - это один из эталонных API в Интернете.
3. [Accuweather](https://developer.accuweather.com/) - один из публичных API сервисов прогнозов погоды.
## Авторизация и аутентификация API
### Аутентификация
Аутентификация - это процесс проверки личности пользователя, устройства или системы, пытающихся получить доступ к ресурсу. Она гарантирует, что субъект, запрашивающий доступ, является тем, за кого себя выдает. В контексте HTTP аутентификация часто включает в себя ввод имени пользователя и пароля, которые затем проверяются системой. Могут использоваться и другие методы, такие как токены, отпечатки пальцев или двухфакторная аутентификация. После проверки подлинности пользователю предоставляется доступ к ресурсам системы. 
### Авторизация
Авторизация, с другой стороны, определяет, какие действия **аутентифицированный пользователь** может выполнять в системе. Она определяет уровень доступа пользователя к определенным ресурсам или функциональным возможностям. Авторизация часто основывается на ролях или разрешениях, связанных с пользователем. Например, пользователь с привилегиями "администратора" может иметь доступ ко всем функциям, в то время как обычный пользователь может иметь ограниченный доступ. Авторизация не позволяет неавторизованным пользователям выполнять действия, выходящие за рамки их полномочий.
### Токены
API-токен - это часть данных, которая используется для аутентификации и авторизации пользователя, системы или приложения при взаимодействии с API. API-токены обычно используются для обеспечения безопасности и контроля доступа. Они действуют как форма учетных данных, позволяя владельцу токена делать запросы к API и получать доступ к определенным данным или сервисам.

#### Ключевые моменты API-токенов:
1. **Аутентификация и авторизация**:  API может проверить токен, чтобы узнать, какими правами или ролями обладает носитель токена и, соответственно, предоставить или запретить доступ.
2. **Генерация токенов**: API-токены генерируются провайдером API или службой аутентификации при аутентификации пользователя или приложения. Они уникальны для каждого пользователя или клиента.
3. **Истечение срока действия и аннулирование**: API-токены могут иметь срок действия, по истечении которого они становятся недействительными. Если токен скомпрометирован или больше не нужен, его можно отозвать, чтобы предотвратить дальнейший доступ. Для пользователя просроченный токен может выглядеть как просроченная сессия.
4. **Типы API-токенов**: Существуют различные типы API-токенов, в том числе:
   1. *API-ключ*: Простая строка или код, который часто включается в заголовок запроса. Ключи API обычно используются для идентификации и проверки подлинности клиента, выполняющего запрос.
   2. *Токен носителя*: Тип аутентификации на основе токенов, при котором токен предъявляется в качестве доказательства личности.
##### API-ключ
**Ключи API** обычно включаются в запрос в качестве заголовка или параметра запроса. Пример запроса с **ключом API** в заголовке:
```console
GET /api/resource HTTP/1.1
Host: example.com
X-API-Key: YOUR_API_KEY
```
```console
GET /api/resource?api_key=YOUR_API_KEY HTTP/1.1
Host: example.com
```
##### Bearer Token
**Bearer Token** - это тип маркера доступа, который обеспечивает подтверждение аутентификации и часто используется для более безопасной и детальной авторизации. Они обычно используются в протоколе OAuth 2.0. 

**Bearer token'ы** обычно включаются в заголовок "Authorization" как "Bearer", за которым следует токен.

Пример запроса с **Bearer token** в заголовке:
```console
GET /api/protected/resource HTTP/1.1
Host: example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkRlZmF1bHQgVXNlciIsImlhdCI6MTUxNjIzOTAyMn0.-lm-DCr7J9gh50-jNcP2J-6Ld17HeXXMvRmOiJN6YkA
```
**Алгоритм работы аутентификации на основе токенов:**
1. *Аутентификация пользователя*: Когда пользователь входит в систему, его учетные данные (обычно имя пользователя и пароль) отправляются на сервер аутентификации для проверки.
2. *Генерация токенов*: Если учетные данные пользователя действительны, сервер аутентификации генерирует уникальный токен. Этот токен связан с сессией пользователя и часто содержит информацию о его личности и разрешениях.
3. *Выдача токена*: Токен выдается пользователю, который затем предъявляет его при каждом последующем запросе на доступ к защищенному ресурсу или выполнение действия.
4. *Проверка подлинности*: Сервер, получивший токен, проверяет его действительность, убеждаясь, что срок его действия не истек и он не был подделан. Если токен действителен, доступ предоставляется; в противном случае запрос отклоняется.

<table><thead><tr><th style="width:18.0979%;"><br></th><th style="width:42.1696%;"><span>Bearer tokens</span></th><th style="width:40.1509%;"><span>API &nbsp;Keys</span></th></tr></thead><tbody><tr><td style="width:18.0979%;"><span>Безопасность</span></td><td style="width:42.1696%;"><p style="text-align:justify;">Считаются более безопасными, поскольку обычно имеют большую длину и генерируются криптографически. Они обеспечивают более высокий уровень безопасности и часто используются в потоках аутентификации на основе OAuth 2.0.</p></td><td style="width:40.1509%;text-align:justify;"><span>Ввиду простоты, они могут считаться менее безопасными, поскольку обычно являются статичными и могут быть легко перехвачены, если не передаются по защищенным соединениям.</span></td></tr><tr><td style="width:18.0979%;text-align:justify;"><span>Сценарий использования</span></td><td style="width:42.1696%;text-align:justify;">Часто используется, когда требуется более тонкий контроль доступа и безопасность, например, при доступе к пользовательским или конфиденциальным данным.<br></td><td style="width:40.1509%;text-align:justify;"><span>Обычно используется для простой аутентификации для доступа к общедоступным или менее чувствительным API.</span></td></tr><tr><td style="width:18.0979%;">Авторизация<br></td><td style="width:42.1696%;text-align:justify;">Могут нести дополнительную информацию о разрешениях и ролях пользователя или клиента, что делает их пригодными для более сложных сценариев авторизации.<br></td><td style="width:40.1509%;text-align:justify;">Обычно используется для простой аутентификации без возможности передачи данных о конкретном пользователе.<br></td></tr><tr style="text-align:justify;"><td style="width:18.0979%;">Примеры<br></td><td style="width:42.1696%;text-align:justify;">Используется для аутентификации пользователя для доступа к информации его личного профиля на платформе социальных сетей.<br></td><td style="width:40.1509%;text-align:justify;">Используется для доступа к публичному API погоды, где достаточно простого ключа.<br></td></tr></tbody></table>


