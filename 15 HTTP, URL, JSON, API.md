# 15 HTTP, URL, JSON, API
## HTTP
HTTP (HyperText Transfer Protocol) - протокол прикладного уровня для передачи гипертекста по сети. Он является основой для обмена данными в Интернете, обеспечивая коммуникацию между веб-браузерами и веб-серверами. Сейчас широко используются:
+ HTTP/1.1
+ HTTPS
+ HTTP/2
+ HTTP/3
### HTTP/1.1
+ Год выпуска: 1997
+ Характеристики:
  + HTTP-сообщение отправляется открытым текстом, передаваемая информация может быть легко перехвачена и расшифрована.
  + Поддерживает постоянные соединения (keep-alive), что позволяет использовать одно соединение для передачи нескольких запросов и ответов.
  + Ограничение на количество одновременных соединений с одним сервером (обычно 6-8).
  + Серверы не могут инициировать передачу данных без запроса клиента (односторонняя связь).
  + Заголовки передаются в виде текста, что может привести к избыточности и большим объемам данных.
  + Порт по умолчанию: 80
### HTTPS
+ Год выпуска: 1994
+ Характеристики:
  + HTTPS — это расширение HTTP, использующее SSL/TLS для шифрования данных.
  + Обеспечивает защиту передаваемых данных от перехвата и подделки.
  + Поддерживается всеми версиями HTTP (HTTP/1.1, HTTP/2, HTTP/3).
  + Включает механизмы аутентификации сервера (подробнее см. ниже) и иногда клиента (сервер в HTTPS-соединении может аутентифицировать клиентов различными способами, включая использование клиентских сертификатов, учетных данных и токенов доступа).
  + Использование HTTPS обязательно для защиты чувствительных данных и рекомендуется для всех веб-сайтов.
  + Порт по умолчанию: 443
### HTTP/2
+ Год выпуска: 2015
+ Характеристики:
  + Использование бинарного протокола позволило улучшить производительность и снизить задержки по сравнению с текстовым HTTP/1.1 за счет:
    + Мультиплексирования: позволяет отправлять несколько запросов и получать несколько ответов одновременно по одному TCP-соединению.
    + Сжатия заголовков: заголовки сжимаются, уменьшая объем передаваемых данных.
    + Server Push: Сервер может инициировать передачу данных, что позволяет отправлять данные клиенту до того, как он их запросит (добавлена вместо сокета новая сущность "логические потоки", через которую сервер инициирует Server Push).
  + Хотя протокол может работать и без шифрования на порту 80, основное применение HTTP/2 происходит через HTTPS на порту 443, обеспечивая таким образом безопасное шифрование данных с использованием TLS. В большинстве современных браузеров и серверов HTTP/2 автоматически включается при установке HTTPS-соединения.
### HTTP/3
+ Год выпуска: 2020 (экспериментальная реализация), 2022 (RFC 9114)
+ Характеристики:
  + Основан на протоколе QUIC - современном транспортном протоколе, работающем поверх UDP и разработанном Google для замены или дополнения традиционного TCP, обеспечив более быструю и надежную передачу данных в интернете. Он обладает рядом улучшений по сравнению с TCP, особенно в контексте использования с протоколом HTTP/3:
    + QUIC позволяет установить защищенное соединение за один RTT (Round-Trip Time), объединив процесс установки соединения и TLS рукопожатие.
    + QUIC поддерживает мультиплексирование множества логических потоков в рамках одного соединения (мультиплексирование без блокировки: позволяет избежать проблем с задержками и блокировками, связанных с HTTP/2)
    + QUIC позволяет сохранять соединение при смене IP-адреса или порта (полезно для мобильных устройств, меняющих сети, переключаясь с Wi-Fi на мобильные данные).
    + QUIC включает в себя интеграцию с TLS 1.3: все соединения QUIC шифруются по умолчанию, обеспечивая защиту данных в транзите.
    + QUIC включает современные алгоритмы управления перегрузкой и механизмы восстановления потерь.
  + Порт по умолчанию: 443
### Основные особенности гипертекстовых протоколов
+ HTTP/1.1: Стандартный, простой в реализации, но ограничен в производительности из-за последовательной передачи данных.
+ HTTP/2: Улучшенная производительность за счет мультиплексирования и сжатия заголовков, позволяет быстрее загружать веб-страницы.
+ HTTP/3: Еще более быстрая и эффективная передача данных благодаря использованию QUIC и работы поверх UDP, лучше подходит для современных сетей с высокой задержкой (но не для условий, где недопустима потеря данных из-за потери пакетов).
+ HTTPS: Обеспечивает безопасность передачи данных, защищает от атак типа "человек посередине" (MITM) и обеспечивает конфиденциальность и целостность данных (ВНИМАНИЕ!!! В большинстве современных браузеров и серверов при установке HTTPS-соединения автоматически включается HTTP/2).
### Stateless protocol
HTTP/1.1, HTTP/2, HTTP/3 и HTTPS - протоколы без состояния (stateless protocol). С точки зрения сервера, каждый новый запрос как будто поступает от совершенно нового клиента (сервер не помнит, что вы только что были на предыдущей странице или авторизовались). Чтобы обеспечить и согласованность запросов, используются:
+ Cookies (куки): Маленькие файлы, которые сервер отправляет браузеру клиента, и которые затем отправляются обратно серверу с каждым последующим запросом. Таким образом, сервер может "узнавать" клиента и отслеживать его действия. Они доступны для чтения и записи только веб-сайтам, которые установили эти куки. Местоположение файлов куков зависит от операционной системы и браузера:
  + В Windows: обычно в папке ```%APPDATA%\Roaming\<BrowserName>\Cookies```.
  + В macOS: в папке ```~/Library/Application Support/<BrowserName>/Cookies```.
  + В Linux: в папке ```~/.config/<BrowserName>/Cookies```.
+ Сессии (sessions): Сервер может создавать уникальные идентификаторы сессий для каждого пользователя, которые сохраняются в куки или в URL. Эти идентификаторы позволяют серверу связывать текущий запрос с предыдущими запросами от того же клиента.
+ Заголовки HTTP (HTTP headers): В HTTP-заголовках могут передаваться дополнительные данные, которые помогают серверу идентифицировать и отслеживать клиента. Например, заголовок ```Authorization``` может содержать токен, который сервер использует для проверки прав доступа клиента.
### Шифрование при передаче данных
Для шифрования информации, передаваемой по протоколу HTTPS, на сервере должен быть установлен так называемый сертификат SSL (Secure Sockets Layer) или TLS (Transport Layer Security, улучшенная версия SSL). Сертификат SSL/TLS состоит из двух частей: открытого ключа, используемого для шифрования данных, и закрытого ключа, используемого для их расшифровки, который доступен и известен только владельцу сайта и хранится на сервере в защищенном месте. Генерацией данной пары ключей занимается центр сертификации (CA), которому необходимо отправить запрос на подписание сертификата (CSR), сообщив о назначении вашего сайта, названии организации и т.д. Запрос имеет специальный формат и может быть автоматически сгенерирован специальными программами.
#### Процедура обмена данными по HTTPS
1. *Инициация соединения и TLS/SSL Handshake (рукопожатие):* Клиент отправляет запрос на сервер для установления соединения по HTTPS, обычно указывая URL, начинающийся с "https://".
   1. *Client Hello*: Клиент отправляет запрос на сервер для установления соединения по HTTPS, указывая URL, начинающийся с "https://". В рамках этого запроса клиент отправляет сообщение "Client Hello", содержащее:
      1. Версию протокола TLS/SSL, которую поддерживает клиент.
      2. Список шифров (алгоритмов шифрования), поддерживаемых клиентом.
      3. Случайное число (random number), которое будет использоваться для создания сессионного ключа.
   2. *Server Hello*: Сервер отвечает сообщением "Server Hello", содержащее:
      1. Выбранную версию протокола TLS/SSL.
      2. Выбранный шифр из списка, предложенного клиентом.
      3. Случайное число от сервера.
2. *Аутентификация и передача сертификата*
   1. *Сертификат сервера*: Сервер отправляет свой цифровой сертификат, выданный доверенным центром сертификации (CA). Этот сертификат содержит:
      1. Публичный ключ сервера.
      2. Информацию о сервере и о центре сертификации.
      3. Подпись центра сертификации, подтверждающую подлинность сертификата.
   2. *Проверка сертификата*: Клиент проверяет сертификат сервера, чтобы убедиться, что он:
      1. Выдан доверенным центром сертификации.
      2. Не просрочен и не отозван.
      3. Соответствует имени сервера (имя хоста в URL).
3. *Генерация сессионного ключа*
   1. *Client Key Exchange*: Клиент создает премастер-секрет (pre-master secret), шифрует его публичным ключом сервера и отправляет на сервер. Только сервер может расшифровать этот премастер-секрет своим приватным ключом.
   2. *Создание мастер-секрета*: Клиент и сервер используют премастер-секрет и случайные числа, обменянные ранее, для создания мастер-секрета. Мастер-секрет используется для генерации сессионных ключей, которые будут использоваться для симметричного шифрования данных.
4. *Завершение рукопожатия*
   1. *Client Finished*: Клиент отправляет сообщение "Finished", зашифрованное сессионным ключом. Это сообщение содержит хэш всех предыдущих сообщений рукопожатия, чтобы сервер мог подтвердить целостность процесса.
   2. *Server Finished*: Сервер отвечает аналогичным образом, отправляя сообщение "Finished", также зашифрованное сессионным ключом.
5. *Передача данных*: После успешного завершения рукопожатия клиент и сервер начинают передавать данные по зашифрованному каналу, используя симметричное шифрование с сессионными ключами.
## URL, URN, URI
URI (Uniform Resource Identifier): Общий термин, который используется для обозначения идентификатора ресурса. Он может быть либо URL, либо URN.
1. URL (Uniform Resource Locator): Специфический тип URI, который используется для обозначения адреса ресурса в Интернете и содержит информацию о том, как этот ресурс можно получить (например, через HTTP, HTTPS, FTP и т.д.).
2. Термин URN (Uniform Resource Name) - это уникальная идентификация ресурса в определенном пространстве (книги, RFC и т.д.), в специальном пространстве, начинающемся с urn: ```urn:ietf:rfc:7230``` (серверы реализуют mapping между представлением URN и URL)
### Структура URL
<img src="resources/url_NOPROCESS1_.png" alt="Структура URL" width="70%"/>

1. Протокол (protocol) - набор правил, которые необходимо использовать для доступа к ресурсу. Это может быть:
   1. HTTP
   2. HTTPS
   3. FTP и другие
2. Хост (host) - Адрес сервера - www.nexus.oy...- - это как строка "город-улица-здание" в физическом адресе. Он может быть представлен в виде:
   1. слов, разделенных точками (например, mentorpiece.education или nexus.oy.defects.tst) - каждое слово является уровнем домена
   2. цифр, разделенные точками, в данном случае это IP-адрес (например, 192.168.40.100/)
   3. localhost (означает локальный компьютер, IP-адрес по умолчанию - 127.0.0.1)
3. Порт (port)- Целевое приложение "слушает" этот порт и обрабатывает соответствующие запросы - 8079 - это как номер квартиры внутри здания
   1. Порт по умолчанию для протокола HTTP - 80
   2. Порт по умолчанию для протокола HTTPS - 443
   3. Порт по умолчанию для протокола FTP - 21
   4. Порт по умолчанию для почтового протокола (SMTP)  - 587
4. Путь (path)- путь к ресурсу - /service/rest/v1/search - рассматривайте его как путь к комнате внутри этой квартиры.
5. Параметры (parameters) - некоторые значения для модификации запроса - ?sort=version и ?direction=desc - воспринимайте это как вопрос типа "Есть ли у вас в комнате такая книга?".

*Примечание:*
+ URL чаще встречаются в повседневной работе в Интернете, поскольку они используются для доступа к веб-ресурсам
+ URN встречаются реже, но служат конкретной цели обеспечения постоянных и независимых от местоположения идентификаторов ресурсов, что делает их ценными в некоторых специализированных областях, где стабильность и уникальность ресурсов имеют первостепенное значение.
### Методы HTTP
HTTP определяет типы запросов, которые могут быть отправлены от клиента к серверу. Эти типы называются HTTP-методами:
+ ``GET`` - используется для чтения данных с сервера
+ ```POST``` - используется для создания чего-либо на стороне сервера. Например, создать новую учетную запись пользователя.
+ ```PUT``` - используется для полного обновления ресурса (клиент должен отправить полный набор данных ресурса, даже если необходимо изменить только одну часть ресурса). Он заменяет весь текущий ресурс на сервере новыми данными, переданными в запросе. ```PUT``` является идемпотентным методом. Это означает, что повторный вызов PUT с одинаковыми данными приведет к одному и тому же результату, не изменяя ресурс повторно
+ ```DELETE``` - что-то удалить.
+ ```PATCH``` - используется для частичного обновления ресурса. Он вносит изменения только в те части ресурса, которые указаны в запросе. ```PATCH``` может быть неидемпотентным, что означает, что повторные вызовы могут привести к различным результатам
+ ```HEAD``` - аналогично ```GET```, но возвращаются только заголовки ответа (некоторая метаинформация) (без данных).
+ ```OPTIONS``` - метод не выполняет никаких изменений и не возвращает данные ресурса; вместо этого он возвращает информацию о том, какие методы HTTP и другие параметры коммуникации поддерживаются. Метод ```OPTIONS``` широко используется в механизме ```CORS``` для выполнения предварительных запросов (preflight requests). Когда браузер делает запрос к ресурсу на другом домене, сначала отправляется запрос ```OPTIONS``` для проверки разрешений. Ответ на этот запрос включает информацию о том, разрешен ли доступ и какие методы и заголовки допустимы. Пример предварительного запроса (preflight request):
```console
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: http://www.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header
```
Пример ответа на предварительный запрос:
```console
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://www.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-Custom-Header
```
+ ```CONNECT``` - используется для установления туннеля связи между клиентом и целевым сервером через промежуточный сервер (создание туннелей для HTTPS, для создания туннелей для VPN-соединений и других туннельных протоколов, где требуется передача данных через защищенный канал).
+ ```TRACE``` - используется для диагностики, отладки сетевых соединений, отладка прокси-серверов и шлюзов, проверка целостности запроса. Он позволяет клиенту отправить запрос на сервер и получить в ответе точную копию этого запроса. Это помогает определить, какие изменения или модификации были внесены в запрос при его прохождении через различные промежуточные узлы (прокси-серверы, шлюзы и т.д.). Метод ```TRACE``` может представлять угрозу безопасности, так как он возвращает клиенту всю информацию запроса, включая возможные конфиденциальные данные и заголовки. Это может быть использовано злоумышленниками для проведения атак, таких как ```Cross-Site Tracing (XST)```. Многие веб-серверы и прокси-серверы по умолчанию отключают поддержку метода ```TRACE``` или ограничивают его использование для повышения безопасности.
#### CRUD
Четыре метода (```GET```, ```POST```, ```PUT```, ``DELETE``) называют ``CRUD``: CREATE-READ-UPDATE-DELETE (где CREATE - POST, READ - GET, UPDATE - PUT, а DELETE - DELETE).
### HTTP Запрос/Ответ
<img src="resources/Req_resp_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

### Коды состояния HTTP
+ 200 OK. Все в порядке, вот содержимое запрашиваемой страницы.
+ 201 Created. Запрашиваемый ресурс успешно создан.
+ 301 Moved Permanently. Ресурс с этим URI навсегда перемещен по адресу, указанному в заголовках на стороне сервера.
+ 302 Moved Temporarily. Аналогично, но перемещено временно. Часто 301 и 302 означают одно и то же, это зависит от настроек веб-сервера (или веб-приложения). Так что основная идея кодов 301/302 - "возьмите новый адрес и перейдите туда".
+ 304 Not Modified. Если был использован заголовок клиента "If-Modified-Since" (если изменен, то...) и ресурс не был изменен, то нет необходимости получать его снова.
+ 400 Bad Request. Что-то не так с вашим запросом.
+ 401 Unauthorized. Вы должны быть авторизованы, чтобы открыть этот URI. Когда сервер отвечает этим кодом, он также показывает вам форму авторизации для ввода логина и пароля.
+ 403 Forbidden. Доступ запрещен. Показывается, например, когда введены неправильные логин и/или пароль.
+ 404 Not found. Ресурс с таким URI не существует (или сервер хочет, чтобы вы так думали).
+ 418 I’m a teapot. (418 Я чайник) Код из первоапрельской шутки, на самом деле не должен работать.
+ 500 Internal Server Error. Что-то не так с сервером.
+ 502 Bad Gateway. Сервер попытался перенаправить ваш запрос на другой сервер, но не преуспел в этом.
+ 503 Service Unavailable. По сути, то же самое, что 500.
+ 504 Gateway Timeout. То же самое, что и 502, но в случае ошибки тайм-аута.
### Заголовки HTTP
Вторая часть HTTP-запроса или ответа - раздел заголовков.
#### Заголовки запросов
##### General Headers (Общие заголовки):
+ ```Host```: Указывает доменное имя и порт сервера, к которому обращается клиент.
+ ```Connection```: Управляет параметрами текущего соединения. Например, ```Connection: keep-alive``` сохраняет соединение открытым для последующих запросов.
+ ```Cache-Control```: Управляет кешированием запросов. Например, ```Cache-Control: no-cache```.
##### Request Headers (Заголовки запросов):
+ ```Accept```: Указывает типы медиа, которые клиент может обработать. Например, ```Accept: text/html```.
+ ```User-Agent```: Идентифицирует клиентское приложение. Например, ```User-Agent: Mozilla/5.0```.
+ ```Accept-Language```: Указывает предпочтительные языки. Например, ```Accept-Language: en-US```.
+ ```Authorization```: Передает учетные данные для аутентификации. Например:
  + ```Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела запроса. Например, ```Content-Type: application/json```.
+ ```Content-Length```: Указывает длину тела запроса в байтах. Например, ```Content-Length: 348```.
#### Заголовки ответов
##### General Headers (Общие заголовки):
+ ```Date```: Указывает дату и время, когда сервер сгенерировал ответ. Например, ```Date: Wed, 12 Jun 2024 15:00:00 GMT```.
##### Response Headers (Заголовки ответов):
+ ```Server```: Идентифицирует серверное программное обеспечение. Например, ```Server: Apache/2.4.1 (Unix)```.
+ ```Set-Cookie```: Устанавливает cookie в браузере. Например, ```Set-Cookie: sessionId=abc123; Path=/; Secure; HttpOnly```.
+ ```WWW-Authenticate```: Указывает метод аутентификации, требуемый для доступа к ресурсу. Например:
  +  ```WWW-Authenticate: Basic realm="Access to the site"```.
##### Entity Headers (Заголовки сущностей):
+ ```Content-Type```: Указывает MIME-тип тела ответа. Например, ```Content-Type: text/html; charset=UTF-8```.
+ ```Content-Length```: Указывает длину тела ответа в байтах. Например, ```Content-Length: 348```.
+ ```Content-Encoding```: Указывает кодировку, использованную для сжатия тела. Например, ```Content-Encoding: gzip```.
#### Другие важные заголовки
+ ```Referer```: Указывает URL, с которого был сделан запрос. Например, ```Referer: https://www.example.com```.
+ ```Location```: Используется для перенаправлений, указывает новый URL. Например, ```Location: https://www.example.com/newpage```.
+ ```Transfer-Encoding```: Управляет фрагментацией тела сообщения. Например, ```Transfer-Encoding: chunked```  позволяет серверу передавать данные в виде серии "чанков", что особенно полезно, когда размер контента неизвестен на момент начала передачи.
+ ```X-Content-Type-Options```: Заголовок ```X-Content-Type-Options: nosniff``` - инструмент для повышения безопасности веб-приложений. Он сообщает браузеру, что он должен строго следовать указанному типу MIME и не пытаться определять его самостоятельно. Это помогает предотвратить выполнение потенциально опасных файлов. 
+ ```Strict-Transport-Security```: Указывает политику безопасности для HTTPS. Когда браузер получает  от сервера этот заголовок, он запоминает домен и обязуется в течение указанного периода времени (максимального возраста) использовать только HTTPS для всех последующих запросов к этому домену. Если злоумышленник попытается заставить браузер использовать HTTP, а не HTTPS, данный заголовок предотвратит это, так как браузер будет знать, что только HTTPS соединения разрешены. Пример:
  + ```Strict-Transport-Security: max-age=31536000```. 

*Примечание:*
Существуют пользовательские заголовки, поддерживаемые только конкретным приложением. Например, вы можете отправить в запросе заголовок x-correlation-id, и ваш сервер должен знать, как обработать этот заголовок.
### Тело HTTP-запроса/ответа
HTTP-запрос/ответ может содержать полезную нагрузку, которая помещается в часть Request Body или Response Body. Тело может содержать:
+ исходный код веб-страницы
+ данные в формате JSON
+ различные типы медиа в соответствии со стандартом: аудио, изображение, текст и так далее.

При выполнении запроса (PUT, POST) тип данных задается с помощью заголовка ```Content-type```, например:
+ ```Content-Type: text/html; charset=utf-8```
## JSON
JSON (JavaScript Object Notation) - легковесный и фундаментальный формат для создания современных веб-приложений и API. JSON используется
+ для передачи данных между сервером и веб-приложением
+ в файлах конфигурации и хранения данных.

К особенностям JSON можно отнести то, что он:
+ стандартизирован: имеет согласованные структуры и форматы данных, хорошо документирован и обладает широкой инструментальной поддержкой. Всё это облегчают работу по  межсистемному тестированию (созданию тестовых данных, обработке ошибок и сотрудничеству с командами разработчиков);
+ независим от языка программирования (хотя в названии JSON присутствует JavaScript), что делает его универсальным и подходящим для широкого спектра приложений.
+ представляет данные в виде набора пар ключ-значение. Каждый ключ - это строка, заключенная в ДВОЙНЫЕ кавычки, а значения могут быть строками, числами, булевыми значения, объектами, массивами или null. Эти наборы пар заключены в фигурные скобки {}
+ игнорирует пробельные символы (пробелы, табуляции, переносы строк) вне строк, что облегчает форматирование для удобства чтения, например:
```console
{"name":"Alice","age":30,"city":"Wonderland"}
```
то же, что и:
```console
{
    "name": "Alice",
    "age": 30,
    "city": "Wonderland"
}
```
### Типы данных
1. **Строка**: Строка - это последовательность символов, заключенных в двойные кавычки. Строки используются для представления текста и могут включать буквы, цифры, символы и пробелы.
2. **Число**: JSON поддерживает как целые числа, так и числа с плавающей точкой. Числа не заключаются в кавычки и могут быть положительными или отрицательными.
3. **Boolean**: В JSON есть два булевых значения: true (истина) и false (ложь).
4. **Объект**: Объект - это неупорядоченная коллекция пар ключ-значение, заключенная в фигурные скобки {}. Ключи - это строки, а значения могут быть любого типа данных JSON, включая другие объекты или массивы.
5. **Массив**: Массив - это упорядоченный список значений, заключенный в квадратные скобки []. Массивы могут содержать значения любого типа данных JSON, включая строки, числа, булевы, объекты и другие массивы. Массивы не ограничены одним типом данных, поэтому один и тот же массив может одновременно содержать строки, числа, булевы значения, объекты, другие массивы и null.
6. **Null**: Специальное значение null означает отсутствие данных или пустое значение. Оно часто используется для обозначения того, что значение намеренно отсутствует или не определено.
<img src="resources/json-introduction_NOPROCESS_.png" alt="Структура запроса и ответа HTTP" width="70%"/>

## API
API (Application Programming Interface) - определяет методы, которые одно программное приложение может использовать для взаимодействия с другим. Он служит интерфейсом, через который программы могут запрашивать и обмениваться данными и функциональностью. Существуют различные API:
+ Аппаратное обеспечение (например, интерфейс жесткого диска)
+ Операционная система (доступ к файловой системе, доступ к пользовательскому интерфейсу)
+ Относящееся к Web (SOAP, REST, GraphQL)
+ gRPC для микросервисов и высоконагруженных систем
### SOAP
**SOAP** (Simple Object Access Protocol) - это протокол обмена структурированными сообщениями в распределенной вычислительной среде, основанный на XML. Он предназначен для обмена информацией между компьютерными системами по сети, независимо от используемых программных языков и аппаратных платформ. Был популярен в начале 2000-х годов.
#### Основные характеристики SOAP API:
1. SOAP использует XML для форматирования запросов и ответов.
2. SOAP обычно работает поверх прикладных протоколов, таких как HTTP и HTTPS. Эти прикладные протоколы в свою очередь используют транспортные протоколы, такие как TCP. SOAP также может работать поверх других прикладных протоколов, таких как SMTP.
3. Сообщения SOAP состоят из трех основных частей:
   1. Envelope (Конверт): Обертка сообщения, которая определяет, что содержимое является SOAP-сообщением и предоставляет пространство имен.
   2. Header (Заголовок): Необязательная часть, содержащая информацию для маршрутизации и обработки сообщения.
   3. Body (Тело): Основная часть сообщения, содержащая запрос или ответ.
4. Расширяемость: SOAP поддерживает расширяемые архитектуры, позволяя добавлять новые функциональные возможности через заголовки и модули.
5. Стандарты безопасности: SOAP поддерживает ```WS-Security```, что обеспечивает безопасную передачу сообщений через сети.
#### Преимущества SOAP API:
1. Платформенная независимость: SOAP может использоваться на различных платформах и с различными языками программирования благодаря использованию стандартного XML-формата.
2. Безопасность: SOAP включает в себя расширения безопасности, такие как ```WS-Security```, для обеспечения конфиденциальности и целостности данных.
3. Междоменная связь: SOAP легко проходит через междоменные политики и файрволы, так как часто использует HTTP/HTTPS.
4. Формальная спецификация: SOAP имеет четко определенные стандарты и спецификации, что делает его надежным и хорошо документированным протоколом.
#### Примеры использования SOAP API:
1. Банковские и финансовые системы: SOAP часто используется в финансовых приложениях, где важна безопасность и надежность передачи данных.
2. Корпоративные системы: Большие предприятия используют SOAP для интеграции различных систем и приложений внутри организации.
3. Услуги правительственных организаций: SOAP применяется для передачи данных между государственными учреждениями и сервисами, требующими высокой степени безопасности и согласованности.
#### Пример SOAP-сообщения:
```htm
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:m="http://www.example.org/stock">
   <soap:Header>
      <m:Trans>234</m:Trans>
   </soap:Header>
   <soap:Body>
      <m:GetStockPrice>
         <m:StockName>IBM</m:StockName>
      </m:GetStockPrice>
   </soap:Body>
</soap:Envelope>
```
*В этом примере SOAP-сообщения запрос отправляется для получения цены акции компании IBM. Конверт оборачивает все сообщение, заголовок содержит идентификатор транзакции, а тело содержит сам запрос.*
#### Недостатки SOAP:
SOAP имеет несколько недостатков по сравнению с другими протоколами обмена сообщениями, такими как REST:
1. Тяжеловесность: SOAP использует XML для форматирования сообщений, что делает его более тяжеловесным по сравнению с более современными и легковесными форматами данных, такими как JSON. Это требует больше ресурсов для обработки и передачи данных. Отсюда и проблемы производительностью и, таким образом, меньше подходит для ресурсоемких операций.
2. Сложность разработки и поддержки: SOAP имеет сложную спецификацию и требует строгого соблюдения стандартов. Это может усложнять процесс разработки, особенно для новичков в области веб-сервисов.
3. Низкая читаемость: XML-структура SOAP-сообщений не так легко читаема как JSON, что может затруднять отладку и мониторинг.
4. Сложность интеграции с современными веб-технологиями: В современных веб-приложениях, где широко используются JavaScript и RESTful API, интеграция с SOAP может потребовать дополнительных усилий и библиотек.
5. Сложность в настройке безопасности: Хотя SOAP поддерживает WS-Security для обеспечения безопасности сообщений, его конфигурация и настройка могут потребовать дополнительных усилий и специализированных знаний.
### gRPC
gRPC (gRPC Remote Procedure Calls) — разработанный Google в 2015 году современный, высокопроизводительный RPC фреймворк, использующий ```HTTP/2``` для транспорта и ```Protocol Buffers``` (protobuf) для сериализации данных. 

*RPC (Remote Procedure Call) — это протокол, который позволяет программе выполнять методы на удаленном сервере так, как будто они выполняются локально.*
#### Преимущества gRPC
1. Высокая производительность: 
   1. HTTP/2 в качестве транспорта обеспечивает эффективную передачу данных (мультиплексирование запросов, компрессию заголовков и поддержку server push).
   2. Protocol Buffers обеспечивают компактное представление данных в бинарном формате, что уменьшает размер передаваемых данных, ускоряет их передачу по сети и, благодаря простоте и эффективности бинарного формата, обеспечивают более компактное и быстрое кодирование/декодирование данных по сравнению с JSON или XML.
2. Сильная типизация: gRPC использует строго типизированные контракты, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает лучшее автодополнение и рефакторинг в IDE.
3. Мультиплатформенность: gRPC поддерживает множество языков программирования, включая C++, Java, Python, Go, Ruby, C#, Node.js и другие, что позволяет использовать его в различных экосистемах для эффективного обмена данными между различными компонентами системы
4. Двусторонний стриминг: gRPC поддерживает не только одноразовые запросы-ответы, но и потоковые взаимодействия (как клиент-сервер, так и двусторонние), что делает его идеальным для приложений реального времени.
5. Интероперабельность: gRPC обеспечивает высокую степень совместимости между различными системами и сервисами благодаря четко определённым интерфейсам и стандартизованным инструментам.
#### Недостатки gRPC
1. Сложность настройки: В отличие от REST, который часто используется в веб-разработке и имеет большое количество документации и инструментов, gRPC может потребовать больше усилий для настройки и интеграции, особенно для разработчиков, незнакомых с Protocol Buffers и HTTP/2.
2. Ограниченная поддержка браузеров: gRPC предназначен в первую очередь для взаимодействия между микросервисами и серверными приложениями, где он обеспечивает высокую производительность благодаря использованию HTTP/2 и Protocol Buffers. Однако, из-за использования бинарного формата и специализированной обработки, gRPC не поддерживается непосредственно большинством современных веб-браузеров. Для того чтобы клиентские веб-приложения могли взаимодействовать с gRPC-бэкендами, был разработан протокол gRPC-Web, являющийся адаптацией gRPC для работы через стандартный HTTP/1.x и поддерживаемый браузерами. Однако для использования gRPC-Web требуется дополнительный прокси-сервер или промежуточный слой на стороне сервера, который конвертирует запросы и ответы между gRPC и gRPC-Web. Этот прокси-сервер или промежуточный слой позволяет преобразовывать запросы HTTP/1.x от клиентских браузеров в gRPC-запросы на сервере и наоборот.
3. Изучение новых технологий: Разработчикам, привыкшим к REST и JSON, может потребоваться время на освоение Protocol Buffers и принципов работы gRPC, что может замедлить начальную разработку.
4. Необходимость в gRPC-специфичных инструментах: Для генерации клиентских и серверных кодов необходимо использовать специфические инструменты gRPC, что может добавить сложности в процессы сборки и развертывания.
5. Командное управление версиями: Управление версиями и обновление контрактов может быть сложнее в gRPC из-за строгой типизации и необходимости синхронизации между клиентами и серверами.
#### Примеры использования gRPC
1. Микросервисная архитектура: gRPC идеально подходит для внутреннего взаимодействия микросервисов благодаря своей высокой производительности и поддержке различных языков программирования.
2. Системы реального времени: Потоковые возможности gRPC делают его отличным выбором для чатов, видеоконференций, игр и других приложений, требующих низкой задержки и высокой пропускной способности.
3. Интерфейсы для мобильных и IoT-устройств: Благодаря компактному формату Protocol Buffers, gRPC может эффективно использоваться на устройствах с ограниченными ресурсами, таких как мобильные и IoT-устройства.
#### Заключение
gRPC предоставляет мощные возможности для создания производительных и масштабируемых распределенных систем. Однако, он может быть сложнее в настройке и использовании по сравнению с REST, особенно для разработчиков, привыкших к традиционным веб-технологиям. Выбор между gRPC и другими протоколами, такими как REST, зависит от конкретных требований проекта, включая производительность, сложность, поддерживаемые платформы и тип взаимодействия.
### GraphQL
+ GraphQL (Graph Query Language) — это язык запросов для API, разработанный Facebook в 2012 году и выпущенный в открытый доступ в 2015 году. GraphQL предоставляет гибкий и эффективный способ взаимодействия с сервером, позволяя клиенту запрашивать именно те данные, которые ему необходимы, и ничего лишнего.
+ GraphQL может работать поверх любого транспортного протокола, но обычно используется с HTTP/HTTPS для взаимодействия между клиентом и сервером (поддерживается веб-браузерами без дополнительных инструментов в отличие от gRPC). 
+ Запросы и ответы GraphQL передаются в формате JSON, что делает их легкими для чтения и обработки.
+ Клиент может отправлять запросы различными способами, в зависимости от используемых инструментов и среды разработки, в том числе, с помощью Postman;
  1. Создайте новый запрос и выберите тип GraphQL
  2. Вставьте ваш GraphQL-запрос в поле для запроса:
```console
query GetBook($id: ID!) {
  book(id: $id) {
    title
    author {
      name
    }
  }
}
```
  1. Введите URL вашего GraphQL сервера, например, http://localhost:4000/graphql.
  2. Нажмите "Send" для выполнения запроса.
#### Преимущества GraphQL
1. Запрос только необходимых данных: Клиенты могут запрашивать ровно те поля, которые им нужны, что снижает объем передаваемых данных и повышает производительность.
2. Гибкость запросов: Клиенты могут комбинировать несколько запросов в одном вызове, делать вложенные запросы и т.д., что позволяет уменьшить количество сетевых запросов.
3. Типизированная система: GraphQL использует строгую типизацию схемы, что позволяет обнаруживать ошибки на этапе компиляции и обеспечивает автодополнение и документацию прямо в редакторе.
4. Единый эндпоинт: Все запросы обрабатываются через один эндпоинт, что упрощает архитектуру API и управление запросами.
5. Инструменты для разработки: GraphQL имеет отличные инструменты для разработки и отладки, такие как GraphiQL и Apollo Client, которые помогают разработчикам быстро и эффективно работать с API.
#### Недостатки GraphQL
1. Сложность настройки и обучения: Первоначальная настройка и обучение GraphQL может быть более сложной по сравнению с REST, особенно для разработчиков, незнакомых с концепцией схем и типизаций.
2. Производительность на сервере: Обработка запросов GraphQL может потребовать больше ресурсов на сервере, так как сервер должен динамически разбирать запросы и формировать ответ. Особенно это заметно при сложных или неоптимизированных запросах.
3. Кеширование: Кеширование в GraphQL сложнее реализовать по сравнению с REST. В REST можно использовать кеширование на уровне HTTP, тогда как в GraphQL запросы могут быть более сложными и динамическими, что затрудняет кеширование на уровне сети.
4. Ограничения в инструментах мониторинга и безопасности: Традиционные инструменты мониторинга и безопасности, которые хорошо работают с REST, могут быть несовместимы с GraphQL или требовать дополнительной настройки.
#### Примеры использования GraphQL
1. Facebook: Facebook использует GraphQL для своего мобильного приложения, обеспечивая эффективный и гибкий доступ к данным.
2. GitHub: GitHub предлагает GraphQL API, позволяя разработчикам запрашивать только необходимые данные и получать их в одном запросе.
3. Shopify: Shopify использует GraphQL для своего Storefront API, что позволяет разработчикам создавать гибкие и производительные интерфейсы для интернет-магазинов.
#### Заключение
GraphQL предоставляет мощные и гибкие возможности для разработки API, позволяя клиентам запрашивать только необходимые данные и улучшая производительность и эффективность взаимодействия с сервером. Однако, он требует более сложной настройки и обучения, а также может потребовать дополнительных ресурсов на сервере. Выбор между GraphQL и другими протоколами, такими как REST или gRPC, зависит от конкретных требований проекта, включая гибкость, производительность и сложность реализации.
### Endpoint API<a name="endpoint-api"></a>
Endpoint (конечная точка) в API — это конкретный URL-адрес, по которому можно выполнить определенное действие в рамках API(получение данных, создание ресурса, обновление или удаление).
#### Основные аспекты Endpoint в API:
1. URL-адрес: URL (Uniform Resource Locator) включает в себя доменное имя, путь и, возможно, параметры запроса. Например, в REST API URL может выглядеть так: ```https://api.example.com/users/123```.
2. Метод HTTP: Эндпоинт обычно ассоциируется с одним из HTTP-методов, таких как GET, POST, PUT, DELETE, которые определяют тип операции, которую клиент хочет выполнить.
   + GET: Получение данных.
   + POST: Создание нового ресурса.
   + PUT: Обновление существующего ресурса.
   + DELETE: Удаление ресурса.
3. Ресурсы и действия: Эндпоинты связаны с конкретными ресурсами или действиями. Например:
   + GET /users: Получить список пользователей.
   + POST /users: Создать нового пользователя.
   + GET /users/123: Получить информацию о пользователе с ID 123.
   + PUT /users/123: Обновить информацию о пользователе с ID 123.
   + DELETE /users/123: Удалить пользователя с ID 123.
4. Параметры: Эндпоинты могут включать параметры пути (path parameters) и параметры запроса (query parameters), которые уточняют запрос.
   + Параметры пути: /users/{id}
   + Параметры запроса: /users?sort=asc&limit=10
#### Примеры
##### REST API:
В REST API эндпоинты представляют собой URL-адреса, которые соответствуют ресурсам и действиям над ними. Например:
+ GET /api/products: Получить список продуктов.
+ POST /api/products: Создать новый продукт.
+ GET /api/products/123: Получить информацию о продукте с ID 123.
+ PUT /api/products/123: Обновить продукт с ID 123.
+ DELETE /api/products/123: Удалить продукт с ID 123.
+ GET /api/products?category=electronics: Фильтрация результатов
+ GET /api/posts?page=2&pageSize=10: Пагинация результатов
+ GET /api/articles/456/details: Получение подробностей о ресурсе
+ GET /api/countries/usa/cities/new-york: Получение ресурса с использованием путей
+ GET /api/articles/123/comments: Получение коллекции связанных ресурсов
##### GraphQL API:
В GraphQL API обычно есть один эндпоинт для всех запросов и мутаций. GraphQL API поддерживает для выполнения запросов к API использование методов HTTP POST (используется для выполнения запросов GraphQL, которые могут быть сложными, содержать мутации или большие данные) и GET (может использоваться для выполнения простых запросов GraphQL, часто для чтения данных, а также в ситуациях, когда требуется кэширование или передача параметров через строку запроса). Например, здесь все запросы и мутации отправляются на этот эндпоинт, а данные и операции указываются в теле запроса:
+ ```POST /graphql```
##### SOAP API:
В SOAP API эндпоинты представляют собой URL-адреса, к которым отправляются SOAP-сообщения. В отличие от GraphQL, который обычно имеет один универсальный эндпоинт для всех запросов и мутаций, SOAP API может иметь несколько эндпоинтов, каждый из которых представляет собой конкретную веб-службу или операцию. SOAP API, как правило, использует метод POST для отправки SOAP-запросов на сервер. Это обусловлено тем, что SOAP-запросы представляют собой структурированные XML-документы, которые передаются в теле HTTP-запроса. Например:
+ ```POST /service.asmx```.
##### Заключение
Эндпоинт в API играет ключевую роль в определении того, как клиент взаимодействует с сервером. Он включает URL-адрес, HTTP-метод, ресурсы и параметры, которые вместе определяют конкретное действие, которое должно быть выполнено.
### Документация по API
Документация по API содержит подробную информацию и инструкции о том, как эффективно использовать API и взаимодействовать с ним.

Пример открытого API Petstore на языке Swagger
<img src="resources/petstoreSwaggerList_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

<img src="resources/petstoreSwagger_NOPROCESS_.png" alt="пример открытого API Petstore на языке Swagger" width="70%"/>

#### Обычно документация по API содержит:
1. **Обзор**: объясняет, что делает API, какие данные или функциональные возможности он предоставляет и почему он полезен.
2. **Endpoint'ы**: в документации по API перечислены все доступные [endpoint'ы](#endpoint-api), в которых указано, к каким данным или действиям можно получить доступ через API.
3. **Методы запроса**: Эта часть объясняет, какие "действия" вы можете выполнять с каждым endpoint'ом. В мире API эти действия обычно представлены HTTP-методами GET, POST, PUT и DELETE.
4. **Параметры**: в документации API подробно описаны параметры, которые можно использовать при выполнении запросов API.
5. **Формат ответа**: документация по API подсказывает, какого рода ответ следует ожидать при использовании endpoint’а, объясняя формат данных, которые возвращает API.
6. **Обработка ошибок**: В документации по API приводятся инструкции о том, как API обрабатывает ошибки, реагируя на недействительные или неожиданные входные данные.
7. **Примеры**: Документация по API может содержать примеры использования API, пригодные для тестирования сценариев.
8. **Аутентификация**: документация по API объясняет, как аутентифицировать себя для безопасного использования API.
9. **Ограничения и квоты**: документация к API содержит подробную информация об ограничениях API, например, по частоте использования.
#### Документация условно делится на:
+ классическую (веб-страница, полная статичных таблиц и параграфов). Она проста для чтения и понимания, но основным недостатком классического подхода является то, что такая документация может быть устаревшей;
+ динамическую. В большинстве случаев генерируется на лету. Пример динамической документации: https://petstore.swagger.io/. Динамическая документация является наиболее актуальной и в некоторых случаях может использоваться для выполнения запросов или даже генерации программного кода (например, генерации исходного кода для клиента API). 
##### Инструменты и спецификации динамической документации:
1. ```OpenAPI```<a id="openapi"></a>
   1. OpenAPI - спецификация для описания RESTful API. Определяет стандартный формат для создания машинно-читабельной документации API, включающей в себя информацию о всех эндпоинтах, методах HTTP, параметрах, типах данных и так далее. OpenAPI Specification (OAS) предоставляет язык для описания интерфейсов API в формате JSON или YAML.
   2. OpenAPI JSON — это формат, используемый для описания API (интерфейсов прикладного программирования) с помощью спецификации OpenAPI. Использование OpenAPI JSON позволяет автоматизировать создание документации, генерацию клиентских и серверных библиотек и улучшить взаимодействие между различными частями системы. Основные компоненты OpenAPI JSON:
      1. openapi: Версия спецификации OpenAPI, используемой в документе.
      2. info: Метаданные об API, такие как название, версия, описание и контактная информация.
      3. servers: Список серверов, на которых доступен API.
      4. paths: Определения путей (endpoints), доступных в API, и методов (GET, POST, PUT, DELETE и т.д.), поддерживаемых каждым путем.
      5. components: Определения компонентов, используемых в API, таких как схемы данных (models), параметры, ответы, запросы и безопасность.
      6. security: Определение методов аутентификации и авторизации для API.
      7. tags: Список тегов для организации и группировки операций API.
      8. externalDocs: Ссылки на внешнюю документацию.
   3. Пример API с одним эндпоинтом /users, который поддерживает GET запрос для получения списка пользователей. В разделе components определяется схема User, описывающая структуру объекта пользователя
      ```json
      {
         "openapi": "3.0.0",
         "info": {
            "title": "Sample API",
            "description": "API для демонстрации OpenAPI спецификации",
            "version": "1.0.0"
         },
         "servers": [
            {
               "url": "https://api.example.com/v1"
            }
         ],
         "paths": {
            "/users": {
               "get": {
               "summary": "Получить список пользователей",
               "responses": {
                  "200": {
                     "description": "Успешный ответ",
                     "content": {
                     "application/json": {
                        "schema": {
                           "type": "array",
                           "items": {
                           "$ref": "#/components/schemas/User"
                           }
                        }
                     }
                     }
                  }
               }
               }
            }
         },
         "components": {
            "schemas": {
               "User": {
               "type": "object",
               "properties": {
                  "id": {
                     "type": "integer",
                     "format": "int64"
                  },
                  "name": {
                     "type": "string"
                  }
               }
               }
            }
         }
      }
      ```
2. ```Swagger```<a id="swagger"></a> - набор инструментов и экосистема для работы с API, созданная для поддержки и расширения возможностей, описанных в спецификации OpenAPI. Включает в себя следующие компоненты:
   1. Swagger Editor: Веб-редактор для создания и редактирования спецификаций OpenAPI.
   2. Swagger UI: Генератор пользовательского интерфейса для взаимодействия с API, описанным в спецификации OpenAPI. Этот инструмент позволяет пользователям легко тестировать API через веб-интерфейс.
   3. Swagger Codegen: Инструмент для генерации клиентских библиотек, серверных stubs и документации из спецификации OpenAPI.
   4. Swagger Inspector: Инструмент для тестирования API и генерации спецификаций OpenAPI из существующих API.

*Внимание!!! Чтобы понять, как спецификация OpenAPI в JSON может быть преобразована в человекочитаемую документацию по API, нужно посетить сайт https://editor.swagger.io/ и вставить приведенный выше "Пример API с одним эндпоинтом /users..." в редактор Swagger.*
### Примеры
1. Репозиторий [Public APIs](https://github.com/public-api-lists/public-api-lists) - это ресурс для разработчиков и широкой общественности. Он служит курируемой коллекцией публичных API из различных областей, облегчая разработчикам поиск и доступ к широкому спектру данных и сервисов. 
2. Документация по API на [GitHub](https://docs.github.com/en/rest) - это один из эталонных API в Интернете.
3. [Accuweather](https://developer.accuweather.com/) - один из публичных API сервисов прогнозов погоды.
## Авторизация и аутентификация API
### Аутентификация
Аутентификация - это процесс проверки подлинности личности пользователя, устройства или системы, пытающихся получить доступ к ресурсу. В контексте HTTP аутентификация часто включает в себя ввод имени пользователя и пароля, которые затем проверяются системой. Также могут использоваться и другие методы, такие как одноразовые пароли (OTP), отпечатки пальцев или двухфакторная аутентификация. После проверки подлинности пользователю предоставляется доступ к ресурсам системы. 
### Авторизация
Авторизация определяет уровень доступа **аутентифицированного пользователя** к определенным ресурсам и функциональным возможностям. Авторизация часто основывается на ролях или разрешениях, связанных с пользователем и не позволяет неавторизованным пользователям выполнять действия, выходящие за рамки их полномочий.
### API-токены
**API-токен** - это часть данных, которая используется для аутентификации и авторизации субъекта взаимодействия с API (пользователя, системы или приложения)

#### Ключевые моменты API-токенов:
1. *Аутентификация и авторизация*:  API может проверить токен, чтобы узнать, какими правами или ролями обладает носитель токена и, соответственно, предоставить или запретить доступ.
2. *Генерация токенов*: API-токены генерируются провайдером API или службой аутентификации после  аутентификации пользователя или приложения. Они уникальны для каждого субъекта взаимодействии с API.
3. *Истечение срока действия и аннулирование*: API-токены могут иметь срок действия, по истечении которого они становятся недействительными. Если токен скомпрометирован или больше не нужен, его можно отозвать, чтобы предотвратить дальнейший доступ. Для пользователя просроченный токен может выглядеть как просроченная сессия.
4. *Типы API-токенов*: Существуют различные типы API-токенов, в том числе:
   1. *API-ключ (API Keys)*:
      1. Описание:
         1. Простые строки: API-ключи обычно представляют собой простые строки или коды.
         2. Идентификация клиента: Основная цель API-ключей — аутентификация (идентификация) клиента, который делает запрос к API: чтобы API могло отличать одно приложение от другого и применять к ним разные правила доступа или квоты. Например:
            1. Разработчик регистрирует свое приложение в сервисе картографии и получает уникальный API Key.
            2. В приложении API Key используется для идентификации приложения при каждом запросе к API сервиса картографии.
            3. Сервис картографии использует API Key для отслеживания использования приложением и применяет разные правила доступа или квоты на основе зарегистрированных параметров приложения.
         3. Легкость использования: API-ключи легко интегрируются в запросы, часто просто добавляются в заголовок или параметр URL.
      2. Безопасность:
         1. Меньше безопасности: API-ключи не содержат информации о правах доступа или пользователе, их безопасность зависит от способа передачи (рекомендуется использовать HTTPS).
         2. Нет поддержки сроков действия: API-ключи обычно не имеют встроенного срока действия, что делает их более уязвимыми, если они будут скомпрометированы.
      3. Пример:
         1. предоставления API Keys в HTTP-заголовке
         ```console
         GET /api/resource HTTP/1.1
         Host: example.com
         X-API-Key: YOUR_API_KEY
         ```
         2. предоставления API Keys в URL-запросе
         ```console
         GET /api/resource?api_key=YOUR_API_KEY HTTP/1.1
         Host: example.com
         ```
   2. *Токен носителя (Bearer Tokens)*:
      1. Описание:
         1. Более сложные структуры: Токены носителя обычно представляют собой более сложные строки, часто сгенерированные с использованием протоколов аутентификации, таких как OAuth 2.0.
         2. Аутентификация и авторизация: Токены носителя не только идентифицируют клиента, но и предоставляют права доступа, встроенные в токен.
         3. Широкие возможности: Токены носителя могут содержать информацию о пользователе, правах доступа, времени действия и т.д.
      2. Безопасность:
         1. Повышенная безопасность: Токены носителя имеют ограниченный срок действия и могут быть отозваны, что делает их более безопасными.
         2. Часто используются вместе с HTTPS: Токены носителя передаются по защищенному соединению, что уменьшает риск их перехвата.
         3. Информация внутри токена: В случае JWT (JSON Web Tokens) токены содержат зашифрованную информацию о пользователе и его правах, что позволяет серверу быстро проверять токен без обращения к базе данных.

      3. Пример
         1. Запрос на получение токена:
            ```console
            POST /oauth/token HTTP/1.1
            Host: auth.example.com
            Content-Type: application/x-www-form-urlencoded

            grant_type=client_credentials&client_id=your_client_id&client_secret=your_client_secret
            ```
            Ответ:
            ```json
            {
            "access_token": "your_bearer_token_here",
            "token_type": "Bearer",
            "expires_in": 3600
            }
            ```
         2. Запрос к API с использованием токена носителя:
            ```console
            GET /v1/data HTTP/1.1
            Host: api.example.com
            Authorization: Bearer your_bearer_token_here
            ```
#### Алгоритм работы аутентификации на основе токена носителя (Bearer Tokens):
1. *Аутентификация пользователя*: Когда пользователь входит в систему, его учетные данные (обычно имя пользователя и пароль) отправляются на сервер аутентификации для проверки.
2. *Генерация токенов*: Если учетные данные пользователя действительны, сервер аутентификации генерирует уникальный токен. Этот токен связан с сессией пользователя и часто содержит информацию о его личности и разрешениях.
3. *Выдача токена*: Токен выдается пользователю, который затем предъявляет его при каждом последующем запросе на доступ к защищенному ресурсу или выполнение действия.
4. *Проверка подлинности*: Сервер, получивший токен, проверяет его действительность, убеждаясь, что срок его действия не истек и он не был подделан. Если токен действителен, доступ предоставляется; в противном случае запрос отклоняется.
<table><thead><tr><th style="width:18.0979%;"><br></th><th style="width:42.1696%;"><span>Bearer tokens</span></th><th style="width:40.1509%;"><span>API &nbsp;Keys</span></th></tr></thead><tbody><tr><td style="width:18.0979%;"><span>Безопасность</span></td><td style="width:42.1696%;"><p style="text-align:justify;">Считаются более безопасными, поскольку обычно имеют большую длину и генерируются криптографически. Они обеспечивают более высокий уровень безопасности и часто используются в потоках аутентификации на основе OAuth 2.0.</p></td><td style="width:40.1509%;text-align:justify;"><span>Ввиду простоты, они могут считаться менее безопасными, поскольку обычно являются статичными и могут быть легко перехвачены, если не передаются по защищенным соединениям.</span></td></tr><tr><td style="width:18.0979%;text-align:justify;"><span>Сценарий использования</span></td><td style="width:42.1696%;text-align:justify;">Часто используется, когда требуется более тонкий контроль доступа и безопасность, например, при доступе к пользовательским или конфиденциальным данным.<br></td><td style="width:40.1509%;text-align:justify;"><span>Обычно используется для простой аутентификации для доступа к общедоступным или менее чувствительным API.</span></td></tr><tr><td style="width:18.0979%;">Авторизация<br></td><td style="width:42.1696%;text-align:justify;">Могут нести дополнительную информацию о разрешениях и ролях пользователя или клиента, что делает их пригодными для более сложных сценариев авторизации.<br></td><td style="width:40.1509%;text-align:justify;">Обычно используется для простой аутентификации без возможности передачи данных о конкретном пользователе.<br></td></tr><tr style="text-align:justify;"><td style="width:18.0979%;">Примеры<br></td><td style="width:42.1696%;text-align:justify;">Используется для авторизации пользователя для доступа к информации его личного профиля на платформе социальных сетей.<br></td><td style="width:40.1509%;text-align:justify;">Используется для доступа к публичному API погоды, где достаточно простого ключа.<br></td></tr></tbody></table>

